const L=Object.entries,st=Object.fromEntries,nt="ENTRIES",T="KEYS",R="VALUES",_="";class k{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case R:return this.value();case T:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const D=g!==t[F],w=o[p+F]+ +D,A=o[p+F+1]+1,z=o[m+F]+1,V=o[m+F+1]=Math.min(w,A,z);V<l&&(l=V)}if(l>s)continue t}W(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=M(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new k(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new k(this,T)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new k(this,R)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)q(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},q=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)q(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=M(e);n.set(o+t,s),n.delete(o)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",N="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},H=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},J=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){J(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?J(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},U={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K},X=Symbol("*"),At=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=dt[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){gt(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],D=at(y,m,e._documentCount,F,p,r),w=n*a*f*D,A=d.get(l);if(A){A.score+=w,lt(A.terms,t);const z=H(A.match,s);z?z.push(c):A.match[s]=[c]}else d.set(l,{score:w,terms:[t],match:{[s]:[c]}})}}return d},Ct=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:H(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...U.weights,...i},h=e._index.get(t.term),g=B(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);B(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);B(e,t.term,l,F,f,o,u,d,g)}return g},Q=(e,t,s={})=>{if(t===X)return At(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Q(e,g,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>Ct(e,a,i));return Y(c,i.combineWith)},Z=(e,t,s={})=>{const n=Q(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===X&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(G),o},Et=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Z(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class wt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...U,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new wt(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),bt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),tt=(e,t,s={})=>{const n={};return Z(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>j(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>j(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>j(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),L(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):bt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},et=(e,t,s={})=>Et(t,e,{fuzzy:.2,...s}).map(({suggestion:n})=>n),v=st(L(JSON.parse("{\"/\":{\"documentCount\":258,\"nextId\":258,\"documentIds\":{\"0\":\"1\",\"1\":\"1#冒泡排序\",\"2\":\"1#插入排序\",\"3\":\"1#选择排序\",\"4\":\"1#快速排序\",\"5\":\"2\",\"6\":\"2#_3-1-计算机网络\",\"7\":\"2#_3-1-1-osi与tcp-ip各层的结构与功能-都有哪些协议\",\"8\":\"2#应用层\",\"9\":\"2#运输层\",\"10\":\"2#网络层\",\"11\":\"2#数据链路层\",\"12\":\"2#物理层\",\"13\":\"2#总结一下\",\"14\":\"2#_3-1-2-tcp-三次握手和四次挥手-面试常客\",\"15\":\"2#tcp-三次握手漫画图解\",\"16\":\"2#为什么要三次握手\",\"17\":\"2#为什么要传回-syn\",\"18\":\"2#传了-syn-为啥还要传-ack\",\"19\":\"2#为什么要四次挥手\",\"20\":\"2#_3-1-2-tcp-udp-协议的区别\",\"21\":\"2#_3-1-3-tcp-协议如何保证可靠传输\",\"22\":\"2#_3-1-4-arq协议\",\"23\":\"2#停止等待arq协议\",\"24\":\"2#连续arq协议\",\"25\":\"2#_3-1-5-滑动窗口和流量控制\",\"26\":\"2#_3-1-6-拥塞控制\",\"27\":\"2#_3-1-7-在浏览器中输入url地址-显示主页的过程-面试常客\",\"28\":\"2#_3-1-8-状态码\",\"29\":\"2#_3-1-9-各种协议与http协议之间的关系\",\"30\":\"2#_3-1-10-http长连接-短连接\",\"31\":\"2#_3-1-11-http是不保存状态的协议-如何保存用户状态\",\"32\":\"2#_3-1-12-cookie的作用是什么-和session有什么区别\",\"33\":\"2#_3-1-13-http-1-0和http-1-1的主要区别是什么\",\"34\":\"2#_3-1-12-uri和url的区别是什么\",\"35\":\"2#_3-1-13-http-和-https-的区别\",\"36\":\"2#建议\",\"37\":\"2#参考\",\"38\":\"3\",\"39\":\"3#_1-输入一个网址到显示页面的过程-越详细越好\",\"40\":\"3#具体过程\",\"41\":\"3#dns-解析\",\"42\":\"3#解析过程\",\"43\":\"3#dns-优化\",\"44\":\"3#dns-缓存\",\"45\":\"3#dns-负载均衡\",\"46\":\"3#tcp-连接\",\"47\":\"3#https-协议\",\"48\":\"3#https-过程\",\"49\":\"3#http-请求\",\"50\":\"3#请求行\",\"51\":\"3#请求报头\",\"52\":\"3#请求正文\",\"53\":\"3#服务器处理请求并返回-http-报文\",\"54\":\"3#状态码\",\"55\":\"3#响应报头\",\"56\":\"3#响应报文\",\"57\":\"3#浏览器解析渲染页面\",\"58\":\"3#web-优化\",\"59\":\"3#总结\",\"60\":\"3#_2-https除了信息安全和身份认证还有什么优点\",\"61\":\"3#_3-常见的网络攻击手段\",\"62\":\"3#_4-解释dhcp的原理-执行过程-底层是用tcp还是udp\",\"63\":\"3#_5-一个网页平常很快-突然变慢你是怎么排查的\",\"64\":\"4\",\"65\":\"5\",\"66\":\"5#_2-2-java集合\",\"67\":\"5#_2-2-1-说说list-set-map三者的区别\",\"68\":\"5#_2-2-2-arraylist-与-linkedlist-区别\",\"69\":\"5#补充内容-randomaccess接口\",\"70\":\"5#补充内容-双向链表和双向循环链表\",\"71\":\"5#_2-2-3-arraylist-与-vector-区别呢-为什么要用arraylist取代vector呢\",\"72\":\"5#_2-2-4-说一说-arraylist-的扩容机制吧\",\"73\":\"5#_2-2-5-hashmap-和-hashtable-的区别\",\"74\":\"5#_2-2-6-hashmap-和-hashset区别\",\"75\":\"5#_2-2-7-hashset如何检查重复\",\"76\":\"5#_2-2-8-hashmap的底层实现\",\"77\":\"5#jdk1-8之前\",\"78\":\"5#jdk1-8之后\",\"79\":\"5#_2-2-9-hashmap-的长度为什么是2的幂次方\",\"80\":\"5#_2-2-10-hashmap-多线程操作导致死循环问题\",\"81\":\"5#_2-2-11-concurrenthashmap-和-hashtable-的区别\",\"82\":\"5#_2-2-12-concurrenthashmap线程安全的具体实现方式-底层具体实现\",\"83\":\"5#jdk1-7-上面有示意图\",\"84\":\"5#jdk1-8-上面有示意图\",\"85\":\"5#_2-2-13-comparable-和-comparator的区别\",\"86\":\"5#comparator定制排序\",\"87\":\"5#重写compareto方法实现按年龄来排序\",\"88\":\"5#_2-2-14-集合框架底层数据结构总结\",\"89\":\"5#collection\",\"90\":\"5#map\",\"91\":\"5#_2-2-15-如何选用集合\",\"92\":\"6\",\"93\":\"6#java基础\",\"94\":\"6#_1-string和stringbuffer和stringbuilder区别\",\"95\":\"6#_2-string为啥默认用final\",\"96\":\"6#_3-和equals区别-详细比如相同对象比较、以及相同integer\",\"97\":\"6#_4-hashmap和hashset\",\"98\":\"6#_5-集合类-比如arraylist底层有什么的\",\"99\":\"6#_6-多线程sleep和wait-以及-notify和notifyall\",\"100\":\"6#_7-如何创建线程-几种方式-再往深处扩展\",\"101\":\"6#_8-还有就是抽象类和接口的区别\",\"102\":\"6#_9-动态代理有哪些-有什么场景-区别\",\"103\":\"6#_10-int-和integer的区别\",\"104\":\"6#_11-jdbc和mybatis的区别\",\"105\":\"6#_12-和-区别\",\"106\":\"6#_13-分页查询除了使用limit-还能有哪种方式实现-pagehelper插件\",\"107\":\"6#_14-jvm的模型有什么\",\"108\":\"6#_15-jvm了解吗\",\"109\":\"6#_16-包括gc什么的-以及内部的一些东西\",\"110\":\"6#_17-http和https以及tcp-ip-以及socket\",\"111\":\"6#_18-runable和callable\",\"112\":\"6#_19-sychornized-和lock的区别-lock底层用的reentrantlock、readwritelock\",\"113\":\"6#_20-threadlocal-以及-volatile\",\"114\":\"6#_21-aqs-是原理\",\"115\":\"6#_22-线程池了解吗-有哪几种线程池-使用场景有哪些\",\"116\":\"6#_23-比如有4个线程执行-合并结果集\",\"117\":\"6#_24-锁细分-读写锁-偏向锁-自旋锁-轻量级锁-重量级锁\",\"118\":\"6#_25-阻塞队列和非阻塞队列-包括一些常用的队列的说明\",\"119\":\"6#_26-有界队列和无界队列-区别-为啥分有界和无界\",\"120\":\"6#_27-反射和jvm的执行引擎有什么区别\",\"121\":\"6#_28-tcp和udp的区别\",\"122\":\"6#_29-什么是面向连接-什么是面向无连接\",\"123\":\"6#_30-tcp的为什么是可靠连接\",\"124\":\"6#_31-拆包和装包是什么-连接这方面的\",\"125\":\"6#_32-spring和springmvc的常用注解\",\"126\":\"6#_33-spring的ioc和aop\",\"127\":\"6#_34-spring的bean是怎么管理-beanfactory以及applicationcontext\",\"128\":\"6#_35-springboot的注解-三大注解有什么作用\",\"129\":\"6#_36-springboot的compantscan扫描范围是所有的包还是到哪一层\",\"130\":\"6#_37-springcloud用过什么-削峰-限流-其他一些实战-看你用没用过\",\"131\":\"6#_38-future相关的\",\"132\":\"6#_39-servlet-的生命周期是\",\"133\":\"6#_40-session-和-application-的区别-已经cookie\",\"134\":\"6#_41-动态代理-jdk代理和cglib代理区别啥的\",\"135\":\"6#_42-run和start区别-整个过程还有什么\",\"136\":\"6#_43-spring执行机制\",\"137\":\"6#_44-spring事务-以及事务会问你事务除了acid外-还有脏读-不可重复读-幻读可详细说-事务的传播机制7种-事务的隔离级别-可能会出题-比如a方法使用事务-b方法没有使用-那么a调用b会有几种情况-你使用事务哪种级别\",\"138\":\"6#_45-mybatis的事务\",\"139\":\"6#_46-springmvc的执行流程\",\"140\":\"6#_47-线上的修改配置文件的环境比如数据库配置-怎么修改-是不是同一个目录下\",\"141\":\"6#_48-过滤器和拦截器区别-实战用到没有-怎么用的\",\"142\":\"6#_49-设计模式用过哪些-项目中用到的设计模式有哪些-说几个熟悉-可能再往深处扩展-比如你怎么实现-怎么写\",\"143\":\"6#_50-观察者模式和redis的订阅和消费\",\"144\":\"6#_51-netty有没有用过-netty的优势是啥-你为啥用-项目中怎么用的\",\"145\":\"6#_52-微服务和分布式区别\",\"146\":\"6#_53-微服务再细一点-我这边没怎么问-没用到\",\"147\":\"6#_54-dubbo和springcloud的区别\",\"148\":\"6#_55-dubbo和zk连接流程\",\"149\":\"6#_56-dubbo再往深处-比如负载均衡以及容错机制-再往深处\",\"150\":\"6#_57-zk了解吗-没怎么问我\",\"151\":\"6#数据库\",\"152\":\"6#_1-数据库优化方式\",\"153\":\"6#_2-sql优化方式\",\"154\":\"6#_3-索引-通过执行explain-优化索引-比如覆盖索引-最左原则-组合索引遇到的几种方式不同\",\"155\":\"6#_4-b-tree和b-tree区别\",\"156\":\"6#_5-innodb和myisam的区别\",\"157\":\"6#_6-数据库表设计\",\"158\":\"6#_7-三大范式\",\"159\":\"6#_8-数据库查询leftjoin以及其他join-出题考你-还有就是写sql-比如俩个表-只取a表中与b表不共用的那部分-怎么实现\",\"160\":\"6#中间件-rabbitmq、kafka、rocketmq\",\"161\":\"6#_1-使用的队列常见问题-如何保证消息一致性、保证消息不丢失、重复数据怎么处理-、生产者宕机-或者消费者宕机你怎么处理-、不消费怎么处理\",\"162\":\"6#_2-如果整个链路通的-但是数据不消费怎么处理\",\"163\":\"6#_3-rabbitmq的死信队列-原因-之后怎么处理\",\"164\":\"6#_4-会问rabbitmq和kakfa区别或者-和rockedmq区别\",\"165\":\"6#_5-如何保证消息不会被重复消费\",\"166\":\"6#redis\",\"167\":\"6#_1-redis的5种数据类型-使用场景-你项目中用到没有\",\"168\":\"6#string\",\"169\":\"6#hash\",\"170\":\"6#list\",\"171\":\"6#set\",\"172\":\"6#sorted-set\",\"173\":\"6#_2-redis的持久化-俩种方式-rdb和aof\",\"174\":\"6#_3-redis的订阅机制\",\"175\":\"6#jvm总结\",\"176\":\"6#_1-jvm调优实战说一下\",\"177\":\"6#_2-cms-gc的流程-cms-表示基于-标记清理的垃圾回收器\",\"178\":\"6#_3-新生代和老年代标记算法优缺点\",\"179\":\"6#_4-oom的排查思路\",\"180\":\"6#_5-cms优缺点\",\"181\":\"6#_6-对象什么时候进入老年代\",\"182\":\"6#_7-什么时候触发fullgc\",\"183\":\"6#_8-模拟oom和stack-overflow场景\",\"184\":\"6#_9-栈什么时候oom\",\"185\":\"6#_10-怎么jvm中内存的使用情况\",\"186\":\"6#_11-jmap是怎么做到的\",\"187\":\"6#_12-java代码从编译到执行有哪些步骤\",\"188\":\"6#_13-类加载过程\",\"189\":\"6#_14-jar包冲突遇到过吗-jar包冲突时在类加载过程中哪一步报的错\",\"190\":\"6#_15-让你实现一个jvm-标记垃圾的具体步骤你怎么做-怎么扫描垃圾-这些信息维护在哪\",\"191\":\"6#实战总结\",\"192\":\"6#_1-分库分表的场景题-淘宝场景-买家卖家数据怎么存-怎么分库分表\",\"193\":\"6#_2-说说你在重构拆分中遇到的问题-你负责了哪些\",\"194\":\"6#_3-拆分你是怎么保证数据完整性的\",\"195\":\"6#_4-如果你当前系统压力-100倍你怎么设计\",\"196\":\"6#_5-如果根据压测流量路由到影子库\",\"197\":\"6#_6-https-tech-meituan-com-2018-09-27-quake-introduction-html\",\"198\":\"6#_7-分布式事务有没有了解过目前业内比较成熟的解决方案\",\"199\":\"6#_8-场景题-大量请求访问一份数据怎么设计-只说应用层面的-借用读写锁的思想\",\"200\":\"6#_9-分布式锁你们用什么实现的\",\"201\":\"6#_10-你怎么理解幂等\",\"202\":\"6#_11-你是怎么实现幂等的\",\"203\":\"6#_12-链路追踪你们怎么做的\",\"204\":\"6#_13-cpu负载很高一般是什么原因-排查思路是什么\",\"205\":\"6#linux总结\",\"206\":\"6#_1-top命令cpu利用率和load-average的区别\",\"207\":\"6#_2-load-average高但是cpu使用率不高是什么原因\",\"208\":\"6#数据结构-算法\",\"209\":\"6#_1-求链表长度-可能有环\",\"210\":\"6#_2-经典的上台阶问题\",\"211\":\"6#_3-多线程顺序打印\",\"212\":\"6#_4-括号匹配问题\",\"213\":\"6#_5-遍历树-写2种\",\"214\":\"6#_6-求树最大深度-用队列求\",\"215\":\"7\",\"216\":\"7#什么是mysql中的降序索引\",\"217\":\"8\",\"218\":\"8#将微服务运行在docker上\",\"219\":\"9\",\"220\":\"10\",\"221\":\"10#配置证书\",\"222\":\"10#创建一个存放证书目录\",\"223\":\"10#创建一键生成证书脚本\",\"224\":\"10#保存脚本后执行\",\"225\":\"10#修改docker配置\",\"226\":\"10#重载服务并重启docker\",\"227\":\"10#保存证书客户端文件到本地\",\"228\":\"10#测试证书是否配置成功\",\"229\":\"10#使用idea连接\",\"230\":\"11\",\"231\":\"12\",\"232\":\"12#精选评论\",\"233\":\"12#ben-zhong\",\"234\":\"12#讲师回复\",\"235\":\"12#潘\",\"236\":\"12#庚\",\"237\":\"12#讲师回复-1\",\"238\":\"12#的蜗牛\",\"239\":\"12#讲师回复-2\",\"240\":\"12#朋\",\"241\":\"12#讲师回复-3\",\"242\":\"12#kopelan\",\"243\":\"12#讲师回复-4\",\"244\":\"12#斯\",\"245\":\"12#讲师回复-5\",\"246\":\"12#佳\",\"247\":\"12#讲师回复-6\",\"248\":\"12#博\",\"249\":\"12#讲师回复-7\",\"250\":\"12#升\",\"251\":\"12#峰\",\"252\":\"12#讲师回复-8\",\"253\":\"12#_1156\",\"254\":\"12#讲师回复-9\",\"255\":\"13\",\"256\":\"14\",\"257\":\"15\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,25],\"2\":[1,26],\"3\":[1,26],\"4\":[1,37],\"5\":[1],\"6\":[3,14],\"7\":[6,13],\"8\":[1,60],\"9\":[1,31],\"10\":[1,42],\"11\":[1,34],\"12\":[1,20],\"13\":[1,13],\"14\":[7,3],\"15\":[2,15],\"16\":[1,20],\"17\":[2,26],\"18\":[4,29],\"19\":[1,36],\"20\":[6,42],\"21\":[4,37],\"22\":[4,12],\"23\":[1,85],\"24\":[1,33],\"25\":[4,10],\"26\":[4,79],\"27\":[8,19],\"28\":[4],\"29\":[4,4],\"30\":[5,39],\"31\":[6,42],\"32\":[6,42],\"33\":[7,74],\"34\":[5,22],\"35\":[8,43],\"36\":[1,15],\"37\":[1,22],\"38\":[1],\"39\":[3,25],\"40\":[1],\"41\":[2,25],\"42\":[1,38],\"43\":[2,26],\"44\":[2,26],\"45\":[2,37],\"46\":[2,12],\"47\":[2,32],\"48\":[2,20],\"49\":[2,17],\"50\":[1,22],\"51\":[1,49],\"52\":[1,20],\"53\":[3,29],\"54\":[1,48],\"55\":[1,4],\"56\":[1,7],\"57\":[1,107],\"58\":[2,45],\"59\":[1,29],\"60\":[2],\"61\":[2],\"62\":[4],\"63\":[4],\"64\":[1,3461],\"65\":[1],\"66\":[2,14],\"67\":[6,18],\"68\":[6,72],\"69\":[1,81],\"70\":[2,19],\"71\":[8,6],\"72\":[5,3],\"73\":[6,117],\"74\":[5,32],\"75\":[3,53],\"76\":[3],\"77\":[2,100],\"78\":[2,22],\"79\":[4,44],\"80\":[4,21],\"81\":[6,84],\"82\":[4],\"83\":[4,37],\"84\":[4,19],\"85\":[5,25],\"86\":[1,37],\"87\":[1,74],\"88\":[3],\"89\":[1,34],\"90\":[1,33],\"91\":[4,25],\"92\":[1,11],\"93\":[1],\"94\":[2,94],\"95\":[2],\"96\":[5,74],\"97\":[2],\"98\":[4,1],\"99\":[4],\"100\":[4],\"101\":[2],\"102\":[4],\"103\":[3],\"104\":[2],\"105\":[4],\"106\":[4],\"107\":[2],\"108\":[2],\"109\":[3],\"110\":[4],\"111\":[2],\"112\":[5],\"113\":[4],\"114\":[3],\"115\":[5],\"116\":[3],\"117\":[7],\"118\":[4],\"119\":[5],\"120\":[2],\"121\":[2],\"122\":[3],\"123\":[2],\"124\":[3],\"125\":[2],\"126\":[2],\"127\":[3],\"128\":[4],\"129\":[3],\"130\":[7],\"131\":[2],\"132\":[3],\"133\":[6],\"134\":[3],\"135\":[3],\"136\":[2],\"137\":[13],\"138\":[3],\"139\":[2],\"140\":[4],\"141\":[4],\"142\":[7],\"143\":[2],\"144\":[5],\"145\":[2],\"146\":[4],\"147\":[2],\"148\":[2],\"149\":[4],\"150\":[3],\"151\":[1],\"152\":[2],\"153\":[2],\"154\":[7],\"155\":[3],\"156\":[2],\"157\":[2],\"158\":[2],\"159\":[7],\"160\":[5],\"161\":[9],\"162\":[3],\"163\":[4],\"164\":[3],\"165\":[2],\"166\":[1],\"167\":[5],\"168\":[1,17],\"169\":[1,33],\"170\":[1,33],\"171\":[1,34],\"172\":[2,23],\"173\":[5],\"174\":[2],\"175\":[1],\"176\":[2],\"177\":[5],\"178\":[2],\"179\":[2],\"180\":[2],\"181\":[2],\"182\":[2],\"183\":[3],\"184\":[2],\"185\":[2],\"186\":[2],\"187\":[2],\"188\":[2],\"189\":[3],\"190\":[5],\"191\":[1],\"192\":[5],\"193\":[3],\"194\":[2],\"195\":[3],\"196\":[2],\"197\":[11],\"198\":[2],\"199\":[6],\"200\":[2],\"201\":[3],\"202\":[3],\"203\":[2],\"204\":[4],\"205\":[1],\"206\":[3],\"207\":[3],\"208\":[2],\"209\":[3],\"210\":[2],\"211\":[2],\"212\":[2],\"213\":[3],\"214\":[3],\"215\":[1],\"216\":[2,2917],\"217\":[1,486],\"218\":[1,366],\"219\":[2,726],\"220\":[1],\"221\":[1],\"222\":[1,7],\"223\":[1,84],\"224\":[1,3],\"225\":[1,37],\"226\":[1,6],\"227\":[1],\"228\":[1,10],\"229\":[1],\"230\":[1,21],\"231\":[1,489],\"232\":[1],\"233\":[3,16],\"234\":[2,4],\"235\":[2,1],\"236\":[2,1],\"237\":[2,8],\"238\":[2,5],\"239\":[2,6],\"240\":[2,6],\"241\":[2,9],\"242\":[2,12],\"243\":[2,8],\"244\":[2,3],\"245\":[2,7],\"246\":[2,8],\"247\":[2,6],\"248\":[2,20],\"249\":[2,12],\"250\":[2,2],\"251\":[2,1],\"252\":[2,8],\"253\":[2,8],\"254\":[2,6],\"255\":[1,3],\"256\":[1],\"257\":[1]},\"averageFieldLength\":[2.767441860465116,81.7581110467213],\"storedFields\":{\"0\":{\"h\":\"排序算法\"},\"1\":{\"h\":\"冒泡排序\",\"t\":[\"public static void bubbleSort(int[] arr) { if (arr == null || arr.length < 2) { return; } for (int e = arr.length - 1; e > 0; e--) { for (int i = 0; i < e; i++) { if (arr[i] > arr[i + 1]) { swap(arr, i, i + 1); } } } } \"]},\"2\":{\"h\":\"插入排序\",\"t\":[\"public static void insertionSort(int[] arr) { if (arr == null || arr.length < 2) { return; } for (int i = 1; i < arr.length; i++) { for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) { swap(arr, j, j + 1); } } } \"]},\"3\":{\"h\":\"选择排序\",\"t\":[\"public static void selectionSort(int[] arr) { if (arr == null || arr.length < 2) { return; } for (int i = 0; i < arr.length - 1; i++) { int minIndex = i; for (int j = i + 1; j < arr.length; j++) { minIndex = arr[j] < arr[minIndex] ? j : minIndex; } swap(arr, i, minIndex); } } \"]},\"4\":{\"h\":\"快速排序\",\"t\":[\"public static void quickSort(int[] arr, int l, int r) { if (l < r) { swap(arr, l + (int) (Math.random() * (r - l + 1)), r); int[] p = partition(arr, l, r); quickSort(arr, l, p[0] - 1); quickSort(arr, p[1] + 1, r); } } public static void quickSort(int[] arr) { if (arr == null || arr.length < 2) { return; } quickSort(arr, 0, arr.length - 1); } public static int[] partition(int[] arr, int l, int r) { int less = l - 1; int more = r; while (l < more) { if (arr[l] < arr[r]) { swap(arr, ++less, l++); } else if (arr[l] > arr[r]) { swap(arr, --more, l); } else { l++; } } swap(arr, more, r); return new int[] { less + 1, more }; } public static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } \"]},\"5\":{\"h\":\"计算机网络\"},\"6\":{\"h\":\"3.1 计算机网络\",\"t\":[\"作者：Guide哥。\",\"介绍: Github 70k Star 项目 JavaGuide（公众号同名） 作者。每周都会在公众号更新一些自己原创干货。公众号后台回复“1”领取Java工程师必备学习资料+面试突击pdf。\"]},\"7\":{\"h\":\"3.1.1 OSI与TCP/IP各层的结构与功能,都有哪些协议?\",\"t\":[\"学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。\",\"结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。\"]},\"8\":{\"h\":\"应用层\",\"t\":[\"应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。\",\"域名系统\",\"域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco公司的域名是 www.cisco.com 等。\",\"HTTP协议\",\"超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）\"]},\"9\":{\"h\":\"运输层\",\"t\":[\"运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。\",\"运输层主要使用以下两种协议:\",\"传输控制协议 TCP（Transmission Control Protocol）--提供面向连接的，可靠的数据传输服务。\",\"用户数据协议 UDP（User Datagram Protocol）--提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。\",\"TCP 与 UDP 的对比见问题三。\"]},\"10\":{\"h\":\"网络层\",\"t\":[\"在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。\",\"这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。\",\"这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.\",\"互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。\"]},\"11\":{\"h\":\"数据链路层\",\"t\":[\"数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。\",\"在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。\"]},\"12\":{\"h\":\"物理层\",\"t\":[\"在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。\",\"在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。\"]},\"13\":{\"h\":\"总结一下\",\"t\":[\"上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：https://blog.csdn.net/yaopeng_2005/article/details/7064869\",\")\"]},\"14\":{\"h\":\"3.1.2 TCP 三次握手和四次挥手(面试常客)\",\"t\":[\"为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。\"]},\"15\":{\"h\":\"TCP 三次握手漫画图解\",\"t\":[\"如下图所示，下面的两个机器人通过3次握手确定了对方能正确接收和发送消息(图片来源：《图解HTTP》)。 )\",\"简单示意图：)\",\"客户端–发送带有 SYN 标志的数据包–一次握手–服务端\",\"服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端\",\"客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端\"]},\"16\":{\"h\":\"为什么要三次握手\",\"t\":[\"三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。\",\"第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常\",\"第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常\",\"第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常\",\"所以三次握手就能确认双发收发功能都正常，缺一不可。\"]},\"17\":{\"h\":\"为什么要传回 SYN\",\"t\":[\"接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。\",\"SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。\"]},\"18\":{\"h\":\"传了 SYN,为啥还要传 ACK\",\"t\":[\"双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。\",\")\",\"断开一个 TCP 连接则需要“四次挥手”：\",\"客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送\",\"服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号\",\"服务器-关闭与客户端的连接，发送一个FIN给客户端\",\"客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1\"]},\"19\":{\"h\":\"为什么要四次挥手\",\"t\":[\"任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。\",\"举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。\",\"上面讲的比较概括，推荐一篇讲的比较细致的文章：https://blog.csdn.net/qzcsu/article/details/72861891\"]},\"20\":{\"h\":\"3.1.2 TCP,UDP 协议的区别\",\"t\":[\")\",\"UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等\",\"TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。\"]},\"21\":{\"h\":\"3.1.3 TCP 协议如何保证可靠传输\",\"t\":[\"应用数据被分割成 TCP 认为最适合发送的数据块。\",\"TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。\",\"校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。\",\"TCP 的接收端会丢弃重复的数据。\",\"流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）\",\"拥塞控制： 当网络拥塞时，减少数据的发送。\",\"ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。\",\"超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。\"]},\"22\":{\"h\":\"3.1.4 ARQ协议\",\"t\":[\"自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。\"]},\"23\":{\"h\":\"停止等待ARQ协议\",\"t\":[\"停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；\",\"在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；\",\"优点： 简单\",\"缺点： 信道利用率低，等待时间长\",\"1) 无差错情况:\",\"发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。\",\"2) 出现差错情况（超时重传）:\",\"停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。\",\"3) 确认丢失和确认迟到\",\"确认丢失 ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。\",\"确认迟到 ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。\"]},\"24\":{\"h\":\"连续ARQ协议\",\"t\":[\"连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\",\"优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。\",\"缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。\"]},\"25\":{\"h\":\"3.1.5 滑动窗口和流量控制\",\"t\":[\"TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\"]},\"26\":{\"h\":\"3.1.6 拥塞控制\",\"t\":[\"在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。\",\"为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。\",\"TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。\",\"慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。\",\"拥塞避免： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.\",\"快重传与快恢复： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。\"]},\"27\":{\"h\":\"3.1.7 在浏览器中输入url地址 ->> 显示主页的过程(面试常客)\",\"t\":[\"百度好像最喜欢问这个问题。\",\"打开一个网页，整个过程会使用哪些协议\",\"图解（图片来源：《图解HTTP》）：\",\"总体来说分为以下几个过程:\",\"DNS解析\",\"TCP连接\",\"发送HTTP请求\",\"服务器处理请求并返回HTTP报文\",\"浏览器解析渲染页面\",\"连接结束\",\"具体可以参考下面这篇文章：\",\"https://segmentfault.com/a/1190000006879700\"]},\"28\":{\"h\":\"3.1.8 状态码\"},\"29\":{\"h\":\"3.1.9 各种协议与HTTP协议之间的关系\",\"t\":[\"一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。\",\"图片来源：《图解HTTP》\"]},\"30\":{\"h\":\"3.1.10 HTTP长连接,短连接\",\"t\":[\"在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。\",\"而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：\",\"Connection:keep-alive \",\"在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\",\"HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。\",\"—— 《HTTP长连接、短连接究竟是什么？》\"]},\"31\":{\"h\":\"3.1.11 HTTP是不保存状态的协议,如何保存用户状态?\",\"t\":[\"HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。\",\"在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。\",\"Cookie 被禁用怎么办?\",\"最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。\"]},\"32\":{\"h\":\"3.1.12 Cookie的作用是什么?和Session有什么区别？\",\"t\":[\"Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。\",\"Cookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。\",\"Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。\",\"Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。\"]},\"33\":{\"h\":\"3.1.13 HTTP 1.0和HTTP 1.1的主要区别是什么?\",\"t\":[\"这部分回答引用这篇文章 https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A? 的一些内容。\",\"HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：\",\"长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。\",\"错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\",\"缓存处理 :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\",\"带宽优化及网络连接的使用 :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\"]},\"34\":{\"h\":\"3.1.12 URI和URL的区别是什么?\",\"t\":[\"URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。\",\"URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。\",\"URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。\"]},\"35\":{\"h\":\"3.1.13 HTTP 和 HTTPS 的区别？\",\"t\":[\"端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。\",\"安全性和资源消耗： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。 \",\"对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；\",\"非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。\"]},\"36\":{\"h\":\"建议\",\"t\":[\"非常推荐大家看一下 《图解HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。\"]},\"37\":{\"h\":\"参考\",\"t\":[\"https://blog.csdn.net/qq_16209077/article/details/52718250\",\"https://blog.csdn.net/zixiaomuwu/article/details/60965466\",\"https://blog.csdn.net/turn__back/article/details/73743641\",\"https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?\"]},\"38\":{\"h\":\"网络总结\"},\"39\":{\"h\":\"1.输入一个网址到显示页面的过程，越详细越好\",\"t\":[\"最近在进行前端面试方面的一些准备，看了网上许多相关的文章，发现有一个问题始终绕不开: 在浏览器中输入 URL 到整个页面显示在用户面前时这个过程中到底发生了什么。仔细思考这个问题，发现确实很深，这个过程涉及到的东西很多。这个问题的回答真的能够很好的考验一个 web 工程师的水平，于是我自问自答一番。\",\"总体来说分为以下几个过程:\",\"DNS 解析\",\"TCP 连接\",\"发送 HTTP 请求\",\"服务器处理请求并返回 HTTP 报文\",\"浏览器解析渲染页面\",\"连接结束\"]},\"40\":{\"h\":\"具体过程\"},\"41\":{\"h\":\"DNS 解析\",\"t\":[\"DNS 解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如 www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的 IP 地址，但是 IP 地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到 IP 地址的转换，这个过程就是 DNS 解析。它实际上充当了一个翻译的角色，实现了网址到 IP 地址的转换。网址到 IP 地址转换的过程是如何进行的?\"]},\"42\":{\"h\":\"解析过程\",\"t\":[\"DNS 解析是一个递归查询的过程。\",\"上述图片是查找 www.google.com 的 IP 地址过程。首先在本地域名服务器中查询 IP 地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向 com 顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到 google 的 IP 地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -> google.com -> www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是 www.google.com.，并不是我多打了一个.，这个. 对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求 DNS 的时候会自动加上，所有网址真正的解析过程为: . -> .com -> google.com. -> www.google.com.。\"]},\"43\":{\"h\":\"DNS 优化\",\"t\":[\"了解了 DNS 的过程，可以为我们带来哪些？上文中请求到 google 的 IP 地址时，经历了 8 个步骤，这个过程中存在多个请求 (同时存在 UDP 和 TCP 请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是 DNS 缓存。\"]},\"44\":{\"h\":\"DNS 缓存\",\"t\":[\"DNS 存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS 服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。\",\"在你的 chrome 浏览器中输入: chrome://dns/，你可以看到 chrome 浏览器的 DNS 缓存。\",\"系统缓存主要存在 / etc/hosts(Linux 系统) 中:\",\"...\"]},\"45\":{\"h\":\"DNS 负载均衡\",\"t\":[\"不知道大家有没有思考过一个问题: DNS 返回的 IP 地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS 可以返回一个合适的机器的 IP 给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是 DNS 负载均衡，又叫做 DNS 重定向。大家耳熟能详的 CDN(Content Delivery Network) 就是利用 DNS 的重定向技术，DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求，提供所需的内容。在这里打个免费的广告，我平时使用的比较多的是七牛云的 CDN(免费) 储存图片，作为我个人博客的图床使用。\"]},\"46\":{\"h\":\"TCP 连接\",\"t\":[\"HTTP 协议是使用 TCP 作为其传输层协议的，当 TCP 出现瓶颈时，HTTP 也会受到影响。但由于 TCP 优化这一块我平常接触的并不是很多，再加上大学时的计算机网络的基础基本上忘完，所以这一部分我也就不在这里分析了。\"]},\"47\":{\"h\":\"HTTPS 协议\",\"t\":[\"我不知道把 HTTPS 放在这个部分是否合适，但是放在这里好像又说的过去。HTTP 报文是包裹在 TCP 报文中发送的，服务器端收到 TCP 报文时会解包提取出 HTTP 报文。但是这个过程中存在一定的风险，HTTP 报文是明文，如果中间被截取的话会存在一些信息泄露的风险。那么在进入 TCP 报文之前对 HTTP 做一次加密就可以解决这个问题了。HTTPS 协议的本质就是 HTTP + SSL(or TLS)。在 HTTP 报文进入 TCP 报文之前，先使用 SSL 对 HTTP 报文进行加密。从网络的层级结构看它位于 HTTP 协议与 TCP 协议之间。\"]},\"48\":{\"h\":\"HTTPS 过程\",\"t\":[\"HTTPS 在传输数据之前需要客户端与服务器进行一个握手 (TLS/SSL 握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL 使用了非对称加密，对称加密以及 hash 等。具体过程请参考经典的阮一峰先生的博客 TLS/SSL 握手过程。 HTTPS 相比于 HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用 HTTPS 需要根据具体情况在安全和性能方面做出权衡。\"]},\"49\":{\"h\":\"HTTP 请求\",\"t\":[\"其实这部分又可以称为前端工程师眼中的 HTTP，它主要发生在客户端。发送 HTTP 请求的过程就是构建 HTTP 请求报文并通过 TCP 协议中发送到服务器指定端口 (HTTP 协议 80/8080, HTTPS 协议 443)。HTTP 请求报文是由三部分组成: 请求行, 请求报头和请求正文。\"]},\"50\":{\"h\":\"请求行\",\"t\":[\"格式如下:Method Request-URL HTTP-Version CRLF\",\"eg: GET index.html HTTP/1.1 \",\"常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。\",\"TODO：\",\"GET 和 POST 有什么区别？\"]},\"51\":{\"h\":\"请求报头\",\"t\":[\"请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。 PS: 客户端不一定特指浏览器，有时候也可使用 Linux 下的 CURL 命令以及 HTTP 客户端测试工具等。 常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent 等。\",\"上图是使用 Chrome 开发者工具截取的对百度的 HTTP 请求以及响应报文，从图中可以看出，请求报头中使用了 Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie 等字段。Accept 用于指定客户端用于接受哪些类型的信息，Accept-Encoding 与 Accept 类似，它用于指定接受的编码方式。Connection 设置为 Keep-alive 用于告诉客户端本次 HTTP 请求结束之后并不需要关闭 TCP 连接，这样可以使下次 HTTP 请求使用相同的 TCP 通道，节省 TCP 连接建立的时间。\"]},\"52\":{\"h\":\"请求正文\",\"t\":[\"当使用 POST, PUT 等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的 Web 应用通常采用 Rest 架构，请求的数据格式一般为 json。这时就需要设置 Content-Type: application/json。\"]},\"53\":{\"h\":\"服务器处理请求并返回 HTTP 报文\",\"t\":[\"自然而然这部分对应的就是后端工程师眼中的 HTTP。后端从在固定的端口接收到 TCP 报文开始，这一部分对应于编程语言中的 socket。它会对 TCP 连接进行处理，对 HTTP 协议进行解析，并按照报文格式进一步封装成 HTTP Request 对象，供上层使用。这一部分工作一般是由 Web 服务器去进行，我使用过的 Web 服务器有 Tomcat, Jetty 和 Netty 等等。\",\"HTTP 响应报文也是由三部分组成: 状态码, 响应报头和响应报文。\"]},\"54\":{\"h\":\"状态码\",\"t\":[\"状态码是由 3 位数组成，第一个数字定义了响应的类别，且有五种可能取值:\",\"1xx：指示信息–表示请求已接收，继续处理。\",\"2xx：成功–表示请求已被成功接收、理解、接受。\",\"3xx：重定向–要完成请求必须进行更进一步的操作。\",\"4xx：客户端错误–请求有语法错误或请求无法实现。\",\"5xx：服务器端错误–服务器未能实现合法的请求。 平时遇到比较常见的状态码有: 200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。\",\"TODO:\",\"301 和 302 有什么区别？\",\"HTTP 缓存\",\"该图是本公司对状态码的一个总结，绘制而成的 status code map，请大家参考。\"]},\"55\":{\"h\":\"响应报头\",\"t\":[\"常见的响应报头字段有: Server, Connection...。\"]},\"56\":{\"h\":\"响应报文\",\"t\":[\"服务器返回给浏览器的文本信息，通常 HTML, CSS, JS, 图片等文件就放在这一部分。\"]},\"57\":{\"h\":\"浏览器解析渲染页面\",\"t\":[\"浏览器在收到 HTML,CSS,JS 文件后，它是如何把页面呈现到屏幕上的？下图对应的就是 WebKit 渲染的过程。\",\"浏览器是一个边解析边渲染的过程。首先浏览器解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流) 和 repain(重绘)。DOM 节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为 relow; 当盒模型的位置, 大小以及其他属性，如颜色, 字体, 等确定下来之后，浏览器便开始绘制内容，这个过程称为 repain。页面在首次加载时必然会经历 reflow 和 repain。reflow 和 repain 过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少 reflow 和 repain。\",\"JS 的解析是由浏览器中的 JS 解析引擎完成的。JS 是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如 IO 读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务 (synchronous) 和异步任务(asynchronous)。JS 的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈; 异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。\",\"浏览器在解析过程中，如果遇到请求外部资源时，如图像, iconfont,JS 等。浏览器将重复 1-6 过程下载该资源。请求过程是异步的，并不会影响 HTML 文档进行加载，但是当文档加载过程中遇到 JS 文件，HTML 文档会挂起渲染过程，不仅要等到文档中 JS 文件加载完毕还要等待解析执行完毕，才会继续 HTML 的渲染过程。原因是因为 JS 有可能修改 DOM 结构，这就意味着 JS 执行完成前，后续所有资源的下载是没有必要的，这就是 JS 阻塞后续资源下载的根本原因。CSS 文件的加载不影响 JS 文件的加载，但是却影响 JS 文件的执行。JS 代码执行前浏览器必须保证 CSS 文件已经下载并加载完毕。\"]},\"58\":{\"h\":\"Web 优化\",\"t\":[\"上面部分主要介绍了一次完整的请求对应的过程，了解该过程的目的无非就是为了 Web 优化。在谈到 Web 优化之前，我们回到一个更原始的问题，Web 前端的本质是什么。我的理解是: 将信息快速并友好的展示给用户并能够与用户进行交互。快速的意思就是在尽可能短的时间内完成页面的加载，试想一下当你在淘宝购买东西的时候，淘宝页面加载了 10 几秒才显示出物品，这个时候你还有心情去购买吗？怎么快速的完成页面的加载呢？优雅的学院派雅虎给出了常用的一些手段，也就是我们熟悉的雅虎 34 条军规。这 34 军规实际上就是围绕请求过程进行的一些优化方式。\",\"如何尽快的加载资源？答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即 DNS 优化部分; 减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是 reflow，所以围绕这一部分就是考虑如何减少 reflow 的次数。\"]},\"59\":{\"h\":\"总结\",\"t\":[\"写这篇文章真的非常纠结，前前后后断断续续写了两个星期，因为涉及到的东西比较多，再加上有些东西记忆的没有那么清晰了，所以不好下笔。所涉及到的大部分内容，也基本上是一笔带过，只是给读者一个浅显的认知，当遇到相关的问题时，知道如何去查询。大家可以当成一篇 Web 开发的科普类文章去阅读。\",\"另外在这里为公司的产品打个广告，在 Chrome store 中搜索 DHC，这是一款超级好用的 Web 客户端工具，囊括了很多的功能: 报文分析，API 测试等等，可谓说是 WEB 工程师必备工具。\"]},\"60\":{\"h\":\"2.https除了信息安全和身份认证还有什么优点\"},\"61\":{\"h\":\"3.常见的网络攻击手段\"},\"62\":{\"h\":\"4.解释DHCP的原理，执行过程，底层是用TCP还是UDP\"},\"63\":{\"h\":\"5.一个网页平常很快，突然变慢你是怎么排查的？\"},\"64\":{\"h\":\"阿里云面试题\",\"t\":[\"http://note.youdao.com/noteshare?id=c10ecc5535e673b3f7fa396e57866569&sub=CA2841ACDA7C4A6B9C1D8EE4E5B4379E\",\"阿里云面试分享\",\"一、开场白\",\"简单的介绍一下自己的工作经历与职责，在校或者工作中主要的工作内容，主要负责的内容；（你的信息一清二白的写在简历上，这个主要为了缓解面试者的压力）\",\"介绍下自己最满意的，有技术亮点的项目或平台，重点介绍下自己负责那部分的技术细节；（主要考察应聘者对自己做过的事情是否有清晰的描述，判断做的事情的复杂度）\",\"二、Java多线程\",\"线程池的原理，为什么要创建线程池？创建线程池的方式；\",\"线程的生命周期，什么时候会出现僵死进程；\",\"说说线程安全问题，什么实现线程安全，如何实现线程安全；\",\"创建线程池有哪几个核心参数？ 如何合理配置线程池的大小？\",\"volatile、ThreadLocal的使用场景和原理；\",\"ThreadLocal什么时候会出现OOM的情况？为什么？\",\"synchronized、volatile区别、synchronized锁粒度、模拟死锁场景、原子性与可见性；\",\"三、JVM相关\",\"JVM内存模型，GC机制和原理；\",\"GC分哪两种，Minor GC 和Full GC有什么区别？什么时候会触发Full GC？分别采用什么算法？\",\"JVM里的有几种classloader，为什么会有多种？\",\"什么是双亲委派机制？介绍一些运作过程，双亲委派模型的好处；\",\"什么情况下我们需要破坏双亲委派模型；\",\"常见的JVM调优方法有哪些？可以具体到调整哪个参数，调成什么值？\",\"JVM虚拟机内存划分、类加载器、垃圾收集算法、垃圾收集器、class文件结构是如何解析的；\",\"四、Java扩展篇\",\"红黑树的实现原理和应用场景；\",\"NIO是什么？适用于何种场景？\",\"Java9比Java8改进了什么；\",\"HashMap内部的数据结构是什么？底层是怎么实现的？（还可能会延伸考察ConcurrentHashMap与HashMap、HashTable等，考察对技术细节的深入了解程度）；\",\"说说反射的用途及实现，反射是不是很慢，我们在项目中是否要避免使用反射；\",\"说说自定义注解的场景及实现；\",\"List 和 Map 区别，Arraylist 与 LinkedList 区别，ArrayList 与 Vector 区别；\",\"五、Spring相关\",\"Spring AOP的实现原理和场景？\",\"Spring bean的作用域和生命周期；\",\"Spring Boot比Spring做了哪些改进？ Spring 5比Spring4做了哪些改进；\",\"如何自定义一个Spring Boot Starter？\",\"Spring IOC是什么？优点是什么？\",\"SpringMVC、动态代理、反射、AOP原理、事务隔离级别；\",\"六、中间件篇\",\"Dubbo完整的一次调用链路介绍；\",\"Dubbo支持几种负载均衡策略？\",\"Dubbo Provider服务提供者要控制执行并发请求上限，具体怎么做？\",\"Dubbo启动的时候支持几种配置方式？\",\"了解几种消息中间件产品？各产品的优缺点介绍；\",\"消息中间件如何保证消息的一致性和如何进行消息的重试机制？\",\"Spring Cloud熔断机制介绍；\",\"Spring Cloud对比下Dubbo，什么场景下该使用Spring Cloud？\",\"七、数据库篇\",\"锁机制介绍：行锁、表锁、排他锁、共享锁；\",\"乐观锁的业务场景及实现方式；\",\"事务介绍，分布式事物的理解，常见的解决方案有哪些，什么事两阶段提交、三阶段提交；\",\"MySQL记录binlog的方式主要包括三种模式？每种模式的优缺点是什么？\",\"MySQL锁，悲观锁、乐观锁、排它锁、共享锁、表级锁、行级锁；\",\"分布式事务的原理2阶段提交，同步异步阻塞非阻塞；\",\"数据库事务隔离级别，MySQL默认的隔离级别、Spring如何实现事务、JDBC如何实现事务、嵌套事务实现、分布式事务实现；\",\"SQL的整个解析、执行过程原理、SQL行转列；\",\"八、Redis\",\"Redis为什么这么快？redis采用多线程会有哪些问题？\",\"Redis支持哪几种数据结构；\",\"Redis跳跃表的问题；\",\"Redis单进程单线程的Redis如何能够高并发?\",\"Redis如何使用Redis实现分布式锁？\",\"Redis分布式锁操作的原子性，Redis内部是如何实现的？\",\"九、其他\",\"看过哪些源代码？然后会根据你说的源码问一些细节的问题？（这里主要考察面试者是否对技术有钻研的精神，还是只停留在表面，还是背了几道面经，这个对于很多有强迫症的面试官，如果你连源码都没看过，基本上是会pass掉的，比如我也是这样的！）\",\"【解答参照】网址：https://shimo.im/docs/LUYuXUGSX8wTOzY7/ 《阿里云 - 面试总结》\",\"一、Java多线程\",\"1、线程池的原理，为什么要创建线程池？创建线程池的方式；\",\"原理：\",\"JAVA线程池原理详解一\",\"JAVA线程池原理详解二\",\"创建线程池的几种方式：\",\"ThreadPoolExecutor、ThreadScheduledExecutor、ForkJoinPool\",\"​ \",\"2、线程的生命周期，什么时候会出现僵死进程；\",\"​ \",\"​ 僵死进程是指子进程退出时，父进程并未对其发出的SIGCHLD信号进行适当处理，导致子进程停留在僵死状态等待其父进程为其收尸，这个状态下的子进程就是僵死进程。\",\"3、说说线程安全问题，什么是线程安全，如何实现线程安全；\",\"线程安全 - 如果线程执行过程中不会产生共享资源的冲突，则线程安全。\",\"线程不安全 - 如果有多个线程同时在操作主内存中的变量，则线程不安全\",\"实现线程安全的三种方式\",\"1）互斥同步\",\"临界区：syncronized、ReentrantLock\",\"信号量 semaphore\",\"互斥量 mutex\",\"2）非阻塞同步\",\"CAS（Compare And Swap）\",\"3）无同步方案\",\"可重入代码\",\"使用Threadlocal 类来包装共享变量，做到每个线程有自己的copy\",\"线程本地存储\",\"参考：https://blog.csdn.net/jackieeecheng/article/details/69779824\",\"4、创建线程池有哪几个核心参数？ 如何合理配置线程池的大小？\",\"1）核心参数\",\"public ThreadPoolExecutor(int corePoolSize, // 核心线程数量大小\",\"​ int maximumPoolSize, // 线程池最大容纳线程数\",\"​ long keepAliveTime, // 线程空闲后的存活时长\",\"​ TimeUnit unit,\",\"​ //缓存异步任务的队列 //用来构造线程池里的worker线程\",\"​ BlockingQueue workQueue,\",\"​ ThreadFactory threadFactory,\",\"​ //线程池任务满载后采取的任务拒绝策略\",\"​ RejectedExecutionHandler handler)\",\"核心说明\",\"1、当线程池中线程数量小于 corePoolSize 则创建线程，并处理请求。\",\"2、当线程池中线程数量大于等于 corePoolSize 时，则把请求放入 workQueue 中,随着线程池中的核心线程们不断执行任务，只要线程池中有空闲的核心线程，线程池就从 workQueue 中取任务并处理。\",\"3 、当 workQueue 已存满，放不下新任务时则新建非核心线程入池，并处理请求直到线程数目达到 maximumPoolSize（最大线程数量设置值）。\",\"4、如果线程池中线程数大于 maximumPoolSize 则使用 RejectedExecutionHandler 来进行任务拒绝处理。\",\"参考：http://gudong.name/2017/05/03/thread-pool-intro.html\",\"3)线程池大小分配\",\"线程池究竟设置多大要看你的线程池执行的什么任务了，CPU密集型、IO密集型、混合型，任务类型不同，设置的方式也不一样。\",\"任务一般分为：CPU密集型、IO密集型、混合型，对于不同类型的任务需要分配不同大小的线程池。\",\"3.1）CPU密集型\",\"尽量使用较小的线程池，一般Cpu核心数+1\",\"3.2）IO密集型\",\"方法一：可以使用较大的线程池，一般CPU核心数 * 2\",\"方法二：（线程等待时间与线程CPU时间之比 + 1）* CPU数目\",\"3.3）混合型\",\"可以将任务分为CPU密集型和IO密集型，然后分别使用不同的线程池去处理，按情况而定\",\"参考：https://www.cnblogs.com/cherish010/p/8334952.html\",\"5、volatile、ThreadLocal的使用场景和原理；\",\"volatile原理\",\"​ volatile变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写会到系统内存。\",\"​ Lock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。\",\"​ \",\"volatile的适用场景\",\"1）状态标志,如：初始化或请求停机\",\"2）一次性安全发布，如：单列模式\",\"3）独立观察，如：定期更新某个值\",\"4）“volatile bean” 模式\",\"开销较低的“读－写锁”策略，如：计数器\",\"参考：https://blog.csdn.net/hgc0907/article/details/79664102\",\"参考：https://www.ibm.com/developerworks/cn/java/j-jtp06197.html\",\"ThreadLocal原理\",\"​ ThreadLocal是用来维护本线程的变量的，并不能解决共享变量的并发问题。ThreadLocal是各线程将值存入该线程的map中，以ThreadLocal自身作为key，需要用时获得的是该线程之前存入的值。如果存入的是共享变量，那取出的也是共享变量，并发问题还是存在的。\",\"​ 参考：https://www.jianshu.com/p/ee8c9dccc953\",\"​ 参考：https://blog.csdn.net/xlgen157387/article/details/78297568\",\"​ \",\"ThreadLocal的适用场景\",\"场景：数据库连接、Session管理、\",\"参考：https://www.jianshu.com/p/cadd53f063b9\",\"6、ThreadLocal什么时候会出现OOM的情况？为什么？\",\"ThreadLocal变量是维护在Thread内部的，这样的话只要我们的线程不退出，对象的引用就会一直存在。当线程退出时，Thread类会进行一些清理工作，其中就包含ThreadLocalMap，Thread调用exit方法如下：\",\"​ \",\"ThreadLocal在没有线程池使用的情况下，正常情况下不会存在内存泄露，但是如果使用了线程池的话，就依赖于线程池的实现，如果线程池不销毁线程的话，那么就会存在内存泄露。\",\"参考：https://blog.csdn.net/xlgen157387/article/details/78297568\",\"7、synchronized、volatile区别\",\"volatile主要应用在多个线程对实例变量更改的场合，刷新主内存共享变量的值从而使得各个线程可以获得最新的值，线程读取变量的值需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。另外，synchronized还会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中（即释放锁前），从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作\",\"volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。\",\"volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞，比如多个线程争抢synchronized锁对象时，会出现阻塞。\",\"volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性，因为线程获得锁才能进入临界区，从而保证临界区中的所有语句全部得到执行。\",\"volatile标记的变量不会被编译器优化，可以禁止进行指令重排；synchronized标记的变量可以被编译器优化。\",\"参考：https://blog.csdn.net/xiaoming100001/article/details/79781680\",\"8、synchronized锁粒度、模拟死锁场景；\",\"synchronized：具有原子性，有序性和可见性\",\"参考：https://www.jianshu.com/p/cf57726e77f2\",\"粒度：对象锁、类锁\",\"死锁场景，参考：https://blog.csdn.net/u013925989/article/details/50208839\",\"二、JVM相关\",\"1、JVM内存模型，GC机制和原理；\",\"内存模型\",\"Jdk1.6及之前：有永久代, 常量池在方法区\",\"Jdk1.7：有永久代，但已经逐步“去永久代”，常量池在堆\",\"Jdk1.8及之后： 无永久代，常量池在元空间\",\"​ \",\"2、GC分哪两种，Minor GC 和Full GC有什么区别？什么时候会触发Full GC？分别采用什么算法？\",\"​ \",\"对象从新生代区域消失的过程，我们称之为 \\\"minor GC\\\"\",\"对象从老年代区域消失的过程，我们称之为 \\\"major GC\\\"\",\"Minor GC\",\"清理整个YouGen的过程，eden的清理，S0\\\\S1的清理都会由于MinorGC Allocation Failure(YoungGen区内存不足），而触发minorGC\",\"Major GC\",\"OldGen区内存不足，触发Major GC\",\"Full GC\",\"Full GC 是清理整个堆空间—包括年轻代和永久代\",\"Full GC 触发的场景\",\"1）System.gc\",\"2）promotion failed (年代晋升失败,比如eden区的存活对象晋升到S区放不下，又尝试直接晋升到Old区又放不下，那么Promotion Failed,会触发FullGC)\",\"3）CMS的Concurrent-Mode-Failure\",\"由于CMS回收过程中主要分为四步: 1.CMS initial mark 2.CMS Concurrent mark 3.CMS remark 4.CMS Concurrent sweep。在2中gc线程与用户线程同时执行，那么用户线程依旧可能同时产生垃圾， 如果这个垃圾较多无法放入预留的空间就会产生CMS-Mode-Failure， 切换为SerialOld单线程做mark-sweep-compact。\",\"4）新生代晋升的平均大小大于老年代的剩余空间 （为了避免新生代晋升到老年代失败）\",\"当使用G1,CMS 时，FullGC发生的时候 是 Serial+SerialOld。\",\"当使用ParalOld时，FullGC发生的时候是 ParallNew +ParallOld.\",\"3、JVM里的有几种classloader，为什么会有多种？\",\"启动类加载器：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等\",\"扩展类加载器：负责加载JRE扩展目录ext中JAR类包\",\"系统类加载器：负责加载ClassPath路径下的类包\",\"用户自定义加载器：负责加载用户自定义路径下的类包\",\"为什么会有多种：\",\"1）分工，各自负责各自的区块\",\"2）为了实现委托模型\",\"4、什么是双亲委派机制？介绍一些运作过程，双亲委派模型的好处；\",\"如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都不愿意干活，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，这不就是传说中的双亲委派模式。\",\"动作过程\",\"​ \",\"好处\",\"沙箱安全机制：自己写的String.class类不会被加载，这样便可以防止核心API库被随意篡改\",\"避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次\",\"5、什么情况下我们需要破坏双亲委派模型；\",\"<待补充>\",\"**6、常见的JVM调优方法有哪些？**可以具体到调整哪个参数，调成什么值？\",\"调优工具\",\"console，jProfile，VisualVM\",\"Dump线程详细信息：查看线程内部运行情况\",\"死锁检查\",\"查看堆内类、对象信息查看：数量、类型等\",\"线程监控\",\"线程信息监控：系统线程数量。\",\"线程状态监控：各个线程都处在什么样的状态下\",\"热点分析\",\"CPU热点：检查系统哪些方法占用的大量CPU时间\",\"内存热点：检查哪些对象在系统中数量最大（一定时间内存活对象和销毁对象一起统计）\",\"内存泄漏检查\",\"<待补充>\",\"7、JVM虚拟机内存划分、类加载器、垃圾收集算法、垃圾收集器、class文件结构是如何解析的；\",\"JVM虚拟机内存划分（重复）\",\"类加载器（重复）\",\"垃圾收集算法：标记-清除算法、复制算法、标记-整理算法、分代收集算法\",\"垃圾收集器： Serial收集器、ParNew收集器、Parallel Scavenge收集器、Serial Old收集器、ParallelOld收集器、CMS收集器、G1收集器、Z垃圾收集器\",\"class文件结构是如何解析的\",\"解悉过程：https://blog.csdn.net/sinat_38259539/article/details/78248454\",\"​ \",\"三、Java扩展篇\",\"1、红黑树的实现原理和应用场景；\",\"​ \",\"红黑树(一棵自平衡的排序二叉树)五大特性：\",\"1）每个结点要么是红的，要么是黑的。\",\"2）根结点是黑的。\",\"3）每个叶结点，即空结点是黑的。\",\"4）如果一个结点是红的，那么它的俩个儿子都是黑的。\",\"5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。\",\"场景\",\"1）广泛用于C++的STL中,map和set都是用红黑树实现的.\",\"2）著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块,进程的虚拟内存区域都存储在一颗红黑树上,每个虚拟地址区域都对应红黑树的一个节点,左指针指向相邻的地址虚拟存储区域,右指针指向相邻的高地址虚拟地址空间.\",\"3）IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查.\",\"4）ngnix中,用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器.\",\"5）java中的TreeSet,TreeMap\",\"2、NIO是什么？适用于何种场景？\",\"（New IO）为所有的原始类型（boolean类型除外）提供缓存支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。\",\"特性：I/O多路复用 + 非阻塞式I/O\",\"NIO适用场景\",\"服务器需要支持超大量的长时间连接。比如10000个连接以上，并且每个客户端并不会频繁地发送太多数据。例如总公司的一个中心服务器需要收集全国便利店各个收银机的交易信息，只需要少量线程按需处理维护的大量长期连接。\",\"Jetty、Mina、Netty、ZooKeeper等都是基于NIO方式实现。\",\"【NIO技术概览】\",\"3、Java9比Java8改进了什么；\",\"1）引入了模块系统，采用模块化系统的应用程序只需要这些应用程序所需的那部分JDK模块，而非是整个JDK框架了，减少了内存的开销。\",\"2）引入了一个新的package:java.net.http，里面提供了对Http访问很好的支持，不仅支持Http1.1而且还支持HTTP2。\",\"3）引入了jshell这个交互性工具，让Java也可以像脚本语言一样来运行，可以从控制台启动 jshell ，在 jshell 中直接输入表达式并查看其执行结果。\",\"4）增加了List.of()、Set.of()、Map.of()和Map.ofEntries()等工厂方法来创建不可变集合\",\"5）HTML5风格的Java帮助文档\",\"6）多版本兼容 JAR 功能，能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。\",\"7）统一 JVM 日志\",\"可以使用新的命令行选项-Xlog 来控制JVM 上 所有组件的日志记录。该日志记录系统可以设置输出的日志消息的标签、级别、修饰符和输出目标等。\",\"8）垃圾收集机制\",\"Java 9 移除了在 Java 8 中 被废弃的垃圾回收器配置组合，同时把G1设为默认的垃圾回收器实现.因为相对于Parallel来说，G1会在应用线程上做更多的事情，而Parallel几乎没有在应用线程上做任何事情，它基本上完全依赖GC线程完成所有的内存管理。这意味着切换到G1将会为应用线程带来额外的工作，从而直接影响到应用的性能\",\"9）I/O 流新特性\",\"java.io.InputStream 中增加了新的方法来读取和复制 InputStream 中包含的数据。\",\"readAllBytes：读取 InputStream 中的所有剩余字节。\",\"readNBytes： 从 InputStream 中读取指定数量的字节到数组中。\",\"transferTo：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中 。\",\"参考：\",\"java8新特性\",\"java9 新特性\",\"4、HashMap内部的数据结构是什么？底层是怎么实现的？\",\"HashMap内部结构\",\"jdk8以前：数组+链表\",\"jdk8以后：数组+链表 （当链表长度到8时，转化为红黑树）\",\"在并发的情况，发生扩容时，可能会产生循环链表，在执行get的时候，会触发死循环，引起CPU的100%问题，所以一定要避免在并发环境下使用HashMap。\",\"​ \",\"5、延伸考察ConcurrentHashMap与HashMap、HashTable等，考察对技术细节的深入了解程度；\",\"HashMap、HashTable、ConcurrentHashMap的原理与区别\",\"老生常谈，HashMap的死循环\",\"ConcurrentHashMap在jdk1.8中的改进\",\"谈谈ConcurrentHashMap1.7和1.8的不同实现\",\"深入分析ConcurrentHashMap1.8的扩容实现\",\"深入浅出ConcurrentHashMap1.8\",\"ConcurrentHashMap的红黑树实现分析\",\"6、说说反射的用途及实现，反射是不是很慢，我们在项目中是否要避免使用反射；\",\"一、用途\",\"反射被广泛地用于那些需要在运行时检测或修改程序行为的程序中。\",\"二、实现方式\",\"Foo foo = new Foo();\",\"第一种：通过Object类的getClass方法\",\"Classcla = foo.getClass();\",\"第二种：通过对象实例方法获取对象\",\"Classcla = foo.class;\",\"第三种：通过Class.forName方式\",\"Classcla = Class.forName(\\\"xx.xx.Foo\\\");\",\"三、缺点\",\"1）影响性能\",\"反射包括了一些动态类型，所以 JVM 无法对这些代码进行优化。因此，反射操作的效\",\"率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程\",\"序中使用反射。\",\"2）安全限制\",\"使用反射技术要求程序必须在一个没有安全限制的环境中运行。\",\"3）内部暴露\",\"由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方 法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。 反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。\",\"7、说说自定义注解的场景及实现；\",\"利用自定义注解,结合SpringAOP可以完成权限控制、日志记录、统一异常处理、数字签名、数据加解密等功能。\",\"实现场景（API接口数据加解密）\",\"1）自定义一个注解，在需要加解密的方法上添加该注解\",\"2）配置SringAOP环绕通知\",\"3）截获方法入参并进行解密\",\"4）截获方法返回值并进行加密\",\"8、List 和 Map 区别\",\"一、概述\",\"List是存储单列数据的集合，Map是存储键和值这样的双列数据的集合，\",\"List中存储的数据是有顺序，并且允许重复，值允许有多个null；\",\"Map中存储的数据是没有顺序的，键不能重复，值是可以有重复的，key最多有一个null。\",\"二、明细\",\"List\",\"1）可以允许重复的对象。\",\"2）可以插入多个null元素。\",\"3）是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。\",\"4）常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。\",\"Map\",\"1）Map不是collection的子接口或者实现类。Map是一个接口。\",\"2）Map 的 每个 Entry 都持有两个对象，也就是一个键一个值，Map 可能会持有相同的值对象但键对象必须是唯一的。\",\"3）TreeMap 也通过 Comparator 或者 Comparable 维护了一个排序顺序。\",\"4）Map 里你可以拥有随意个 null 值但最多只能有一个 null 键。\",\"5）Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用）\",\"Set（问题扩展）\",\"1）不允许重复对象\",\"2）无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator 或Comparable 维护了一个排序顺序。\",\"3）只允许一个 null 元素\",\"4）Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。\",\"三、场景（问题扩展）\",\"1）如果你经常会使用索引来对容器中的元素进行访问，那么 List 是你的正确的选择。如果你已经知道索引了的话，那么 List 的实现类比如 ArrayList 可以提供更快速的访问,如果经常添加删除元素的，那么肯定要选择LinkedList。\",\"2）如果你想容器中的元素能够按照它们插入的次序进行有序存储，那么还是 List，因为 List 是一个有序容器，它按照插入顺序进行存储。\",\"3）如果你想保证插入元素的唯一性，也就是你不想有重复值的出现，那么可以选择一个 Set 的实现类，比如 HashSet、LinkedHashSet 或者 TreeSet。所有 Set 的实现类都遵循了统一约束比如唯一性，而且还提供了额外的特性比如 TreeSet 还是一个 SortedSet，所有存储于 TreeSet 中的元素可以使用 Java 里的 Comparator 或者 Comparable 进行排序。LinkedHashSet 也按照元素的插入顺序对它们进行存储。\",\"4）如果你以键和值的形式进行数据存储那么 Map 是你正确的选择。你可以根据你的后续需要从 Hashtable、HashMap、TreeMap 中进行选择。\",\"参考：List、Set、Map的区别\",\"9、Arraylist 与 LinkedList 区别，ArrayList 与 Vector 区别；\",\"1）数据结构\",\"Vector、ArrayList内部使用数组，而LinkedList内部使用双向链表，由数组和链表的特性知：\",\"LinkedList适合指定位置插入、删除操作，不适合查找；\",\"ArrayList、Vector适合查找，不适合指定位置的插入删除操作。\",\"但是ArrayList越靠近尾部的元素进行增删时，其实效率比LinkedList要高\",\"2)线程安全\",\"Vector线程安全，ArrayList、LinkedList线程不安全。\",\"3）空间\",\"ArrayList在元素填满容器时会自动扩充容器大小的50%，而Vector则是100%，因此ArrayList更节省空间。\",\"参考：ArrayList和LinkedList内部实现、区别、使用场景\",\"四、Spring相关\",\"1、Spring AOP的实现原理和场景；\",\"​ AOP（Aspect Orient Programming），作为面向对象编程的一种补充，广泛应用于处理一些具有横切性质的系统级服务。\",\"一、场景\",\"事务管理、安全检查、权限控制、数据校验、缓存、对象池管理等\",\"二、实现技术\",\"AOP（这里的AOP指的是面向切面编程思想，而不是Spring AOP）主要的的实现技术主要有Spring AOP和AspectJ。\",\"1）AspectJ的底层技术。\",\"AspectJ的底层技术是静态代理，即用一种AspectJ支持的特定语言编写切面，通过一个命令来编译，生成一个新的代理类，该代理类增强了业务类，这是在编译时增强，相对于下面说的运行时增强，编译时增强的性能更好。\",\"2）Spring AOP\",\"Spring AOP采用的是动态代理，在运行期间对业务方法进行增强，所以不会生成新类，对于动态代理技术，Spring AOP提供了对JDK动态代理的支持以及CGLib的支持。\",\"​ JDK动态代理只能为接口创建动态代理实例，而不能对类创建动态代理。需要获得被目标类的接口信息（应用Java的反射技术），生成一个实现了代理接口的动态代理类（字节码），再通过反射机制获得动态代理类的构造函数，利用构造函数生成动态代理类的实例对象，在调用具体方法前调用invokeHandler方法来处理。\",\"​ CGLib动态代理需要依赖asm包，把被代理对象类的class文件加载进来，修改其字节码生成子类。\",\"​ 但是Spring AOP基于注解配置的情况下，需要依赖于AspectJ包的标准注解。\",\"2、Spring bean的作用域和生命周期；\",\"作用域\",\"​ \",\"生命周期\",\"​ \",\"3、Spring Boot比Spring做了哪些改进？\",\"1）SpringBoot可以建立独立的Spring应用程序；\",\"2）内嵌了如Tomcat，Jetty和Undertow这样的容器，也就是说可以直接跑起来，用不着再做部署工作了；\",\"3）无需再像Spring那样搞一堆繁琐的xml文件的配置；\",\"4）可以自动配置Spring。SpringBoot将原有的XML配置改为Java配置，将bean注入改为使用注解注入的方式(@Autowire)，并将多个xml、properties配置浓缩在一个appliaction.yml配置文件中。\",\"5）提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能；\",\"6）整合常用依赖（开发库，例如spring-webmvc、jackson-json、validation-api和tomcat等），提供的POM可以简化Maven的配置。当我们引入核心依赖时，SpringBoot会自引入其他依赖。\",\"Spring 5比Spring4做了哪些改进；\",\"【官网说明 】\",\"Spring 4.x新特性\",\"泛型限定式依赖注入\",\"核心容器的改进\",\"web开发增强\",\"集成Bean Validation 1.1（JSR-349）到SpringMVC\",\"Groovy Bean定义DSL\",\"更好的Java泛型操作API\",\"JSR310日期API的支持\",\"注解、脚本、任务、MVC等其他特性改进\",\"Spring 5.x新特性\",\"JDK8的增强\",\"核心容器的改进\",\"新的SpringWebFlux模块\",\"测试方面的改进\",\"参考：\",\"《Spring5官方文档》新功能\",\"Spring4新特性——泛型限定式依赖注入\",\"Spring4新特性——核心容器的其他改进\",\"Spring4新特性——Web开发的增强\",\"Spring4新特性——集成Bean Validation 1.1(JSR-349)到SpringMVC\",\"Spring4新特性——Groovy Bean定义DSL\",\"Spring4新特性——更好的Java泛型操作API\",\"Spring4新特性——JSR310日期API的支持\",\"Spring4新特性——注解、脚本、任务、MVC等其他特性改进\",\"如何自定义一个Spring Boot Starter？\",\"《自定义spring boot starter三部曲之一：准备工作》；\",\"《自定义spring boot starter三部曲之二：实战开发》；\",\"《自定义spring boot starter三部曲之三：源码分析spring.factories加载过程》；\",\"Spring IOC是什么？优点是什么？\",\"IoC文英全称Inversion of Control，即控制反转，我么可以这么理解IoC容器：“把某些业务对象的的控制权交给一个平台或者框架来同一管理，这个同一管理的平台可以称为IoC容器。”\",\"ioc的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处：\",\"1）资源集中管理，实现资源的可配置和易管理\",\"2）降低了使用资源双方的依赖程度，也就是我们说的耦合度\",\"Spring IOC原理解读 面试必读\",\"SpringMVC\",\"​ \",\"动态代理\",\"反射\",\"AOP原理\",\"Spring事务；\",\"​ \",\"一、spring事务\",\"什么是事务: 事务逻辑上的一组操作,组成这组操作的各个逻辑单元,要么一起成功,要么一起失败.\",\"二、事务特性（4种）:\",\"原子性 （atomicity）:强调事务的不可分割.\",\"一致性 （consistency）:事务的执行的前后数据的完整性保持一致.\",\"隔离性 （isolation）:一个事务执行的过程中,不应该受到其他事务的干扰\",\"持久性（durability） :事务一旦结束,数据就持久到数据库\",\"如果不考虑隔离性引发安全性问题:\",\"脏读 :一个事务读到了另一个事务的未提交的数据\",\"不可重复读 :一个事务读到了另一个事务已经提交的 update 的数据导致多次查询结果不一致.\",\"虚幻读 :一个事务读到了另一个事务已经提交的 insert 的数据导致多次查询结果不一致.\",\"三、解决读问题: 设置事务隔离级别（5种）\",\"DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.\",\"未提交读（read uncommited） :脏读，不可重复读，虚读都有可能发生\",\"已提交读 （read commited）:避免脏读。但是不可重复读和虚读有可能发生\",\"可重复读 （repeatable read） :避免脏读和不可重复读.但是虚读有可能发生.\",\"串行化的 （serializable） :避免以上所有读问题.\",\"Mysql 默认:可重复读\",\"Oracle 默认:读已提交\",\"四、事务的传播行为\",\"PROPAGION_XXX :事务的传播行为\",\"* 保证同一个事务中\",\"PROPAGATION_REQUIRED 支持当前事务，如果不存在 就新建一个(默认)\",\"PROPAGATION_SUPPORTS 支持当前事务，如果不存在，就不使用事务\",\"PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常\",\"* 保证没有在同一个事务中\",\"PROPAGATION_REQUIRES_NEW 如果有事务存在，挂起当前事务，创建一个新的事务\",\"PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务\",\"PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常\",\"PROPAGATION_NESTED 如果当前事务存在，则嵌套事务执行\",\"五、中间件篇\",\"Dubbo完整的一次调用链路介绍；\",\"​ \",\"参考：http://dubbo.apache.org/zh-cn/docs/dev/design.html\",\"Dubbo支持几种负载均衡策略？\",\"1）Random LoadBalance\",\"随机，按权重设置随机概率。\",\"在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\",\"2）RoundRobin LoadBalance\",\"轮询，按公约后的权重设置轮询比率。\",\"存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\",\"3）LeastActive LoadBalance\",\"最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。\",\"使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\",\"4）ConsistentHash LoadBalance\",\"一致性 Hash，相同参数的请求总是发到同一提供者。\",\"当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。\",\"算法参见：http://en.wikipedia.org/wiki/Consistent_hashing\",\"缺省只对第一个参数 Hash，如果要修改，请配置\",\"<dubbo:parameter key=\\\"hash.arguments\\\" value=\\\"0,1\\\" />\",\"缺省用 160 份虚拟节点，如果要修改，请配置\",\"<dubbo:parameter key=\\\"hash.nodes\\\" value=\\\"320\\\" />\",\"参考：http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html\",\"​ \",\"原码分析：http://www.cnblogs.com/wyq178/p/9822731.html\",\"Dubbo Provider服务提供者要控制执行并发请求上限，具体怎么做？\",\"服务端并发限流：executes\",\"客户端并发限流：actives\",\"样例 1\",\"限制 com.foo.BarService 的每个方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个：\",\"<dubbo:service interface=\\\"com.foo.BarService\\\" executes=\\\"10\\\" />\",\"样例 2\",\"限制 com.foo.BarService 的 sayHello 方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个：\",\"<dubbo:service interface=\\\"com.foo.BarService\\\">\",\"​ <dubbo:method name=\\\"sayHello\\\" executes=\\\"10\\\" />\",\"dubbo:service>\",\"样例 3\",\"限制 com.foo.BarService 的每个方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个：\",\"<dubbo:service interface=\\\"com.foo.BarService\\\" actives=\\\"10\\\" />\",\"或\",\"<dubbo:reference interface=\\\"com.foo.BarService\\\" actives=\\\"10\\\" />\",\"样例 4\",\"限制 com.foo.BarService 的 sayHello 方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个：\",\"<dubbo:service interface=\\\"com.foo.BarService\\\">\",\"​ <dubbo:method name=\\\"sayHello\\\" actives=\\\"10\\\" />\",\"dubbo:service>\",\"或\",\"<dubbo:reference interface=\\\"com.foo.BarService\\\">\",\"​ <dubbo:method name=\\\"sayHello\\\" actives=\\\"10\\\" />\",\"dubbo:service>\",\"参考：http://dubbo.apache.org/zh-cn/docs/user/demos/concurrency-control.html\",\"Dubbo启动的时候支持几种配置方式？\",\"XML配置\",\"http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html\",\"属性配置\",\"http://dubbo.apache.org/zh-cn/docs/user/configuration/properties.html\",\"API配置\",\"http://dubbo.apache.org/zh-cn/docs/user/configuration/api.html\",\"注解配置\",\"http://dubbo.apache.org/zh-cn/docs/user/configuration/annotation.html\",\"了解几种消息中间件产品？各产品的优缺点介绍；\",\"各种消息队列对比.pdf1MB\",\"消息中间件如何保证消息的一致性\",\"(1)主动方应用先把消息发送给消息中间件，消息状态标记为待确认;\",\"(2)消息中间件收到消息之后，把消息持久化到消息存储中，但并不向被动方应用投递消息；\",\"(3)消息中间件返回消息持久化结果（成功，或者失效），主动方应用根据返回结果进行判断如何处理业务操作处理；\",\"①失败：放弃业务操作处理，结束（必须向上层返回失败结果）\",\"②成功：执行业务操作处理\",\"(4)业务操作完成后，把业务操作结果（成功/失败）发送给消息中间件；\",\"(5)消息中间件收到业务操作结果后，根据结果进行处理；\",\"①失败：删除消息存储中的消息，结束；\",\"②成功：更新消息存储中的消息状态为·待发送（可发送）·，紧接着执行消息投递；\",\"(6)前面的正向流程都成功后，向被动方应用投递消息；\",\"​ \",\"如何进行消息的重试机制？\",\"参考：Rocket重试机制，消息模式，刷盘方式\",\"Spring Cloud熔断机制介绍；\",\"在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand，Hystrix会找有这个注解的方法，并将这类方法关联到和熔断器连在一起的代理上。当前，@HystrixCommand仅当类的注解为@Service或@Component时才会发挥作用。\",\"参考：http://www.cnblogs.com/lvgg/p/7843809.html\",\"Spring Cloud对比下Dubbo，什么场景下该使用Spring Cloud？\",\"两者所解决的问题域不一样：Dubbo的定位始终是一款RPC框架，而Spring Cloud的目的是微服务架构下的一站式解决方案。\",\"Spring Cloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。\",\"严格来说，这两种方式各有优劣。虽然在一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适。\",\"​ \",\"更多对比：http://blog.51cto.com/13954634/2296010\",\"六、数据库篇\",\"锁机制介绍：行锁、表锁、排他锁、共享锁；\",\"乐观锁的业务场景及实现方式；\",\"事务介绍，分布式事物的理解，常见的解决方案有哪些，什么是两阶段提交、三阶段提交；\",\"MySQL记录binlog的方式主要包括三种模式？每种模式的优缺点是什么？\",\"mysql复制主要有三种方式：基于SQL语句的复制(statement-based replication, SBR)，基于行的复制(row-based replication, RBR)，混合模式复制(mixed-based replication, MBR)。对应的，binlog的格式也有三种：STATEMENT，ROW，MIXED。\",\"① STATEMENT模式（SBR）\",\"每一条会修改数据的sql语句会记录到binlog中。优点是并不需要记录每一条sql语句和每一行的数据变化，减少了binlog日志量，节约IO，提高性能。缺点是在某些情况下会导致master-slave中的数据不一致( 如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题)\",\"② ROW模式（RBR）\",\"不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。而且不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是altertable的时候会让日志暴涨。\",\"③ MIXED模式（MBR）\",\"以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。\",\"MySQL锁，悲观锁、乐观锁、排它锁、共享锁、表级锁、行级锁；\",\"乐观锁\",\"用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。\",\"悲观锁\",\"在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中synchronized很相似，共享锁（读锁）和排它锁（写锁）是悲观锁的不同的实现\",\"共享锁（读锁）\",\"共享锁又叫做读锁，所有的事务只能对其进行读操作不能写操作，加上共享锁后在事务结束之前其他事务只能再加共享锁，除此之外其他任何类型的锁都不能再加了。\",\"排它锁（写锁）\",\"若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。\",\"表级锁\",\"innodb 的行锁是在有索引的情况下,没有索引的表是锁定全表的\",\"行级锁\",\"行锁又分共享锁和排他锁,由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。\",\"注意：行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。\",\"更多参考：https://blog.csdn.net/yzj5208/article/details/81288633\",\"分布式事务的原理2阶段提交，同步异步阻塞非阻塞；\",\"数据库事务隔离级别，MySQL默认的隔离级别\",\"Mysql默认隔离级别：Repeatable Read\",\"​ \",\"Spring如何实现事务\",\"参考：spring事务管理(详解和实例)\",\"​ \",\"Spring 事物四种实现方式：\",\"基于编程式事务管理实现\",\"基于TransactionProxyFactoryBean的声明式事务管理\",\"基于AspectJ的XML声明式事务管理\",\"基于注解的声明式事务管理\",\"参考：https://blog.csdn.net/zhuxinquan61/article/details/71075051\",\"JDBC如何实现事务\",\"在JDBC中处理事务，都是通过Connection完成的。\",\"同一事务中所有的操作，都在使用同一个Connection对象。\",\"①JDBC中的事务\",\"Connection的三个方法与事务有关：\",\"setAutoCommit（boolean）:设置是否为自动提交事务，如果true（默认值为true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置为false，那么相当于开启了事务了；con.setAutoCommit(false) 表示开启事务。\",\"commit（）：提交结束事务。\",\"rollback（）：回滚结束事务。\",\"示例代码\",\"try{\",\"con.setAutoCommit(false);//开启事务\",\"......\",\"con.commit();//try的最后提交事务\",\"} catch（） {\",\"con.rollback();//回滚事务\",\"}\",\"嵌套事务实现\",\"spring 事务嵌套:外层事务TraB,内层事务TraA、TraC\",\"场景1：\",\"TraA、TraC @Transactional（默认REQUIRED）\",\"TraB:\",\"​ traA.update(order1); (traA.update thrownew RuntimeException()😉\",\"​ traC.update(order2);\",\"结果:内外层事务全部回滚;\",\"场景2：\",\"TraA、TraC @Transactional（默认REQUIRED）\",\"TraB:\",\"​ traA.update(order1); (traA.update thrownew RuntimeException();trycatch traC.update)\",\"traC.update(order2);\",\"结果:内外层事务全部不回滚，traA中trycatch后的事务提交;\",\"场景3：\",\"TraA、TraC @Transactional（默认REQUIRED）\",\"TraB: try{(traA.update thrownew RuntimeException();\",\"​ 在外层TraB trycatch TraA)\",\"​ traA.update(order1);\",\"​ }catch(){}\",\"​ traC.update(order2);\",\"结果:内外层事务全部回滚,内层的异常抛出到外层捕获也会回滚;\",\"场景4：\",\"TraA @Transactional(propagation=Propagation.REQUIRES_NEW)、TraC @Transactional（默认REQUIRED）\",\"TraB:\",\"​ traA.update(order1); (traA.update thrownew RuntimeException()😉\",\"​ traC.update(order2);\",\"结果:内层事务回滚,外层事务继续提交;\",\"场景5：\",\"TraA @Transactional(propagation=Propagation.REQUIRES_NEW)、TraC @Transactional（默认REQUIRED）\",\"​ TraB:\",\"​ traA.update(order1); (traA.update thrownew RuntimeException();trycatch traC.update)\",\"​ traC.update(order2);\",\"结果:内外层事务全部不回滚，traA中trycatch后的事务提交,达到与场景2的同样效果;\",\"场景6：\",\"TraA @Transactional(propagation=Propagation.REQUIRES_NEW)、TraC @Transactional（默认REQUIRED）\",\"​ TraB:\",\"​ try{ (traA.update thrownew RuntimeException();在外层TraB trycatch TraA)\",\"​ traA.update(order1);\",\"​ } catch\",\"​ traC.update(order2);\",\"结果:内层事务回滚,外层事务不回滚;\",\"更多参考：https://blog.csdn.net/yangchangyong0/article/details/51960143\",\"分布式事务实现；\",\"1）基于XA协议的两阶段提交（2PC）\",\"XA 规范主要 定义了 ( 全局 ) 事务管理器 ( Transaction Manager ) 和 ( 局部 ) 资源管理器 ( Resource Manager ) 之间的接口。\",\"2）两阶段提交\",\"事务的提交分为两个阶段：\",\"预提交阶段(Pre-Commit Phase)\",\"决策后阶段（Post-Decision Phase）\",\"3）补偿事务（TCC）\",\"针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段\",\"Try 阶段主要是对业务系统做检测及资源预留\",\"Confirm 阶段主要是对业务系统做确认提交，Try 阶段执行成功并开始执行 Confirm 阶段时，默认Confirm 阶段是不会出错的。即：只要 Try 成功，Confirm 一定成功。\",\"Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放\",\"4）本地消息表（MQ 异步确保）\",\"其基本的设计思想是将远程分布式事务拆分成一系列的本地事务。\",\"5）MQ 事务消息\",\"有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。\",\"6）Sagas 事务模型\",\"该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Sagas 工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。\",\"7）其他补偿方式\",\"加入详细日志记录的，一旦系统内部引发类似致命异常，会有邮件通知。同时，后台会有定时任务扫描和分析此类日志，检查出这种特殊的情况，会尝试通过程序来补偿并邮件通知相关人员。\",\"在某些特殊的情况下，还会有 \\\"人工补偿\\\" 的，这也是最后一道屏障。\",\"参考：https://www.javazhiyin.com/573.html\",\"SQL的整个解析、执行过程原理、SQL行转列；\",\"整体架构\",\"​ \",\"SQL解析\",\"​ \",\"行转列、列转行\",\"参考：https://blog.csdn.net/jx_870915876/article/details/52403472\",\"七、Redis\",\"Redis为什么这么快？\",\"(1) 绝大部分请求是纯粹的内存操作（非常快速）\",\"(2) 采用单线程,避免了不必要的上下文切换和竞争条件\",\"(3) 非阻塞IO - IO多路复用\",\"redis采用多线程会有哪些问题？\",\"1）单线程的问题\",\"无法发挥多核CPU性能，单进程单线程只能跑满一个CPU核\",\"可以通过在单机开多个Redis实例来完善\",\"可以通过数据分片来增加吞吐量，问题（不支持批量操作、扩缩容复杂等）\",\"2）多线程的问题\",\"多线程处理可能涉及到锁\",\"多线程处理会涉及到线程切换而消耗CPU\",\"参考：阿里云Redis多线程性能提升思路解析\",\"Redis支持哪几种数据结构；\",\"String 、List 、Set 、Hash 、ZSet\",\"Redis跳跃表的问题；\",\"Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群结点中用作内部数据结构\",\"参考：https://blog.csdn.net/idwtwt/article/details/80233859\",\"Redis是单进程单线程的，如何能够高并发?\",\"采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）\",\"Redis如何使用Redis实现分布式锁？\",\"参考：Redis分布式锁的正确实现方式\",\"Redis分布式锁操作的原子性，Redis内部是如何实现的？\",\"setnx\",\"Incrby\\\\Decrby\",\"java终级面试题\",\"Vector,ArrayList, LinkedList的区别是什么？\",\"答：\",\"Vector、ArrayList都是以类似数组的形式存储在内存中，LinkedList则以链表的形式进行存储。\",\"List中的元素有序、允许有重复的元素，Set中的元素无序、不允许有重复元素。\",\"Vector线程同步，ArrayList、LinkedList线程不同步。\",\"LinkedList适合指定位置插入、删除操作，不适合查找；ArrayList、Vector适合查找，不适合指定位置的插入、删除操作。\",\"ArrayList在元素填满容器时会自动扩充容器大小的50%，而Vector则是100%，因此ArrayList更节省空间。\",\"HashTable, HashMap，TreeMap区别？\",\"答：\",\"HashTable线程同步，HashMap非线程同步。\",\"HashTable不允许<键,值>有空值，HashMap允许<键,值>有空值。\",\"HashTable使用Enumeration，HashMap使用Iterator。\",\"HashTable中hash数组的默认大小是11，增加方式的old*2+1，HashMap中hash数组的默认大小是16，增长方式一定是2的指数倍。\",\"TreeMap能够把它保存的记录根据键排序，默认是按升序排序。\",\"HashMap的数据结构\",\"jdk1.8之前list + 链表\",\"jdk1.8之后list + 链表（当链表长度到8时，转化为红黑树）\",\"HashMap的扩容因子\",\"默认0.75，也就是会浪费1/4的空间，达到扩容因子时，会将list扩容一倍，0.75 是时间与空间一个平衡值；\",\"多线程修改HashMap\",\"多线程同时写入，同时执行扩容操作，多线程扩容可能死锁、丢数据；可以对HashMap 加入同步锁Collections.synchronizedMap(hashMap)，但是效率很低，因为该锁是互斥锁，同一时刻只能有一个线程执行读写操作，这时候应该使用ConcurrentHashMap\",\"LinkedHashMap\",\"Java LinkedHashMap工作原理及实现\",\"Java集合框架：LinkedHashMap\",\"注意：在使用Iterator遍历的时候，LinkedHashMap会产生java.util.ConcurrentModificationException。\",\"扩展HashMap增加双向链表的实现，号称是最占内存的数据结构。支持iterator()时按Entry的插入顺序来排序(但是更新不算， 如果设置accessOrder属性为true，则所有读写访问都算)。实现上是在Entry上再增加属性before/after指针，插入时把自己加到Header Entry的前面去。如果所有读写访问都要排序，还要把前后Entry的before/after拼接起来以在链表中删除掉自己。\",\"说说你知道的几个Java集合类：list、set、queue、map实现类\",\"描述一下ArrayList和LinkedList各自实现和区别\",\"Java基础篇(四):ArrayList和LinkedList内部实现、区别、使用场景\",\"Java中的队列都有哪些，有什么区别\",\"ArrayDeque, （数组双端队列）\",\"PriorityQueue, （优先级队列）\",\"ConcurrentLinkedQueue, （基于链表的并发队列）\",\"DelayQueue, （延期阻塞队列）（阻塞队列实现了BlockingQueue接口）\",\"ArrayBlockingQueue, （基于数组的并发阻塞队列）\",\"LinkedBlockingQueue, （基于链表的FIFO阻塞队列）\",\"LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列）\",\"PriorityBlockingQueue, （带优先级的无界阻塞队列）\",\"SynchronousQueue （并发同步阻塞队列）\",\"反射中，Class.forName和classloader的区别\",\"java反射中，Class.forName和classloader的区别(代码说话)\",\"Java7、Java8的新特性\",\"java7,8的几个特性\",\"Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高\",\"讲讲IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞\",\"Java IO流详解（二）——IO流的框架体系\",\"讲讲NIO\",\"NIO技术概览\",\"缓冲区\",\"虚拟内存&&内存空间的映射\",\"三个channel使用 ServerSocketChannel||SocketChannel||FileChannel\",\"Java NIO系列教程（八） SocketChannel\",\"Java NIO系列教程（九） ServerSocketChannel\",\"Java NIO系列教程（七） FileChannel\",\"String 编码UTF-8 和GBK的区别\",\"GBK编码：是指中国的中文字符，其实它包含了简体中文与繁体中文字符，另外还有一种字符“gb2312”，这种字符仅能存储简体中文字符。\",\"UTF-8编码：它是一种全国家通过的一种编码，如果你的网站涉及到多个国家的语言，那么建议你选择UTF-8编码。\",\"GBK和UTF8有什么区别？\",\"UTF8编码格式很强大，支持所有国家的语言，正是因为它的强大，才会导致它占用的空间大小要比GBK大，对于网站打开速度而言，也是有一定影响的。\",\"GBK编码格式，它的功能少，仅限于中文字符，当然它所占用的空间大小会随着它的功能而减少，打开网页的速度比较快。\",\"什么时候使用字节流、什么时候使用字符流\",\"什么时候使用字节流、什么时候使用字符流，二者的区别\",\"递归读取文件夹下的文件，代码怎么实现\",\"/** * 递归读取文件夹下的 所有文件 * * @param testFileDir 文件名或目录名 */ private static void testLoopOutAllFileName(String testFileDir) { if (testFileDir == null) { //因为new File(null)会空指针异常,所以要判断下 return; } File[] testFile = new File(testFileDir).listFiles(); if (testFile == null) { return; } for (File file : testFile) { if (file.isFile()) { System.out.println(file.getName()); } else if (file.isDirectory()) { System.out.println(\\\"-------this is a directory, and its files are as follows:-------\\\"); testLoopOutAllFileName(file.getPath()); } else { System.out.println(\\\"文件读入有误！\\\"); } } }\",\"Object.finalize\",\"深入分析Object.finalize方法的实现原理\",\"SynchronousQueue实现原理\",\"SynchronousQueue实现原理\",\"跳表SkipList\",\"跳表（SkipList）及ConcurrentSkipListMap源码解析\",\"Collections.sort排序算法\",\"深入jdk——追踪Collections.sort 引发的bug（1）mergeSort\",\"自定义类加载器\",\"JVM——自定义类加载器\",\"Java并发和并行\",\"并发 : 是指两个或多个事件在同一时间间隔发生,在一台处理器上“同时”处理多个任务;\",\"并行 : 是指两个或者多个事件在同一时刻发生,在多台处理器上同时处理多个任务。\",\"怎么提高并发量，请列举你所知道的方案？\",\"高并发解决方案——提升高并发量服务器性能解决思路\",\"系统的用户量有多少？多用户并发访问时如何解决？\",\"大型网站是怎样解决多用户高并发访问的\",\"说说阻塞队列的实现：可以参考ArrayBlockingQueue的底层实现（锁和同步都行）\",\"Java阻塞队列ArrayBlockingQueue和LinkedBlockingQueue实现原理分析\",\"进程通讯的方式：消息队列，共享内存，信号量，socket通讯等\",\"Linux进程间通信方式--信号，管道，消息队列，信号量，共享内存\",\"用过并发包的哪些类\",\"Excutors可以产生哪些线程池\",\"为什么要用线程池\",\"为什么要使用线程池\",\"线程池的基础概念\",\"core,maxPoolSize,keepalive\",\"执行任务时\",\"如果线程池中线程数量 < core，新建一个线程执行任务；\",\"如果线程池中线程数量 >= core ,则将任务放入任务队列\",\"如果线程池中线程数量 >= core 且 < maxPoolSize，则创建新的线程；\",\"如果线程池中线程数量 > core ,当线程空闲时间超过了keepalive时，则会销毁线程；由此可见线程池的队列如果是无界队列，那么设置线程池最大数量是无效的；\",\"自带线程池的各种坑\",\"Executors.newFixedThreadPool(10);\",\"固定大小的线程池：\",\"它的实现new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue());\",\"初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize，使用LinkedBlockingQuene作为阻塞队列，当线程池没有可执行任务时，也不会释放线程。\",\"由于LinkedBlockingQuene的特性，这个队列是无界的，若消费不过来，会导致内存被任务队列占满，最终oom；\",\"Executors.newCachedThreadPool();\",\"缓存线程池：\",\"它的实现new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue());\",\"初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列；和newFixedThreadPool创建的线程池不同，newCachedThreadPool在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销，因为线程池的最大值了Integer.MAX_VALUE，会导致无限创建线程；所以，使用该线程池时，一定要注意控制并发的任务数，否则创建大量的线程会导致严重的性能问题;\",\"Executors.newSingleThreadExecutor()\",\"单线程线程池：\",\"同newFixedThreadPool线程池一样，队列用的是LinkedBlockingQueue无界队列，可以无限的往里面添加任务，直到内存溢出；\",\"volatile关键字的用法：使多线程中的变量可见\",\"Java并发编程：volatile关键字解析\",\"线程的几种状态\",\"线程在一定条件下，状态会发生变化。线程一共有以下几种状态：\",\"新建状态(New)：新创建了一个线程对象。\",\"就绪状态(Runnable)：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。\",\"运行状态(Running)：就绪状态的线程获取了CPU，执行程序代码。\",\"阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。\",\"阻塞的情况分三种：\",\"等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，\",\"同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。\",\"其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\",\"死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\",\"常用的线程池模式以及不同线程池的使用场景\",\"java线程池与五种常用线程池策略使用与解析\",\"newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。\",\"多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。\",\"了解可重入锁的含义，以及ReentrantLock 和synchronized的区别\",\"同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高\",\"atomicinteger和Volatile等线程安全操作的关键字的理解和使用\",\"CAS和volatile关键字\",\"通过volatile修饰的变量可以保证线程之间的可见性，但并不能保证字节码指令的原子执行，在多线程并发执行下，无法做到线程安全，得到正确的结果\",\"加锁(低效率)\",\"cas\",\"引用占小狼的简书：面试必问的CAS，要多了解\",\"线程间通信，wait和notify\",\"wait和notify的理解与使用\",\"定时线程的使用\",\"场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。\",\"java线程池主线程等待子线程执行完成\",\"进程和线程的区别\",\"进程：\",\"是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独立运行的一段程序(比如正在运行的某个java程序)。\",\"线程：\",\"他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源(一个线程只能属于一个进程，而一个进程可以有多个线程)。\",\"什么叫线程安全？举例说明\",\"java中的线程安全是什么：\",\"就是线程同步的意思，就是当一个程序对一个线程安全的方法或者语句进行访问的时候，其他的不能再对他进行操作了，必须等到这次访问结束以后才能对这个线程安全的方法进行访问\",\"什么叫线程安全：\",\"如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，\",\"就是线程安全的。\",\"或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。\",\"线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。\",\"存在竞争的线程不安全，不存在竞争的线程就是安全的\",\"并发、同步的接口或方法\",\"Java并发编程的类、接口和方法\",\"HashMap 是否线程安全，为何不安全。 ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。\",\"深入浅出ConcurrentHashMap1.8\",\"谈谈ConcurrentHashMap1.7和1.8的不同实现\",\"ConcurrentHashMap的红黑树实现分析\",\"深入分析ConcurrentHashMap1.8的扩容实现\",\"老生常谈，HashMap的死循环\",\"J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。\",\"volatile的理解\",\"java volatile关键字解惑\",\"面试必问的volatile，你了解多少？\",\"Tomcat并发\",\"Tomcat的性能与最大并发配置\",\"有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?\",\"高并发情况下，我们系统是如何支撑大量的请求的\",\"尽量使用缓存，包括用户缓存，信息缓存等，多花点内存来做缓存，可以大量减少与数据库的交互，提高性能。\",\"用jprofiler等工具找出性能瓶颈，减少额外的开销。\",\"优化数据库查询语句，减少直接使用hibernate等工具的直接生成语句（仅耗时较长的查询做优化）。\",\"优化数据库结构，多做索引，提高查询效率。\",\"统计的功能尽量做缓存，或按每天一统计或定时统计相关报表，避免需要时进行统计的功能。\",\"能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。\",\"解决以上问题后，使用服务器集群来解决单台的瓶颈问题。\",\"HTML静态化\",\"效率最高、消耗最小的就是纯静态化的html页面，所以尽可能使网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。但是对于大量内容并且频繁更新的网站，无法全部手动去挨个实现，于是出现了常见的信息发布系统CMS，像常访问的各个门户站点的新闻频道，甚至他们的其他频道，都是通过信息发布系统来管理和实现的，信息发布系统可以实现最简单的信息录入自动生成静态页面，还能具备频道管理、权限管理、自动抓取等功能，对于一个大型网站来说，拥有一套高效、可管理的CMS是必不可少的。\",\"图片服务器分离\",\"对于Web服务器来说，不管是Apache、IIS还是其他容器，图片是最消耗资源的，于是有必要将图片与页面进行分离，这是基本上大型网站都会采用的策略，他们都有独立的图片服务器，甚至很多台图片服务器。这样的架构可以降低提供页面访问请求的服务器系统压力，并且可以保证系统不会因为图片问题而崩溃，在应用服务器和图片服务器上，可以进行不同的配置优化，比如apache在配置ContentType的时候可以尽量少支持，尽可能少的LoadModule，保证更高的系统消耗和执行效率。 这一实现起来是比较容易的一现，如果服务器集群操作起来更方便，如果是独立的服务器，新手可能出现上传图片只能在服务器本地的情况下，可以在令一台服务器设置的IIS采用网络路径来实现图片服务器，即不用改变程序，又能提高性能，但对于服务器本身的IO处理性能是没有任何的改变。\",\"数据库集群和库表散列\",\"大型网站都有复杂的应用，这些应用必须使用数据库，那么在面对大量访问的时候，数据库的瓶颈很快就能显现出来，这时一台数据库将很快无法满足应用，于是需要使用数据库集群或者库表散列。\",\"缓存\",\"缓存一词搞技术的都接触过，很多地方用到缓存。网站架构和网站开发中的缓存也是非常重要。架构方面的缓存，对Apache比较熟悉的人都能知道Apache提供了自己的缓存模块，也可以使用外加的Squid模块进行缓存，这两种方式均可以有效的提高Apache的访问响应能力。\",\"网站程序开发方面的缓存，Linux上提供的Memory Cache是常用的缓存接口，可以在web开发中使用，比如用Java开发的时候就可以调用MemoryCache对一些数据进行缓存和通讯共享，一些大型社区使用了这样的架构。另外，在使用web语言开发的时候，各种语言基本都有自己的缓存模块和方法，PHP有Pear的Cache模块，Java就更多了，.net不是很熟悉，相信也肯定有。\",\"镜像\",\"镜像是大型网站常采用的提高性能和数据安全性的方式，镜像的技术可以解决不同网络接入商和地域带来的用户访问速度差异，比如ChinaNet和EduNet之间的差异就促使了很多网站在教育网内搭建镜像站点，数据进行定时更新或者实时更新。在镜像的细节技术方面，这里不阐述太深，有很多专业的现成的解决架构和产品可选。也有廉价的通过软件实现的思路，比如Linux上的rsync等工具。\",\"负载均衡\",\"负载均衡将是大型网站解决高负荷访问和大量并发请求采用的终极解决办法。 负载均衡技术发展了多年，有很多专业的服务提供商和产品可以选择。\",\"硬件四层交换\",\"第四层交换使用第三层和第四层信息包的报头信息，根据应用区间识别业务流，将整个区间段的业务流分配到合适的应用服务器进行处理。 第四层交换功能就象是虚IP，指向物理服务器。它传输的业务服从的协议多种多样，有HTTP、FTP、NFS、Telnet或其他协议。这些业务在物理服务器基础上，需要复杂的载量平衡算法。在IP世界，业务类型由终端TCP或UDP端口地址来决定，在第四层交换中的应用区间则由源端和终端IP地址、TCP和UDP端口共同决定。\",\"在硬件四层交换产品领域，有一些知名的产品可以选择，比如Alteon、F5等，这些产品很昂贵，但是物有所值，能够提供非常优秀的性能和很灵活的管理能力。Yahoo中国当初接近2000台服务器使用了三四台Alteon就搞定了。\",\"集群如何同步会话状态\",\"集群session一致性和同步问题\",\"基于ZooKeeper的分布式Session实现\",\"负载均衡的原理\",\"六大Web负载均衡原理与实现\",\"如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）\",\"数据库SQL优化大总结之 百万级数据库优化方案\",\"如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题\",\"如何提高服务器并发处理能力\",\"假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。\",\"如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。\",\"你的项目中使用过缓存机制吗？有没用用户非本地缓存\",\"Semphore、CountDownLatch、CyclicBarrier、Phaser\",\"并发工具类（二）同步屏障CyclicBarrier\",\"并发工具类（三）控制并发线程数的Semaphore\",\"CLH队列\",\"【Java并发编程实战】—– AQS(四)：CLH同步队列\",\"JAVA并发编程学习笔记之CLH队列锁\",\"产生死锁的必要条件\",\"操作系统：死锁的产生、条件、和解锁\",\"Java内存模型\",\"设计模式\",\"单例模式：饱汉、饿汉。以及饿汉中的延迟加载,双重检查\",\"工厂模式、装饰者模式、观察者模式。\",\"工厂方法模式的优点（低耦合、高内聚，开放封闭原则）\",\"如何理解观察者模式？\",\"列举出你说熟悉的设计模式，并对其中的一种的使用举一个例子。\",\"JVM\",\"User user = new User() 做了什么操作，申请了哪些内存？\",\"new User(); 创建一个User对象，内存分配在堆上\",\"User user; 创建一个引用，内存分配在栈上\",\"= 将User对象地址赋值给引用\",\"Java的内存模型以及GC算法\",\"JVM内存模型与GC算法\",\"jvm性能调优都做了什么\",\"JVM性能调优\",\"介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明\",\"介绍GC 和GC Root不正常引用\",\"自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展\",\"java classload 机制 详解\",\"jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析\",\"JVM直接内存\",\"浅谈HotSpot逃逸分析\",\"触摸java常量池\",\"数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）\",\"深入理解JVM（6） : Java对象内存分配策略\",\"注意:PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。\",\"如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。\",\"老年代中数组的访问方式\",\"GC算法，永久代对象如何GC，GC有环怎么处理\",\"永久代GC的原因：\",\"永久代空间已经满了\",\"调用了System.gc()\",\"注意： 这种GC是full GC 堆空间也会一并被GC一次\",\"GC有环怎么处理\",\"根搜索算法\",\"什么是根搜索算法\",\"垃圾回收器从被称为GC Roots的点开始遍历遍历对象，凡是可以达到的点都会标记为存活，堆中不可到达的对象都会标记成垃圾，然后被清理掉。\",\"GC Roots有哪些\",\"类，由系统类加载器加载的类。这些类从不会被卸载，它们可以通过静态属性的方式持有对象的引用。\",\"注意，一般情况下由自定义的类加载器加载的类不能成为GC Roots\",\"线程，存活的线程\",\"Java方法栈中的局部变量或者参数\",\"JNI方法栈中的局部变量或者参数\",\"JNI全局引用\",\"用做同步监控的对象\",\"被JVM持有的对象，这些对象由于特殊的目的不被GC回收。这些对象可能是系统的类加载器，一些重要的异常处理类，一些为处理异常预留的对象，以及一些正在执行类加载的自定义的类加载器。但是具体有哪些前面提到的对象依赖于具体的JVM实现。\",\"如何处理\",\"基于引用对象遍历的垃圾回收器可以处理循环引用，只要是涉及到的对象不能从GC Roots强引用可到达，垃圾回收器都会进行清理来释放内存。\",\"谁会被GC，什么时候GC\",\"Java JVM：垃圾回收（GC 在什么时候，对什么东西，做了什么事情）\",\"如果想不被GC怎么办\",\"如果想在 GC 中生存 1 次怎么办\",\"生存一次，释放掉对象的引用，但是在对象的finalize方法中重新建立引用，但是此方法只会被调用一次，所以能在GC中生存一次。\",\"分析System.gc()方法\",\"JVM源码分析之SystemGC完全解读\",\"JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？\",\"当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。\",\"写代码分别使得JVM的堆、栈和持久代发生内存溢出(栈溢出)\",\"JVM内存溢出详解（栈溢出，堆溢出，持久代溢出以及无法创建本地线程）\",\"为什么jdk8用metaspace数据结构用来替代perm？\",\"JDK8：PermGen变更为MetaSpace详解\",\"简单谈谈堆外内存以及你的理解和认识\",\"JVM源码分析之堆外内存完全解读\",\"threadlocal使用场景及注意事项\",\"threadlocal原理及常用应用场景\",\"JVM老年代和新生代的比例？\",\"JVM-堆学习之新生代老年代持久带的使用关系\",\"栈是运行时的单位，而堆是存储的单位。\",\"栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。\",\"在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。\",\"为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？\",\"从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。\",\"堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。\",\"栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。\",\"面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。\",\"为什么不把基本类型放堆中呢？\",\"因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。\",\"堆中存什么？栈中存什么？\",\"堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个4btye的引用（堆栈分离的好处：））。\",\"为什么不把基本类型放堆中呢？因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。\",\"Java中的参数传递时传值呢？还是传引用？\",\"要说明这个问题，先要明确两点：\",\"不要试图与C进行类比，Java中没有指针的概念\",\"程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。\",\"明确以上两点后。Java在方法调用传递参数时，因为没有指针，所以它都是进行传值调用（这点可以参考C的传值调用）。因此，很多书里面都说Java是进行传值调用，这点没有问题，而且也简化的C中复杂性。\",\"但是传引用的错觉是如何造成的呢？在运行栈中，基本类型和引用的处理是一样的，都是传值，所以，如果是传引用的方法调用，也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。但是当进入被调用方法时，被传递的这个引用的值，被程序解释（或者查找）到堆中的对象，这个时候才对应到真正的对象。如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是堆中的数据。所以这个修改是可以保持的了。\",\"对象，从某种意义上说，是由基本类型组成的。可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树（即非叶子节点），基本类型则为树的叶子节点。程序参数传递时，被传递的值本身都是不能进行修改的，但是，如果这个值是一个非叶子节点（即一个对象引用），则可以修改这个节点下面的所有内容。\",\"堆和栈中，栈是程序运行最根本的东西。程序运行可以没有堆，但是不能没有栈。而堆是为栈进行数据存储服务，说白了堆就是一块共享的内存。不过，正是因为堆和栈的分离的思想，才使得Java的垃圾回收成为可能。\",\"Java中，栈的大小通过-Xss来设置，当栈中存储数据比较多时，需要适当调大这个值，否则会出现java.lang.StackOverflowError异常。常见的出现这个异常的是无法返回的递归，因为此时栈中保存的信息都是方法返回的记录点\",\"对象引用类型分为哪几类？\",\"java中四种引用类型（对象的强、软、弱和虚引用）\",\"讲一讲内存分代及生命周期。\",\"管中窥豹——从对象的生命周期梳理JVM内存结构、GC、类加载、AOP编程及性能监控\",\"什么情况下触发垃圾回收？\",\"Java JVM 8：垃圾回收（GC 在什么时候，对什么东西，做了什么事情）\",\"如何选择合适的垃圾收集算法？\",\"深入理解垃圾收集器和收集器的选择策略\",\"JVM给了三种选择：串行收集器、并行收集器、并发收集器 ，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置 进行判断。\",\"吞吐量优先的并行收集器\",\"如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。\",\"典型配置 ：\",\"java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelGC ：选择垃圾收集器为并行收集器。 此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。 -XX:ParallelGCThreads=20 ：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。 java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC -XX:+UseParallelOldGC ：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。 java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:MaxGCPauseMillis=100 : 设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy -XX:+UseAdaptiveSizePolicy ：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。\",\"响应时间优先的并发收集器\",\"如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。\",\"典型配置 ：\",\"java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC ：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。 -XX:+UseParNewGC :设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。 java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction ：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。 -XX:+UseCMSCompactAtFullCollection ：打开对年老代的压缩。可能会影响性能，但是可以消除碎片\",\"StringTable\",\"探索StringTable提升YGC性能\",\"JVM源码分析之String.intern()导致的YGC不断变长\",\"JVM中最大堆大小有没有限制？\",\"JVM调优常用参数配置\",\"如何进行JVM调优？有哪些方法？\",\"如何合理的规划一次jvm性能调优\",\"如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？\",\"详解java内存泄露和如何避免内存泄漏\",\"开源框架\",\"hibernate和ibatis的区别\",\"Ibatis与Hibernate的区别\",\"讲讲mybatis的连接池。\",\"《深入理解mybatis原理》 Mybatis数据源与连接池\",\"spring框架中需要引用哪些jar包，以及这些jar包的用途\",\"springMVC的原理\",\"Spring MVC工作原理 及注解说明\",\"spring中beanFactory和ApplicationContext的联系和区别\",\"Spring系列之beanFactory与ApplicationContext\",\"spring注入的几种方式（循环注入）\",\"Spring循环依赖的三种方式\",\"spring如何实现事务管理的\",\"springIOC\",\"Spring IOC原理解读 面试必读\",\"spring AOP的原理\",\"Spring AOP 实现原理与 CGLIB 应用\",\"spring AOP 两种代理方式\",\"回答为什么要用什么方法这种问题的时候，通常首先要回答两个问题，第一个就是，我要做什么事情，第二个就是，不同方法的优劣是什么。\",\"首先，我要做什么事情。\",\"这里的回答比较简单，就是代理Java类/接口。那么，两者在完成这件事情上，有什么差别呢\",\"JDK Proxy\",\"Cglib Proxy\",\"只能代理接口\",\"以继承的方式完成代理，不能代理被final修饰的类\",\"实际上，大部分的Java类都会以接口-实现的方式来完成，因此，在这个方面上，JDK Proxy实际上是比Cglib Proxy要更胜一筹的。因为如果一个类被final修饰，则Cglib Proxy无法进行代理。\",\"其次，两种方法的优劣又在什么地方呢？\",\"我们可以参考一下来自bytebuddy的数据，这个是在代理一个实现了具有18个方法的接口的类，时间单位为ns。\",\"| JDK Proxy | Cglib Proxy\",\"---|---|---\",\"生成代理类时间 | 1'060.766 | 960.527\",\"方法调用时间 | 0.008 | 0.003\",\"来源 | JDK原生代码 | 第三方库，更新频率较低\",\"不难看出，其实Cglib代理的性能是要远远好于JDK代理的。\",\"其实从原理也能理解，直接通过类的方法调用，肯定要比通过反射调用的时间更短。但是从来源来看的话，一个是JDK原生代码，而另一个则是第三方的开源库。JDK原生代码无疑使用的人会更多范围也更广，会更佳稳定，而且还有可能在未来的JDK版本中不断优化性能。\",\"而Cglib更新频率相对来说比较低了，一方面是因为这个代码库已经渐趋稳定，另一方面也表明后续这个库可能相对来说不会有大动作的优化维护。\",\"对比完之后，再来回看这个问题，为什么要使用两种方式呢？\",\"在功能上讲，实际上Cglib代理并不如JDK代理（如果大家都按接口-实现的方式来设计类）。但是从效率上将，Cglib远胜JDK代理啊！所以，为了提高效率，同时又保有在未来，当JDK代理的性能也能够同样好的时候，使用更佳稳定靠谱的JDK代码，这种可能，于是采取了这种设计。\",\"hibernate中的1级和2级缓存的使用方式以及区别原理（Lazy-Load的理解）\",\"Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。\",\"Spring boot 热加载\",\"Spring boot 热加载\",\"Spring Boot设置有效时间和自动刷新缓存，时间支持在配置文件中配置\",\"Spring Boot缓存实战 Redis 设置有效时间和自动刷新缓存，时间支持在配置文件中配置\",\"Spring 如何保证 Controller 并发的安全？\",\"springMVC一个Controller处理所有用户请求的并发问题\",\"spring中用到哪些设计模式？\",\"spring中用到哪些设计模式\",\"Spring IOC 的理解，其初始化过程？\",\"Spring IoC容器初始化过程学习\",\"Spring的事务管理\",\"Spring事务管理（详解+实例）\",\"MyBatis缓存\",\"《深入理解mybatis原理》 MyBatis缓存机制的设计与实现\",\"MyBatis数据源与连接池\",\"《深入理解mybatis原理》 Mybatis数据源与连接池\",\"分布式\",\"CAP原理和BASE理论\",\"CAP原则(CAP定理)、BASE理论\",\"分布式事务、分布式锁\",\"常用的分布式事务解决方案介绍有多少种？\",\"分布式锁的几种实现方式\",\"分布式存储系统\",\"redis\",\"redis和memcache的区别；\",\"用redis做过什么；\",\"redis是如何持久化的：rdb和aof；\",\"Redis数据类型\",\"Redis五种数据类型介绍\",\"redis集群如何同步；\",\"Redis 复制与集群\",\"redis的数据添加过程是怎样的：哈希槽；\",\"redis集群实现（四） 数据的和槽位的分配\",\"redis的淘汰策略有哪些；\",\"Redis 内存淘汰机制\",\"volatile-lru -> 根据LRU算法删除带有过期时间的key。\",\"allkeys-lru -> 根据LRU算法删除任何key。\",\"volatile-random -> 根据过期设置来随机删除key, 具备过期时间的key。\",\"allkeys->random -> 无差别随机删, 任何一个key。\",\"volatile-ttl -> 根据最近过期时间来删除（辅以TTL）, 这是对于有过期时间的key\",\"noeviction -> 谁也不删，直接在写操作时返回错误。\",\"redis有哪些数据结构；\",\"redis的单线程模型\",\"Redis 网络架构及单线程模型\",\"redis 集群基础\",\"所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.\",\"节点的fail是通过集群中超过半数的master节点检测失效时才生效.\",\"客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可\",\"redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node<->slot<->key.\",\"如果存入一个值，按照redis cluster哈希槽的算法： CRC16('key')384 = 6782。 那么就会把这个key 的存储分配到对应的master上\",\"redis Cluster主从模式\",\"如果进群超过半数以上master挂掉，无论是否有slave集群进入fail状态,所以集群中至少应该有奇数个节点，所以至少有三个节点，每个节点至少有一个备份节点,\",\"redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。\",\"zookeeper\",\"zookeeper是什么；\",\"zookeeper哪里用到；\",\"zookeeper的选主过程；\",\"zookeeper集群之间如何通讯\",\"zookeeper系列之通信模型\",\"你们的zookeeper的节点加密是用的什么方式\",\"分布式锁的实现过程；\",\"kafka\",\"传递保证语义：\",\"At most once：消息可能会丢，但绝不会重复传递。\",\"At least once：消息绝不会丢，但可能会重复传递。\",\"Exactly once： 每条消息只会被传递一次。\",\"生产者的“Exactly once”语义方案\",\"当生产者向Kafka发送消息，且正常得到响应的时候，可以确保生产者不会产生重复的消息。但是，如果生产者发送消息后，遇到网络问题，无法获取响应，生产者就无法判断该消息是否成功提交给了Kafka。根据生产者的机制，我们知道，当出现异常时，会进行消息重传，这就可能出现“At least one”语义。为了实现“Exactly once”语义，这里提供两个可选方案：\",\"每个分区只有一个生产者写入消息，当出现异常或超时的情况时，生产者就要查询此分区的最后一个消息，用来决定后续操作是消息重传还是继续发送。\",\"为每个消息添加一个全局唯一主键，生产者不做其他特殊处理，按照之前分析方式进行重传，由消费者对消息进行去重，实现“Exactly once”语义。\",\"如果业务数据产生消息可以找到合适的字段作为主键，或是有一个全局ID生成器，可以优先考虑选用第二种方案。\",\"消费者的“Exactly once”语义方案\",\"为了实现消费者的“Exactly once”语义，在这里提供一种方案，供读者参考：消费者将关闭自动提交offset的功能且不再手动提交offset，这样就不使用Offsets Topic这个内部Topic记录其offset，而是由消费者自己保存offset。这里利用事务的原子性来实现“Exactly once”语义，我们将offset和消息处理结果放在一个事务中，事务执行成功则认为此消息被消费，否则事务回滚需要重新消费。当出现消费者宕机重启或Rebalance操作时，消费者可以从关系型数据库中找到对应的offset，然后调用KafkaConsumer.seek()方法手动设置消费位置，从此offset处开始继续消费。\",\"ISR集合\",\"ISR（In-SyncReplica）集合表示的是目前“可用”（alive）且消息量与Leader相差不多的副本集合，这是整个副本集合的一个子集。“可用”和“相差不多”都是很模糊的描述，其实际含义是ISR集合中的副本必须满足下面两个条件：\",\"副本所在节点必须维持着与ZooKeeper的连接。\",\"副本最后一条消息的offset与Leader副本的最后一条消息的offset之间的差值不能超出指定的阈值。\",\"每个分区中的Leader副本都会维护此分区的ISR集合。写请求首先由Leader副本处理，之后Follower副本会从Leader上拉取写入的消息，这个过程会有一定的延迟，导致Follower副本中保存的消息略少于Leader副本，只要未超出阈值都是可以容忍的。如果一个Follower副本出现异常，比如：宕机，发生长时间GC而导致Kafka僵死或是网络断开连接导致长时间没有拉取消息进行同步，就会违反上面的两个条件，从而被Leader副本踢出ISR集合。当Follower副本从异常中恢复之后，会继续与Leader副本进行同步，当Follower副本“追上”（即最后一条消息的offset的差值小于指定阈值）Leader副本的时候，此Follower副本会被Leader副本重新加入到ISR中。\",\"请说明什么是Apache Kafka?\",\"Apache Kafka是由Apache开发的一种发布订阅消息系统，它是一个分布式的、分区的和重复的日志服务。\",\"请说明什么是传统的消息传递方法?\",\"传统的消息传递方法包括两种：\",\"排队：在队列中，一组用户可以从服务器中读取消息，每条消息都发送给其中一个人。\",\"发布-订阅：在这个模型中，消息被广播给所有的用户。\",\"请说明Kafka相对传统技术有什么优势?\",\"Apache Kafka与传统的消息传递技术相比优势之处在于：\",\"快速:单一的Kafka代理可以处理成千上万的客户端，每秒处理数兆字节的读写操作。\",\"可伸缩:在一组机器上对数据进行分区和简化，以支持更大的数据\",\"持久:消息是持久性的，并在集群中进行复制，以防止数据丢失\",\"设计:它提供了容错保证和持久性\",\"在Kafka中broker的意义是什么?\",\"在Kafka集群中，broker术语用于引用服务器。\",\"Kafka服务器能接收到的最大信息是多少?\",\"Kafka服务器可以接收到的消息的最大大小是1000000字节。\",\"解释Kafka的Zookeeper是什么?我们可以在没有Zookeeper的情况下使用Kafka吗?\",\"Zookeeper是一个开放源码的、高性能的协调服务，它用于Kafka的分布式应用。\",\"不，不可能越过Zookeeper，直接联系Kafka broker。一旦Zookeeper停止工作，它就不能服务客户端请求。\",\"Zookeeper主要用于在集群中不同节点之间进行通信\",\"在Kafka中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都可以从之前提交的偏移量中获取\",\"除此之外，它还执行其他活动，如: leader检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等等。\",\"解释Kafka的用户如何消费信息?\",\"在Kafka中传递消息是通过使用sendfile API完成的。它支持将字节从套接口转移到磁盘，通过内核空间保存副本，并在内核用户之间调用内核。\",\"解释如何提高远程用户的吞吐量?\",\"如果用户位于与broker不同的数据中心，则可能需要调优套接口缓冲区大小，以对长网络延迟进行摊销。\",\"解释一下，在数据制作过程中，你如何能从Kafka得到准确的信息?\",\"在数据中，为了精确地获得Kafka的消息，你必须遵循两件事: 在数据消耗期间避免重复，在数据生产过程中避免重复。\",\"这里有两种方法，可以在数据生成时准确地获得一个语义:\",\"每个分区使用一个单独的写入器，每当你发现一个网络错误，检查该分区中的最后一条消息，以查看您的最后一次写入是否成功\",\"在消息中包含一个主键(UUID或其他)，并在用户中进行反复制\",\"解释如何减少ISR中的扰动?broker什么时候离开ISR?\",\"ISR是一组与leaders完全同步的消息副本，也就是说ISR中包含了所有提交的消息。ISR应该总是包含所有的副本，直到出现真正的故障。如果一个副本从leader中脱离出来，将会从ISR中删除。\",\"Kafka为什么需要复制?\",\"Kafka的信息复制确保了任何已发布的消息不会丢失，并且可以在机器错误、程序错误或更常见些的软件升级中使用。\",\"如果副本在ISR中停留了很长时间表明什么?\",\"如果一个副本在ISR中保留了很长一段时间，那么它就表明，跟踪器无法像在leader收集数据那样快速地获取数据。\",\"请说明如果首选的副本不在ISR中会发生什么?\",\"如果首选的副本不在ISR中，控制器将无法将leadership转移到首选的副本。\",\"有可能在生产后发生消息偏移吗?\",\"在大多数队列系统中，作为生产者的类无法做到这一点，它的作用是触发并忘记消息。broker将完成剩下的工作，比如使用id进行适当的元数据处理、偏移量等。\",\"作为消息的用户，你可以从Kafka broker中获得补偿。如果你注视SimpleConsumer类，你会注意到它会获取包括偏移量作为列表的MultiFetchResponse对象。此外，当你对Kafka消息进行迭代时，你会拥有包括偏移量和消息发送的MessageAndOffset对象。\",\"kafka与传统的消息中间件对比\",\"kafka与传统的消息中间件对比\",\"KAFKA：如何做到1秒发布百万级条消息\",\"KAFKA：如何做到1秒发布百万级条消息\",\"kafka文件存储\",\"Kafka文件存储机制那些事\",\"据kafka官网吹，如果随机写入磁盘，速度就只有100KB每秒。顺序写入的话，7200转/s的磁盘就能达到惊人的600MB每秒！\",\"操作系统对文件访问做了优化，文件会在内核空间分页做缓存（pageCache）。写入时先写入pageCache。由操作系统来决定何时统一写入磁盘。操作系统会使用顺序写入。\",\"Kafka深入理解-1：Kafka高效的文件存储设计\",\"kafka的log存储解析——topic的分区partition分段segment以及索引等\",\"dubbo\",\"默认使用的是什么通信框架，还有别的选择吗?\",\"默认也推荐使用netty框架，还有mina。\",\"服务调用是阻塞的吗？\",\"默认是阻塞的，可以异步调用，没有返回值的可以这么做。\",\"一般使用什么注册中心？还有别的选择吗？\",\"推荐使用zookeeper注册中心，还有redis等不推荐。\",\"默认使用什么序列化框架，你知道的还有哪些？\",\"默认使用Hessian序列化，还有Duddo、FastJson、Java自带序列化。\",\"服务提供者能实现失效踢出是什么原理？\",\"服务失效踢出基于zookeeper的临时节点原理。\",\"服务上线怎么不影响旧版本？\",\"采用多版本开发，不影响旧版本。\",\"如何解决服务调用链过长的问题？\",\"可以结合zipkin实现分布式服务追踪。\",\"说说核心的配置有哪些？\",\"核心配置有 dubbo:service/ dubbo:reference/ dubbo:protocol/ dubbo:registry/ dubbo:application/ dubbo:provider/ dubbo:consumer/ dubbo:method/\",\"dubbo推荐用什么协议？\",\"默认使用dubbo协议。\",\"同一个服务多个注册的情况下可以直连某一个服务吗？\",\"可以直连，修改配置即可，也可以通过telnet直接某个服务。\",\"画一画服务注册与发现的流程图\",\"流程图见dubbo.io。\",\"Dubbo集群容错怎么做？\",\"读操作建议使用Failover失败自动切换，默认重试两次其他服务器。写操作建议使用Failfast快速失败，发一次调用失败就立即报错。\",\"在使用过程中都遇到了些什么问题？\",\"使用过程中的问题可以百度\",\"dubbo和dubbox之间的区别？\",\"dubbox是当当网基于dubbo上做了一些扩展，如加了服务可restful调用，更新了开源组件等。\",\"你还了解别的分布式框架吗？\",\"别的还有spring的spring cloud，facebook的thrift，twitter的finagle等。\",\"dubbo重试雪崩\",\"Dubbo超时机制导致的雪崩连接\",\"TCP/IP\",\"算法\",\"使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）\",\"两个有序数组的合并排序\",\"一个数组的倒序\",\"计算一个正整数的正平方根\",\"说白了就是常见的那些查找、排序算法以及各自的时间复杂度\",\"二叉树的遍历算法\",\"DFS,BFS算法\",\"比较重要的数据结构，如链表，队列，栈的基本理解及大致实现。\",\"排序算法与时空复杂度（快排为什么不稳定，为什么你的项目还在用）\",\"逆波兰计算器\",\"Hoffman 编码\",\"查找树与红黑树\",\"如何给100亿个数字排序?\",\"如何给100亿个数字排序?\",\"统计海量数据中出现次数最多的前10个IP\",\"哈希分治法 - 统计海量数据中出现次数最多的前10个IP\",\"排序算法时间复杂度\",\"排序方法\",\"时间复杂度（平均）\",\"时间复杂度（最坏)\",\"时间复杂度（最好)\",\"空间复杂度\",\"稳定性\",\"复杂性\",\"直接插入排序\",\"O(n2)\",\"O(n2)\",\"O(n)\",\"O(1)\",\"稳定\",\"简单\",\"希尔排序\",\"O(nlog2n)\",\"O(n2)\",\"O(n)\",\"O(1)\",\"不稳定\",\"较复杂\",\"直接选择排序\",\"O(n2)\",\"O(n2)\",\"O(n2)\",\"O(1)\",\"不稳定\",\"简单\",\"堆排序\",\"O(nlog2n)\",\"O(nlog2n)\",\"O(nlog2n)\",\"O(1)\",\"不稳定\",\"较复杂\",\"冒泡排序\",\"O(n2)\",\"O(n2)\",\"O(n)\",\"O(1)\",\"稳定\",\"简单\",\"快速排序\",\"O(nlog2n)\",\"O(n2)\",\"O(nlog2n)\",\"O(nlog2n)\",\"不稳定\",\"较复杂\",\"归并排序\",\"O(nlog2n)\",\"O(nlog2n)\",\"O(nlog2n)\",\"O(n)\",\"稳定\",\"较复杂\",\"基数排序\",\"O(d(n+r))\",\"O(d(n+r))\",\"O(d(n+r))\",\"O(n+r)\",\"稳定\",\"较复杂\",\"判断链表中是否有环\",\"判断链表中是否有环 ----- 有关单链表中环的问题\",\"hash算法及常用的hash算法\",\"常见hash算法的原理\",\"查找算法\",\"七大查找算法\",\"设计与思想\",\"重构过代码没有？说说经验；\",\"一千万的用户实时排名如何实现；\",\"海量积分数据实时排名处理\",\"如何高效地获得玩家排名？\",\"基于redis的zset实现排行榜功能\",\"五万人并发抢票怎么实现；\",\"Web大规模高并发请求和抢购的解决方案\",\"有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?\",\"高并发情况下，我们系统是如何支撑大量的请求的\",\"集群如何同步会话状态\",\"集群服务器Session同步\",\"负载均衡的原理\",\"如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）\",\"大数据量高并发的数据库优化\",\"如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。\",\"如何提高服务器并发处理能力\",\"假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。\",\"三个方面解决性能问题的基本思路和方法\",\"一个Web应用的性能瓶颈一般有哪些呢？通常采取什么手段解决呢？\",\"如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。\",\"五步定位性能瓶颈\",\"性能测试如何定位瓶颈\",\"你的项目中使用过缓存机制吗？有没用用户非本地缓存\",\"使用缓存的9大误区（上）\",\"使用缓存的9大误区（下）\",\"网站缓存技术\",\"Tomcat优化\",\"Tomcat 调优及 JVM 参数优化\",\"网络通信\",\"http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。\",\"socket通信，以及长连接，分包，连接异常断开的处理。\",\"Socket TCP/IP协议数据传输过程中的粘包和分包问题\",\"深入理解socket网络异常\",\"socket通信模型的使用，AIO和NIO。\",\"socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。\",\"同步和异步，阻塞和非阻塞。\",\"OSI七层模型，包括TCP,IP的一些基本知识\",\"OSI七层协议模型和TCP/IP四层模型比较\",\"http中，get post的区别\",\"get： 从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。\",\"post: 向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。\",\"请求方式的区别: get 请求的数据会附加在URL之后,特定的浏览器和服务器对URL的长度有限制. post 更加安全数据不会暴漏在url上,而且长度没有限制.\",\"HTTP报文内容\",\"HTTP请求报文和HTTP响应报文\",\"说说http,tcp,udp之间关系和区别。\",\"说说浏览器访问http://www.taobao.com，经历了怎样的过程。\",\"访问 www.taobao.com过程\",\"HTTP协议、 HTTPS协议，SSL协议及完整交互过程；\",\"HTTPS协议，SSL协议及完整交互过程\",\"tcp的拥塞，快回传，ip的报文丢弃\",\"https处理的一个过程，对称加密和非对称加密\",\"head各个特点和区别\",\"ping的原理\",\"Ping过程 原理 详解(图)\",\"ARP/RARP\",\"TCP/IP协议详解笔记——ARP协议和RARP协议\",\"DNS解析过程\",\"DNS域名解析的过程\",\"Http会话的四个过程\",\"建立连接，发送请求，返回响应，关闭连接。\",\"数据库MySql\",\"MySql的存储引擎的不同\",\"MySQL存储引擎之Myisam和Innodb总结性梳理\",\"MySql参数\",\"Mysql优化系列（1）--Innodb引擎下mysql自身配置优化\",\"单个索引、联合索引、主键索引\",\"Mysql主键索引、唯一索引、普通索引、全文索引、组合索引的区别\",\"Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)\",\"如果按时间排序查询，使用limit n （不要使用limit m, n 页数多了之后效率低）然后记录最后一条的时间，下次从最后一条的时间开始查询\",\"mysql 数据库 分表后 怎么进行分页查询？Mysql分库分表方案?\",\"mysql大数据量使用limit分页，随着页码的增大，查询效率越低下。\",\"分表之后想让一个id多个表是自增的，效率实现\",\"MySQL分表自增ID解决方案\",\"分布式id生成算法\",\"理解分布式id生成算法SnowFlake\",\"MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离\",\"Mysql主从同步的实现原理\",\"MySQL索引\",\"浅谈算法和数据结构: 十 平衡查找树之B树\",\"MySQL索引背后的数据结构及算法原理\",\"MySQL索引失效的几种情况\",\"事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题\",\"数据库的锁：行锁，表锁；乐观锁，悲观锁\",\"mysql的锁--行锁，表锁，乐观锁，悲观锁\",\"mysql for update语法实现行锁\",\"MySQL 加锁处理分析\",\"数据库事务的几种粒度；\",\"理解事务 - MySQL 事务处理机制\",\"MVCC\",\"Mysql中的MVCC\",\"聚簇索引\",\"mysql索引原理之聚簇索引\",\"关系型和非关系型数据库区别\",\"关系型数据库：是指采用了关系模型(二维表格模型)来组织数据的数据库。\",\"非关系型数据库：以键值对存储，且结构不固定.\",\"MySql死锁排查\",\"我的Mysql死锁排查过程（案例分析）\",\"MySql优化\",\"MySQL 对于千万级的大表要怎么优化？\",\"Linux\",\"介绍一下epoll\",\"kill的用法，某个进程杀不掉的原因（进入内核态，忽略kill信号）\",\"硬链接和软链接的区别\",\"grep的使用\",\"进程间的通信，共享内存方式的优缺点\",\"swap分区\",\"Swap交换分区概念\",\"Linux系统swappiness参数在内存与交换分区之间优化作用\",\"overcommit_memory\",\"取值为0，系统在为应用进程分配虚拟地址空间时，会判断当前申请的虚拟地址空间大小是否超过剩余内存大小，如果超过，则虚拟地址空间分配失败。因此，也就是如果进程本身占用的虚拟地址空间比较大或者剩余内存比较小时，fork、malloc等调用可能会失败。\",\"取值为1，系统在为应用进程分配虚拟地址空间时，完全不进行限制，这种情况下，避免了fork可能产生的失败，但由于malloc是先分配虚拟地址空间，而后通过异常陷入内核分配真正的物理内存，在内存不足的情况下，这相当于完全屏蔽了应用进程对系统内存状态的感知，即malloc总是能成功，一旦内存不足，会引起系统OOM杀进程，应用程序对于这种后果是无法预测的\",\"取值为2，则是根据系统内存状态确定了虚拟地址空间的上限，由于很多情况下，进程的虚拟地址空间占用远大小其实际占用的物理内存，这样一旦内存使用量上去以后，对于一些动态产生的进程(需要复制父进程地址空间)则很容易创建失败，如果业务过程没有过多的这种动态申请内存或者创建子进程，则影响不大，否则会产生比较大的影响\",\"又一次内存分配失败(关于overcommit_memory)\",\"linux系统下查看CPU、内存负载情况\",\"linux系统下查看CPU、内存负载情况\"]},\"65\":{\"h\":\"集合框架\"},\"66\":{\"h\":\"2.2 Java集合\",\"t\":[\"作者：Guide哥。\",\"介绍: Github 70k Star 项目 JavaGuide（公众号同名） 作者。每周都会在公众号更新一些自己原创干货。公众号后台回复“1”领取Java工程师必备学习资料+面试突击pdf。\"]},\"67\":{\"h\":\"2.2.1 说说List,Set,Map三者的区别？\",\"t\":[\"List(对付顺序的好帮手)： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象\",\"Set(注重独一无二的性质): 不允许重复的集合。不会有多个元素引用相同的对象。\",\"Map(用Key来搜索的专家): 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。\"]},\"68\":{\"h\":\"2.2.2 Arraylist 与 LinkedList 区别?\",\"t\":[\"1. 是否保证线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；\",\"2. 底层数据结构：Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）\",\"3. 插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以对于add(\\bE e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为o(n))因为需要先移动到指定位置再插入。\",\"4. 是否支持快速随机访问：LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index) 方法)。\",\"5. 内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。\"]},\"69\":{\"h\":\"\",\"t\":[\"public interface RandomAccess { } \",\"查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。\",\"在 binarySearch（）方法中，它要判断传入的list 是否 RamdomAccess 的实例，如果是，调用indexedBinarySearch（）方法，如果不是，那么调用iteratorBinarySearch（）方法\",\" public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key) { if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key); } \",\"ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！\",\"下面再总结一下 list 的遍历方式选择：\",\"实现了 RandomAccess 接口的list，优先选择普通 for 循环 ，其次 foreach,\",\"未实现 RandomAccess接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环\"]},\"70\":{\"h\":\"补充内容:双向链表和双向循环链表\",\"t\":[\"双向链表： 包含两个指针，一个prev指向前一个节点，一个next指向后一个节点。\",\"另外推荐一篇把双向链表讲清楚的文章：https://juejin.im/post/5b5d1a9af265da0f47352f14\",\"双向循环链表： 最后一个节点的 next 指向head，而 head 的prev指向最后一个节点，构成一个环。\"]},\"71\":{\"h\":\"2.2.3 ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？\",\"t\":[\"Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。\",\"Arraylist不是同步的，所以在不需要保证线程安全时建议使用Arraylist。\"]},\"72\":{\"h\":\"2.2.4 说一说 ArrayList 的扩容机制吧\",\"t\":[\"详见笔主的这篇文章:通过源码一步一步分析ArrayList 扩容机制\"]},\"73\":{\"h\":\"2.2.5 HashMap 和 Hashtable 的区别\",\"t\":[\"线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；\",\"效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；\",\"对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。\",\"初始容量大小和每次扩充容量大小的不同 ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。\",\"底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。\",\"HashMap 中带有初始容量的构造函数：\",\" public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity < 0) throw new IllegalArgumentException(\\\"Illegal initial capacity: \\\" + initialCapacity); if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor <= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\\\"Illegal load factor: \\\" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } \",\"下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小。\",\" /** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } \"]},\"74\":{\"h\":\"2.2.6 HashMap 和 HashSet区别\",\"t\":[\"如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone() 、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。\",\"HashMap\",\"HashSet\",\"实现了Map接口\",\"实现Set接口\",\"存储键值对\",\"仅存储对象\",\"调用 put（）向map中添加元素\",\"调用 add（）方法向Set中添加元素\",\"HashMap使用键（Key）计算Hashcode\",\"HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，\"]},\"75\":{\"h\":\"2.2.7 HashSet如何检查重复\",\"t\":[\"当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。（摘自我的Java启蒙书《Head fist java》第二版）\",\"hashCode（）与equals（）的相关规定：\",\"如果两个对象相等，则hashcode一定也是相同的\",\"两个对象相等,对两个equals方法返回true\",\"两个对象有相同的hashcode值，它们也不一定是相等的\",\"综上，equals方法被覆盖过，则hashCode方法也必须被覆盖\",\"hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。\",\"==与equals的区别\",\"==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同\",\"==是指对内存地址进行比较 equals()是对字符串的内容进行比较\",\"==指引用是否相同 equals()指的是值是否相同\",\"作者：Guide哥。\",\"介绍: Github 70k Star 项目 JavaGuide（公众号同名） 作者。每周都会在公众号更新一些自己原创干货。公众号后台回复“1”领取Java工程师必备学习资料+面试突击pdf。\"]},\"76\":{\"h\":\"2.2.8 HashMap的底层实现\"},\"77\":{\"h\":\"JDK1.8之前\",\"t\":[\"JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。\",\"所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。\",\"JDK 1.8 HashMap 的 hash 方法源码:\",\"JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。\",\" static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // >>>:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } \",\"对比一下 JDK1.7的 HashMap 的 hash 方法源码.\",\"static int hash(int h) { // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } \",\"相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。\",\"所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\"]},\"78\":{\"h\":\"JDK1.8之后\",\"t\":[\"相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。\",\"TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。\",\"推荐阅读：\",\"《Java 8系列之重新认识HashMap》 ：https://zhuanlan.zhihu.com/p/21673805\"]},\"79\":{\"h\":\"2.2.9 HashMap 的长度为什么是2的幂次方\",\"t\":[\"为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) & hash”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。\",\"这个算法应该如何设计呢？\",\"我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。\"]},\"80\":{\"h\":\"2.2.10 HashMap 多线程操作导致死循环问题\",\"t\":[\"主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。\",\"详情请查看：https://coolshell.cn/articles/9606.html\"]},\"81\":{\"h\":\"2.2.11 ConcurrentHashMap 和 Hashtable 的区别\",\"t\":[\"ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。\",\"底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\",\"实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\",\"两者的对比图：\",\"图片来源：http://www.cnblogs.com/chengxiao/p/6842045.html\",\"HashTable:\",\"JDK1.7的ConcurrentHashMap：\",\"JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：\"]},\"82\":{\"h\":\"2.2.12 ConcurrentHashMap线程安全的具体实现方式/底层具体实现\"},\"83\":{\"h\":\"JDK1.7（上面有示意图）\",\"t\":[\"首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。\",\"ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。\",\"Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。\",\"static class Segment<K,V> extends ReentrantLock implements Serializable { } \",\"一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。\"]},\"84\":{\"h\":\"JDK1.8 （上面有示意图）\",\"t\":[\"ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）\",\"synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。\"]},\"85\":{\"h\":\"2.2.13 comparable 和 Comparator的区别\",\"t\":[\"comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序\",\"comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序\",\"一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort().\"]},\"86\":{\"h\":\"Comparator定制排序\",\"t\":[\" ArrayList<Integer> arrayList = new ArrayList<Integer>(); arrayList.add(-1); arrayList.add(3); arrayList.add(3); arrayList.add(-5); arrayList.add(7); arrayList.add(4); arrayList.add(-9); arrayList.add(-7); System.out.println(\\\"原始数组:\\\"); System.out.println(arrayList); // void reverse(List list)：反转 Collections.reverse(arrayList); System.out.println(\\\"Collections.reverse(arrayList):\\\"); System.out.println(arrayList); // void sort(List list),按自然排序的升序排序 Collections.sort(arrayList); System.out.println(\\\"Collections.sort(arrayList):\\\"); System.out.println(arrayList); // 定制排序的用法 Collections.sort(arrayList, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); } }); System.out.println(\\\"定制排序后：\\\"); System.out.println(arrayList); \",\"Output:\",\"原始数组: [-1, 3, 3, -5, 7, 4, -9, -7] Collections.reverse(arrayList): [-7, -9, 4, 7, -5, 3, 3, -1] Collections.sort(arrayList): [-9, -7, -5, -1, 3, 3, 4, 7] 定制排序后： [7, 4, 3, 3, -1, -5, -7, -9] \"]},\"87\":{\"h\":\"重写compareTo方法实现按年龄来排序\",\"t\":[\"// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列 // 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他 // 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了 public class Person implements Comparable<Person> { private String name; private int age; public Person(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } /** * TODO重写compareTo方法实现按年龄来排序 */ @Override public int compareTo(Person o) { // TODO Auto-generated method stub if (this.age > o.getAge()) { return 1; } else if (this.age < o.getAge()) { return -1; } return age; } } \",\" public static void main(String[] args) { TreeMap<Person, String> pdata = new TreeMap<Person, String>(); pdata.put(new Person(\\\"张三\\\", 30), \\\"zhangsan\\\"); pdata.put(new Person(\\\"李四\\\", 20), \\\"lisi\\\"); pdata.put(new Person(\\\"王五\\\", 10), \\\"wangwu\\\"); pdata.put(new Person(\\\"小红\\\", 5), \\\"xiaohong\\\"); // 得到key的值的同时得到key所对应的值 Set<Person> keys = pdata.keySet(); for (Person key : keys) { System.out.println(key.getAge() + \\\"-\\\" + key.getName()); } } \",\"Output：\",\"5-小红 10-王五 20-李四 30-张三 \"]},\"88\":{\"h\":\"2.2.14 集合框架底层数据结构总结\"},\"89\":{\"h\":\"Collection\",\"t\":[\"1. List\",\"Arraylist： Object数组\",\"Vector： Object数组\",\"LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)\",\"2. Set\",\"HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素\",\"LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的\",\"TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)\"]},\"90\":{\"h\":\"Map\",\"t\":[\"HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间\",\"LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》\",\"Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的\",\"TreeMap： 红黑树（自平衡的排序二叉树）\"]},\"91\":{\"h\":\"2.2.15 如何选用集合?\",\"t\":[\"主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。\",\"如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。\",\"《JavaGuide 面试突击版》 : 由本文档衍生的专为面试而生的《JavaGuide 面试突击版》 版本公众号后台回复 \\\"Java 面试突击\\\" 即可免费领取！\",\"Java 工程师必备学习资源: 一些 Java 工程师常用学习资源公众号后台回复关键字 “1” 即可免费无套路获取。\"]},\"92\":{\"h\":\"面试\",\"t\":[\"（面试大厂的面试题）https://juejin.im/post/5ec0ff4a6fb9a043271c76e9?utm_source=gold_browser_extension\"]},\"93\":{\"h\":\"Java基础\"},\"94\":{\"h\":\"1. String和StringBuffer和StringBuilder区别\",\"t\":[\"可变性 简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以 String 对象是不可变的。\",\"补充（来自issue 675）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 private final byte[] value\",\"而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。\",\"StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。\",\"AbstractStringBuilder.java\",\"abstract class AbstractStringBuilder implements Appendable, CharSequence { /** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count; AbstractStringBuilder(int capacity) { value = new char[capacity]; } \",\"线程安全性\",\"String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\",\"性能\",\"每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\",\"对于三者使用的总结：\",\"操作少量的数据: 适用 String\",\"单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder\",\"多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer\"]},\"95\":{\"h\":\"2. String为啥默认用final\"},\"96\":{\"h\":\"3. ==和equals区别（详细比如相同对象比较、以及相同integer）\",\"t\":[\"== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。\",\"equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：\",\"情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。\",\"情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。\",\"举个例子：\",\"public class test1 { public static void main(String[] args) { String a = new String(\\\"ab\\\"); // a 为一个引用 String b = new String(\\\"ab\\\"); // b为另一个引用,对象的内容一样 String aa = \\\"ab\\\"; // 放在常量池中 String bb = \\\"ab\\\"; // 从常量池中查找 if (aa == bb) // true System.out.println(\\\"aa==bb\\\"); if (a == b) // false，非同一对象 System.out.println(\\\"a==b\\\"); if (a.equals(b)) // true System.out.println(\\\"aEQb\\\"); if (42 == 42.0) { // true System.out.println(\\\"true\\\"); } } } \",\"说明：\",\"String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。\",\"当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。\"]},\"97\":{\"h\":\"4. hashMap和hashSet\"},\"98\":{\"h\":\"5. 集合类（比如ArrayList底层有什么的）\",\"t\":[\"底层为数组\"]},\"99\":{\"h\":\"6. 多线程sleep和wait 以及 notify和notifyAll\"},\"100\":{\"h\":\"7. 如何创建线程，几种方式，再往深处扩展\"},\"101\":{\"h\":\"8. 还有就是抽象类和接口的区别\"},\"102\":{\"h\":\"9. 动态代理有哪些，有什么场景，区别\"},\"103\":{\"h\":\"10. int 和Integer的区别\"},\"104\":{\"h\":\"11. jdbc和mybatis的区别\"},\"105\":{\"h\":\"12. #{} 和 ${}区别\"},\"106\":{\"h\":\"13. 分页查询除了使用limit，还能有哪种方式实现 pagehelper插件\"},\"107\":{\"h\":\"14. jvm的模型有什么\"},\"108\":{\"h\":\"15. jvm了解吗\"},\"109\":{\"h\":\"16. 包括gc什么的，以及内部的一些东西\"},\"110\":{\"h\":\"17. http和https以及tcp/ip 以及socket\"},\"111\":{\"h\":\"18. runable和callable\"},\"112\":{\"h\":\"19. Sychornized 和lock的区别，lock底层用的ReentrantLock、ReadWriteLock\"},\"113\":{\"h\":\"20. Threadlocal 以及 volatile\"},\"114\":{\"h\":\"21. AQS 是原理\"},\"115\":{\"h\":\"22. 线程池了解吗 ，有哪几种线程池，使用场景有哪些，\"},\"116\":{\"h\":\"23. 比如有4个线程执行，合并结果集\"},\"117\":{\"h\":\"24. 锁细分，读写锁，偏向锁，自旋锁，轻量级锁，重量级锁\"},\"118\":{\"h\":\"25. 阻塞队列和非阻塞队列（包括一些常用的队列的说明，）\"},\"119\":{\"h\":\"26. 有界队列和无界队列（区别，为啥分有界和无界）\"},\"120\":{\"h\":\"27. 反射和jvm的执行引擎有什么区别\"},\"121\":{\"h\":\"28. tcp和udp的区别\"},\"122\":{\"h\":\"29. 什么是面向连接，什么是面向无连接\"},\"123\":{\"h\":\"30. tcp的为什么是可靠连接\"},\"124\":{\"h\":\"31. 拆包和装包是什么，连接这方面的\"},\"125\":{\"h\":\"32. spring和springmvc的常用注解\"},\"126\":{\"h\":\"33. spring的ioc和aop\"},\"127\":{\"h\":\"34. spring的bean是怎么管理，beanfactory以及applicationcontext\"},\"128\":{\"h\":\"35. springboot的注解，三大注解有什么作用，\"},\"129\":{\"h\":\"36. springboot的compantScan扫描范围是所有的包还是到哪一层；\"},\"130\":{\"h\":\"37. Springcloud用过什么，削峰，限流，其他一些实战（看你用没用过）\"},\"131\":{\"h\":\"38. future相关的\"},\"132\":{\"h\":\"39. servlet 的生命周期是\"},\"133\":{\"h\":\"40. session 和 application 的区别 已经cookie\"},\"134\":{\"h\":\"41. 动态代理 jdk代理和cglib代理区别啥的\"},\"135\":{\"h\":\"42. run和start区别 ，整个过程还有什么\"},\"136\":{\"h\":\"43. spring执行机制\"},\"137\":{\"h\":\"44. spring事务，以及事务会问你事务除了ACID外，还有脏读，不可重复读，幻读可详细说，事务的传播机制7种，事务的隔离级别，可能会出题，比如A方法使用事务，B方法没有使用，那么A调用B会有几种情况，你使用事务哪种级别\"},\"138\":{\"h\":\"45. mybatis的事务，\"},\"139\":{\"h\":\"46. springmvc的执行流程\"},\"140\":{\"h\":\"47. 线上的修改配置文件的环境比如数据库配置，怎么修改，是不是同一个目录下\"},\"141\":{\"h\":\"48. 过滤器和拦截器区别，实战用到没有，怎么用的\"},\"142\":{\"h\":\"49. 设计模式用过哪些，项目中用到的设计模式有哪些，说几个熟悉，可能再往深处扩展，比如你怎么实现，怎么写\"},\"143\":{\"h\":\"50. 观察者模式和redis的订阅和消费\"},\"144\":{\"h\":\"51. netty有没有用过，netty的优势是啥， 你为啥用，项目中怎么用的\"},\"145\":{\"h\":\"52. 微服务和分布式区别\"},\"146\":{\"h\":\"53. 微服务再细一点，我这边没怎么问，没用到\"},\"147\":{\"h\":\"54. dubbo和springcloud的区别\"},\"148\":{\"h\":\"55. dubbo和zk连接流程\"},\"149\":{\"h\":\"56. dubbo再往深处，比如负载均衡以及容错机制，再往深处\"},\"150\":{\"h\":\"57. zk了解吗，没怎么问我\"},\"151\":{\"h\":\"数据库\"},\"152\":{\"h\":\"1.数据库优化方式\"},\"153\":{\"h\":\"2.sql优化方式\"},\"154\":{\"h\":\"3.索引，通过执行explain,优化索引， 比如覆盖索引，最左原则，组合索引遇到的几种方式不同\"},\"155\":{\"h\":\"4.B tree和B+Tree区别\"},\"156\":{\"h\":\"5.innodb和myisam的区别\"},\"157\":{\"h\":\"6.数据库表设计\"},\"158\":{\"h\":\"7.三大范式\"},\"159\":{\"h\":\"8.数据库查询Leftjoin以及其他join 出题考你，还有就是写sql，比如俩个表，只取A表中与B表不共用的那部分，怎么实现\"},\"160\":{\"h\":\"中间件(rabbitmq、kafka、rocketMq)\"},\"161\":{\"h\":\"1.使用的队列常见问题 ( 如何保证消息一致性、保证消息不丢失、重复数据怎么处理 、生产者宕机 或者消费者宕机你怎么处理 、不消费怎么处理 )\"},\"162\":{\"h\":\"2.如果整个链路通的，但是数据不消费怎么处理\"},\"163\":{\"h\":\"3.rabbitmq的死信队列 ，原因，之后怎么处理\"},\"164\":{\"h\":\"4.会问rabbitMq和kakfa区别或者 和rockedMq区别\"},\"165\":{\"h\":\"5.如何保证消息不会被重复消费\"},\"166\":{\"h\":\"redis\"},\"167\":{\"h\":\"1.redis的5种数据类型（使用场景，你项目中用到没有）\"},\"168\":{\"h\":\"String\",\"t\":[\"常用命令: set,get,decr,incr,mget 等。\",\"String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。\"]},\"169\":{\"h\":\"Hash\",\"t\":[\"常用命令： hget,hset,hgetall 等。\",\"hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：\",\"key=JavaUser293847 value={ “id”: 1, “name”: “SnailClimb”, “age”: 22, “location”: “Wuhan, Hubei” } \"]},\"170\":{\"h\":\"List\",\"t\":[\"常用命令: lpush,rpush,lpop,rpop,lrange等\",\"list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。\",\"Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。\",\"另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。\"]},\"171\":{\"h\":\"Set\",\"t\":[\"常用命令： sadd,spop,smembers,sunion 等\",\"set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。\",\"当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。\",\"比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：\",\"sinterstore key1 key2 key3 将交集存在key1内 \"]},\"172\":{\"h\":\"Sorted Set\",\"t\":[\"常用命令： zadd,zrange,zrem,zcard等\",\"和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。\",\"举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。\"]},\"173\":{\"h\":\"2.redis的持久化，俩种方式，rdb和aof，\"},\"174\":{\"h\":\"3.redis的订阅机制\"},\"175\":{\"h\":\"JVM总结\"},\"176\":{\"h\":\"1.JVM调优实战说一下\"},\"177\":{\"h\":\"2.cms gc的流程 cms 表示基于 标记清理的垃圾回收器\"},\"178\":{\"h\":\"3.新生代和老年代标记算法优缺点\"},\"179\":{\"h\":\"4.oom的排查思路\"},\"180\":{\"h\":\"5.cms优缺点\"},\"181\":{\"h\":\"6.对象什么时候进入老年代\"},\"182\":{\"h\":\"7.什么时候触发fullgc\"},\"183\":{\"h\":\"8.模拟oom和Stack Overflow场景\"},\"184\":{\"h\":\"9.栈什么时候oom\"},\"185\":{\"h\":\"10.怎么jvm中内存的使用情况\"},\"186\":{\"h\":\"11.jmap是怎么做到的\"},\"187\":{\"h\":\"12.java代码从编译到执行有哪些步骤\"},\"188\":{\"h\":\"13.类加载过程\"},\"189\":{\"h\":\"14.jar包冲突遇到过吗？jar包冲突时在类加载过程中哪一步报的错\"},\"190\":{\"h\":\"15.让你实现一个jvm,标记垃圾的具体步骤你怎么做，怎么扫描垃圾，这些信息维护在哪\"},\"191\":{\"h\":\"实战总结\"},\"192\":{\"h\":\"1. 分库分表的场景题，淘宝场景，买家卖家数据怎么存，怎么分库分表\"},\"193\":{\"h\":\"2. 说说你在重构拆分中遇到的问题，你负责了哪些\"},\"194\":{\"h\":\"3. 拆分你是怎么保证数据完整性的\"},\"195\":{\"h\":\"4. 如果你当前系统压力*100倍你怎么设计\"},\"196\":{\"h\":\"5. 如果根据压测流量路由到影子库\"},\"197\":{\"h\":\"6. https://tech.meituan.com/2018/09/27/quake-introduction.html\"},\"198\":{\"h\":\"7. 分布式事务有没有了解过目前业内比较成熟的解决方案\"},\"199\":{\"h\":\"8. 场景题，大量请求访问一份数据怎么设计，只说应用层面的（借用读写锁的思想）\"},\"200\":{\"h\":\"9. 分布式锁你们用什么实现的\"},\"201\":{\"h\":\"10. 你怎么理解幂等？\"},\"202\":{\"h\":\"11. 你是怎么实现幂等的？\"},\"203\":{\"h\":\"12. 链路追踪你们怎么做的\"},\"204\":{\"h\":\"13. CPU负载很高一般是什么原因，排查思路是什么？\"},\"205\":{\"h\":\"linux总结\"},\"206\":{\"h\":\"1. top命令CPU利用率和Load?Average的区别\"},\"207\":{\"h\":\"2. Load?Average高但是CPU使用率不高是什么原因\"},\"208\":{\"h\":\"数据结构&算法\"},\"209\":{\"h\":\"1. 求链表长度，可能有环\"},\"210\":{\"h\":\"2. 经典的上台阶问题\"},\"211\":{\"h\":\"3. 多线程顺序打印\"},\"212\":{\"h\":\"4. 括号匹配问题\"},\"213\":{\"h\":\"5. 遍历树，写2种\"},\"214\":{\"h\":\"6. 求树最大深度，用队列求\"},\"215\":{\"h\":\"面试题\"},\"216\":{\"h\":\"什么是Mysql中的降序索引？\",\"t\":[\"大家可能对索引比较熟悉，而对降序索引比较陌生，事实上，降序索引是索引的子集。\",\"我们通常使用下面的语句来创建一个索引：\",\"create index idx_t1_bcd on t1(b,c,d); \",\"上面sql的意思是在t1表中，针对b,c,d三个字段创建一个联合索引。\",\"但是大家不知道的是，上面这个sql实际上和下面的这个sql是等价的：\",\"SQL\",\"1\",\"create index idx_t1_bcd on t1(b asc,c asc,d asc);\",\"asc表示的是升序，使用这种语法创建出来的索引叫做升序索引。也就是我们平时在创建索引的时候，创建的都是升序索引。\",\"可能你会想到，在创建的索引的时候，可以针对字段设置asc，那是不是也可以设置desc呢？\",\"当然是可以的，比如下面三个语句：\",\"SQL\",\"1\",\"2\",\"3\",\"create index idx_t1_bcd on t1(b desc,c desc,d desc);\",\"create index idx_t1_bcd on t1(b asc,c desc,d desc);\",\"create index idx_t1_bcd on t1(b asc,c asc,d desc);\",\"这种语法在mysql中也是支持的，使用这种语法创建出来的索引就叫降序索引，关键问题是：在Mysql8.0之前仅仅只是语法层面的支持，底层并没有真正支持。\",\"我们分别使用Mysql7、Mysql8两个版本来举例子说明一下：\",\"在Mysql7、Mysql8中分别创建一个表，有a,b,c,d,e五个字段：\",\"SQL\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"create table t1 (\",\"a int primary key,\",\"b int,\",\"c int,\",\"d int,\",\"e varchar(20)\",\") engine=InnoDB;\",\"然后分别创建一个降序索引：\",\"SQL\",\"1\",\"create index idx_t1_bcd on t1(b desc,c desc,d desc);\",\"创建成功后，我们使用以下sql查看一下索引信息：\",\"SQL\",\"1\",\"show index from t1;\",\"Mysql7中你将得到结果：\",\"Mysql8中你将得到结果：\",\"我们只关心Key_name为idx_t1_bcd的三行记录，细心的你应该可以发现，这两个结果中的Collation字段的结果是不一样的：\",\"●在Mysql7中，Collation字段的结果为A,A,A，表示b,c,d三个字段的排序方式是asc\",\"●在Mysql8中，Collation字段的结果为D,D,D，表示b,c,d三个字段的排序方式是desc\",\"但是我们在创建索引的时候，明明在语法层面已经指定了b,c,d三个字段的排序方式是desc，这就可以看出来在Mysql7中降序索引只是语法层面的支持，底层并没有真正支持，并且固定是升序索引。而在Mysql8中则真正从底层支持了降序索引。\",\"到此为止，大家应该对升序索引和降序索引有了一个大概的了解，但并没有真正理解，因为大家并不知道升序索引与降序索引底层到底是如何实现的。\",\"升序索引底层实现\",\"我们知道，索引是用来提高查询速度的，但是为什么索引能提高查询速度呢？\",\"给定你一个数列，比如[1,3,7,9,2,5,4,6,8]，这是一个无序的数列或数组，现在如果想提高这个数列的查询速度，你首先会做什么？\",\"我相信大部分人都能够想到先排序，先把这个无序的数列，按从小到大的顺序进行排序，比如得到[1,2,3,4,5,6,7,8,9]，有了这个有序的数列之后，我们就可以利用比如二分法等等算法来提高这个数列的查询速度了。\",\"我举这个例子想告诉大家的是：想提高数据集合的查询速度，首先你可以对这些数据进行排序。\",\"所以，对Mysql表中的存储的数据也是一样的，我们如果想提高这个表的查询速度，我们可以先对这个表里的数据进行排序，那么表里的某一行数据包括了很多字段，我们现在想对这些数据行进行排序，我们应该根据哪些字段来确定这个顺序呢？这就是索引，在创建索引的时候你所指定的列就是用来对表里的数据行进行排序的。\",\"比如我们仍然利用上面所创建的t1表，向t1表里插入8条数据：\",\"那么这些数据肯定是存储在文件中的，所以文件中保存这些数据的格式大概如下，顺序与插入顺序保持一致：\",\"注意，t1是Innodb的存储引擎，而且a字段是主键，所以Innodb存储引擎在处理这些插入的数据时，会按主键进行排序，也就是上面我说的文件中保存这些数据的格式是不准确的，因为不想篇幅太长，所以不去深究，感兴趣的同学可以关注一波公众号：1点25，我会专门写一篇文章来讲解Innodb中索引的具体实现，包括B+树到底是如何生成的。\",\"而如果我们基于上面的这种存储方式，来查找数据，比如查找a=3的这行记录，查找需要从第一行记录开始查找，那么要查找6次，而如果我们将上面的数据按照a字段的大小来进行排序：\",\"排好序之后，如果我们还是查找a=3的这行记录，我们只需要查3次了。而且这样还有一个好处就是，如果我们现在需要查找a=3.5这行数据，如果我们基于未排序之前的存储方式，我们需要查询所有8行数据最终确定a=3.5这行数据不存在，而如果我们利用排好序之后的存储方式，我们就只需要查4次就好了，因为当你查到4311d这行记录时，你会发现4>3.5了，已经可以确定a=3.5的这行记录不存在了。\",\"而如果我们现在对t1创建一个索引，就像上面创建索引一样，如果我们写的是下面的sql:\",\"这个sql表示要对t1创建一个索引，索引字段是b,c,d，并且是升序的，所以实际上就是对原本的数据按照b,c,d三个字段进行排序，那么排序之后类似：\",\"可以好好看下，上面的记录是按照b,c,d三个字段来对数据行就行排序的，比如1111a中的b,c,d三个字段的值是111，而2222b中的b,c,d三个字段的值是222, 111是小于222的，所以对应的行排在前面。\",\"那么数据如果这样排序有什么好处呢？其实和刚刚按a字段排序之后的好处是类似的，比如你现在想来查找b=4 and c=4 and d=4的数据也是能查询更快的，实际上这就是索引的原理：\",\"我们对某个表创建一个索引，就是对这个表中的数据进行排序，而排好序之后的数据是能够提高查询速度。\",\"还有一点需要注意的是，排序有很多中方式，或者所可以利用一些数据结构，比如二叉树、红黑树、B+树，这些数据结构实际上就是对数据进行排序，只是排序的形式各不相同而已，每种数据结构有它各自的特点，而大家应该都知道，Mysql中用得最多的就是B+树了，还是一样，因为篇幅不想太长，感兴趣的同学可以关注一波公众号：1点25，我会专门写一篇文章来讲解Innodb中索引的具体实现，包括B+树到底是如何生成的。\",\"相信，看到这里，大家应该对索引重新有了认识，只不过我们上面举的几个例子都是升序排序，而且排好序之后的数据不仅可以提高查询速度，而且对于order by也是管用的，比如我们如果现在想对t1进行order by b asc,c asc,d asc；对于这个排序，如果已经在t1表建立了b,c,d的升序索引，那么就代表对t1表中的数据已经提前按照b,c,d排好序了，所以对于order by语句可以直接使用已经排好序的数据了，不用利用filesort再次进行排序了。\",\"而且如果我们的order by是order by b desc, c desc, d desc，同样可以利用b,c,d的升序索引，因为如果是order by b asc,c asc,d asc就从上往下遍历即可，如果是order by b desc, c desc, d desc就从下往上遍历即可。\",\"那么，如果是order by b asc, c desc, d desc呢？这个order by是不是就没有办法利用b,c,d的升序索引了。\",\"这个时候就需要降序索引了。\",\"降序索引底层实现\",\"我们花了较大篇幅介绍了升序索引的实现原理，总结来说就是对表中的数据按照指定的字段比较大小进行升序排序。\",\"升序是什么？是数据进行大小比较后，是小的在上，大的在下，或者如果是B+树的话就是小的在左，大的在右。而降序就是大的在上，小的在下，或者如果是B+树的话就是大的在左，小的在右。\",\"所以，对于上面的那份原始数据：\",\"如果我们将这份数据按照a desc进行排序就是：\",\"非常简单吧，那如果我们将这份数据按照b desc, c desc, d desc排序就是：\",\"也非常简单，那如果我们要将这份数据按照b desc, c asc, d desc排序呢？这是不是就有点懵了？\",\"其实不难，排序其实就是对数据比较大小，我们用下面三行数据来模拟一下：\",\"首先，按照b desc, c desc, d desc来排序，得到结果如下：\",\"按照b desc, c asc, d desc来排序，得到结果如下：\",\"可能一部分大佬已经能理解，实际上b desc所表达的意思就是b字段数据大者在上，数据小者在下，数据相等的话则开始比较c字段，而c字段是按升序排的，也就是c字段数据小者在下，数据大者在上。所以就得到了上面的结果。\",\"这就是降序索引。\",\"线程池中的线程是如何保活和回收的？\",\"我们知道线程池的作用就是提高线程的利用率，需要线程时，可以直接从线程池中获取线程直接使用，而不用创建线程，那线程池中的线程，在没有任务执行时，是如何保活的呢？\",\"线程池中的线程会不断地的从阻塞队列中获取任务，调用的是workQueue.poll()方法或take()，这两个方法都会阻塞式的从队列中获取元素，区别式poll()方法可以设置一个超时时间，take()不能设置超时时间，所以这也间接的使得线程池中的线程阻塞等待从而达到保活的效果。\",\"当然并不是线程池中的所有线程都需要一直保活，比如只有核心线程需要保活，非核心线程就不需要保活，那非核心线程是怎么回收的呢？\",\"底层是这样的，当一个线程处理完当前任务后，就会开始去阻塞队列中获取任务，只不过，在调用poll或take方法之前，会判断当前线程池中有多少个线程，如果多余核心线程数，那么当前线程就会调用poll()并设置超时时间来获取阻塞队列中的任务，这样一旦时间到了还没有获取到任务，那么线程就不会阻塞了，并且没有业务执行，那么线程就会运行结束，也就是回收了。\",\"线程池有哪几种状态，分别是如何变化的？\",\"1RUNNING：线程池正常运行中，可以正常的接受并处理任务\",\"2SHUTDOWN：线程池关闭了，不能接受新任务，但是线程池会把阻塞队列中的剩余任务执行完，剩余任务都处理完之后，会中断所有工作线程\",\"3STOP：线程池停止了，不能接受新任务，并且也不会处理阻塞队列中的任务，会中断所有工作线程\",\"4TIDYING：当前线程池中没有工作线程后，也就是线程池没有工作线程在运行了，就会进入TIDYING，这个状态是自动发生在SHUTDOWN和STOP之后的\",\"5TERMINATED：线程池处于TIDYING状态后，会执行terminated()方法，执行完后就会进入TERMINATED状态，在ThreadPoolExecutor中terminated()是一个空方法，可以自定义线程池重写这个方法\",\"作者：图灵课堂-------周瑜\",\"Tomcat的最大线程数为什么默认是200？\",\"首先，200只是一个默认值，一般默认值代表大多数情况，按照自己的情况进行修改，所以我们不应该纠结为什么是200，而不是300，这里我们应该想的是，为什么是200，而不是20，因为我们都知道并不是线程越多越好，我们一般会根据计算机的核心数来设置线程数，比如16核，那么要么我们就设置16个线程，或32个线程，怎么也不会设置到200个线程，那么Tomcat为什么默认给的是200，给的这么大呢？\",\"我个人认为，之所以这么设置，是为了用户体验。\",\"举个例子，假如你去银行取钱，但是现在只有一台点钞机，正常来说，就开一个窗口就好了，反正就一台点钞机，那对于客户来说，到底是开一个窗口让人心里舒服些，还是开10个窗口让人舒服些呢？\",\"按我去银行取钱的经验来说，是10个，因为我不想排队，这样能让我更快的感受到自己被服务了，虽然服务过程会比较慢。\",\"回到Tomcat，也是一样的，Tomcat中的线程是用来处理客户所发送过来的HTTP请求的，如果只有16个线程，那就表示同一个时刻只能处理16个请求，如果每个请求都需要查询数据库，都需要进行磁盘IO或网络IO，那这16个线程一下子就被这16个请求占用完了，当第17个请求过来时，就没有线程能处理它了，只能排队等着，设置会被拒绝服务。\",\"而Tomcat把线程数设置为200，显而易见，此时Tomcat就能同时处理200个请求了，这个对于发送请求的客户来说体验是比较好的，自己发送的请求正在被处理了，虽然可能会慢一些，但是我更加不愿意排队。\",\"什么是集群脑裂？如何解决脑裂问题？\",\"什么是脑裂\",\"脑裂(split-brain)就是“大脑分裂”，也就是本来一个“大脑”被拆分了两个或多个“大脑”，我们都知道，如果一个人有多个大脑，并且相互独立的话，那么会导致人体“手舞足蹈”，“不听使唤”。\",\"脑裂通常会出现在集群环境中，比如ElasticSearch、Zookeeper集群，而这些集群环境有一个统一的特点，就是它们有一个大脑，比如ElasticSearch集群中有Master节点，Zookeeper集群中有Leader节点。\",\"本篇文章着重来给大家讲一下Zookeeper中的脑裂问题，以及是如果解决脑裂问题的。\",\"Zookeeper集群中的脑裂场景\",\"对于一个集群，想要提高这个集群的可用性，通常会采用多机房部署，比如现在有一个由6台zkServer所组成的一个集群，部署在了两个机房：\",\"正常情况下，此集群只会有一个Leader，那么如果机房之间的网络断了之后，两个机房内的zkServer还是可以相互通信的，如果不考虑过半机制，那么就会出现每个机房内部都将选出一个Leader。\",\"这就相当于原本一个集群，被分成了两个集群，出现了两个“大脑”，这就是脑裂。\",\"对于这种情况，我们也可以看出来，原本应该是统一的一个集群对外提供服务的，现在变成了两个集群同时对外提供服务，如果过了一会，断了的网络突然联通了，那么此时就会出现问题了，两个集群刚刚都对外提供服务了，数据该怎么合并，数据冲突怎么解决等等问题。\",\"刚刚在说明脑裂场景时，有一个前提条件就是没有考虑过半机制，所以实际上Zookeeper集群中是不会出现脑裂问题的，而不会出现的原因就跟过半机制有关。\",\"过半机制\",\"在领导者选举的过程中，如果某台zkServer获得了超过半数的选票，则此zkServer就可以成为Leader了。\",\"过半机制的源码实现其实非常简单：\",\"大家仔细看一下上面方法中的注释，核心代码就是下面两行：\",\"举个简单的例子：\",\"如果现在集群中有5台zkServer，那么half=5/2=2，那么也就是说，领导者选举的过程中至少要有三台zkServer投了同一个zkServer，才会符合过半机制，才能选出来一个Leader。\",\"那么有一个问题我们想一下，选举的过程中为什么一定要有一个过半机制验证？\",\"因为这样不需要等待所有zkServer都投了同一个zkServer就可以选举出来一个Leader了，这样比较快，所以叫快速领导者选举算法呗。\",\"那么再来想一个问题，过半机制中为什么是大于，而不是大于等于呢？\",\"这就是更脑裂问题有关系了，比如回到上文出现脑裂问题的场景：\",\"当机房中间的网络断掉之后，机房1内的三台服务器会进行领导者选举，但是此时过半机制的条件是set.size() > 3，也就是说至少要4台zkServer才能选出来一个Leader，所以对于机房1来说它不能选出一个Leader，同样机房2也不能选出一个Leader，这种情况下整个集群当机房间的网络断掉后，整个集群将没有Leader。\",\"而如果过半机制的条件是set.size() >= 3，那么机房1和机房2都会选出一个Leader，这样就出现了脑裂。所以我们就知道了，为什么过半机制中是大于，而不是大于等于。就是为了防止脑裂。\",\"如果假设我们现在只有5台机器，也部署在两个机房：\",\"此时过半机制的条件是set.size() > 2，也就是至少要3台服务器才能选出一个Leader，此时机房件的网络断开了，对于机房1来说是没有影响的，Leader依然还是Leader，对于机房2来说是选不出来Leader的，此时整个集群中只有一个Leader。\",\"所以，我们可以总结得出，有了过半机制，对于一个Zookeeper集群，要么没有Leader，要没只有1个Leader，这样就避免了脑裂问题。\",\"作者：图灵课堂-------周瑜\",\"微服务中什么是应用级注册？什么是接口级注册？优缺点是什么？\",\"目前大部分的微服务框架都是应用级注册，比如SpringCloud，包括K8S也是应用注册，应用级注册代表是把整个应用作为一个微服务注册到注册中心，注册中心保存的数据格式为：\",\"应用名:\",\"实例1的ip和port\",\"实例2的ip和port\",\"实例3的ip和port\",\"而接口级注册，代表是把应用中的某个接口作为一个微服务注册到注册中心，注册中心保存的数据格式为：\",\"接口1：\",\"实例1的ip和port\",\"实例2的ip和port\",\"实例3的ip和port\",\"接口2：\",\"实例1的ip和port\",\"实例2的ip和port\",\"实例3的ip和port\",\"目前Dubbo3.0之前的版本采取的就是接口级注册，Dubbo3.0已经支持了应用级注册。\",\"接口级注册的好处在于，对于消费者而言，可以直接面向接口，消费者想要使用哪个接口，就可以直接从注册中心根据接口名找到接口所在的地址，然后直接调用，而不用关心接口在哪个应用。而对于应用级注册，对于消费者而言，需要知道想要使用的接口在哪个应用，然后获取应用实例地址，再去调用接口，相比较接口级注册而言就稍微麻烦了一点。\",\"接口级注册的缺点在于，注册中心的存储的冗余信息较多，注册中心的压力更大，注册中心存储的数据如果越多，那么数据发生改变的频率也就越高，对于消费者而言就需要消耗资源来进行同步，也增加了消费者应用的压力。\",\"SpringBoot的自动配置是如何实现的？\",\"首先，SpringBoot的自动配置主要作用就是帮助程序员配置了Bean，如果我们不使用SpringBoot，而使用Spring，那么我们在使用Mybatis、各种消息队列、AOP、Spring事务等等功能的时候，除开要添加相关的依赖包之外，还要额外的配置相关的Bean，而SpringBoot的Starter机制就是帮我们更便捷的添加相关的Bean，SpringBoot的自动配置就是帮我们配置了一些。\",\"SpringBoot会通过自动配置类来承载这些Bean，按不同的业务功能，分为不同的自动配置类，每个自动配置类中就定义了该业务相关的Bean，自动配置类其实就是Spring的配置类，只不过是SpringBoot默认给我们提供的，所以叫自动配置类。\",\"另外由于这些自动配置类，是在SpringBoot内部定义的，而对于我们的项目而言，一般情况下是扫描不到这些自动配置的，所以在SpringBoot中会利用@Import注解、以及DeferredImportSelector、以及spring.factories来实现自动配置类的加载，spring.factories相当于SpringBoot的SPI机制，所以如果第三方框架，比如Mybatis，也想提供一些自动配置类，那么也可以在自己的spring.factories文件中添加自己的自动配置类，到时候SpringBoot是能够读取出来并进行解析的。\",\"另外SpringBoot中的自动配置功能的实现，还有一个核心就是添加注解，SpringBoot中基于@Conditional注解扩展了很多其他的条件注解，比如@ConditionalOnClass、@ConditionalOnBean等等，这些条件注解可以用来控制，某个自动配置类或某个Bean是否真正生效，符合所定义的条件才生效，比如如果程序员自己定义了一个，那么SpringBoot默认提供的Bean那就不生效了，这些都是利用条件注解来实现的。\",\"作者：图灵课堂-------周瑜\",\"SpringBoot中配置优先级是怎样的？\",\"流程图：https://www.processon.com/view/link/62d399e71e08530a89222b23\",\"如何设计一个RPC框架？\",\"首先，RPC表示远程过程调用，在Java中表示远程方法调用，所以，一个RPC框架就是一个能支持调用远程方法的框架。\",\"作为一个RPC框架，那最核心的就是网络调用了，也就是如何高效的调用远程方法，比如：\",\"1通过网络，要发送哪些数据，比如至少得发送类名或接口名、要调用的方法名、调用方法时传入的参数等\",\"2方法参数通常是对象，那如果要通过网络发送对象，就要考虑序列化和反序列化，那使用何种序列化机制也是要考虑的\",\"3确定好了要发送的数据后，那通过什么方式发出去呢，是直接通过Socket发出去呢，还是利用HTTP发出去\",\"4如果利用HTTP来发，那是用HTTP1.1呢，还是用HTTP2呢，请求头放什么数据，请求体放什么数据呢？\",\"5如何直接通过Socket来发，那就需要自己设计一个数据格式了，类似与HTTP协议，不然服务端接收到字节流之后不知道该如何解析字节流\",\"6确定好数据格式和网络传输方式之后，就要考虑是否支持异步，是否支持回调等功能了\",\"7另外像负载均衡、服务容错、服务路由、服务重试等功能也要一步步丰满起来了，那这又是一大堆需要考虑的了\",\"所以，对于如何设计一个RPC框架，大体思路是先设计一个最小可用的远程调用框架，然后不断优化性能，然后再不断扩展其功能，作为成为一个成熟的RPC框架，甚至于一个微服务框架。\",\"看以下代码回答问题（一）\",\"答案：\",\"看以下代码回答问题（二）\",\"答案：\",\"1s1 == s2为false\",\"2s2 == s3为true\",\"String对象的intern方法，首先会检查字符串常量池中是否存在\\\"abc\\\"，如果存在则返回该字符串引用，如果不存在，则把\\\"abc\\\"添加到字符串常量池中，并返回该字符串常量的引用。\",\"看以下代码回答问题（三）\",\"答案：\",\"1i1 == i2为true\",\"2i3 == i4为false\",\"在Interger类中，存在一个静态内部类IntegerCache， 该类中存在一个Integer cache[]， 并且存在一个static块，会在加载类的时候执行，会将-128至127这些数字提前生成Integer对象，并缓存在cache数组中，当我们在定义Integer数字时，会调用Integer的valueOf方法，valueOf方法会判断所定义的数字是否在-128至127之间，如果存在则直接从cache数组中获取Integer对象，如果超过，则生成一个新的Integer对象。\",\"String、StringBuffer、StringBuilder的区别\",\"1String是不可变的，如果尝试去修改，会新生成一个字符串对象，StringBuffer和StringBuilder是可变的\",\"2StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下StringBuilder效率会更高\",\"ArrayList和LinkedList有哪些区别\",\"1首先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的\",\"2由于底层数据结构不同，他们所适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同\",\"3另外ArrayList和LinkedList都实现了List接口，但是LinkedList还额外实现了Deque接口，所以LinkedList还可以当做队列来使用\",\"CopyOnWriteArrayList的底层原理是怎样的\",\"1首先CopyOnWriteArrayList内部也是用数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新数组上进行，读操作在原数组上进行\",\"2并且，写操作会加锁，防止出现并发写入丢失数据的问题\",\"3写操作结束之后会把原数组指向新数组\",\"4CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场景，但是CopyOnWriteArrayList会比较占内存，同时可能读到的数据不是实时最新的数据，所以不适合实时性要求很高的场景\",\"HashMap的扩容机制原理\",\"1.7版本\",\"1先生成新数组\",\"2遍历老数组中的每个位置上的链表上的每个元素\",\"3取每个元素的key，并基于新数组长度，计算出每个元素在新数组中的下标\",\"4将元素添加到新数组中去\",\"5所有元素转移完了之后，将新数组赋值给HashMap对象的table属性\",\"1.8版本\",\"1先生成新数组\",\"2遍历老数组中的每个位置上的链表或红黑树\",\"3如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去\",\"4如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置\",\"a统计每个下标位置的元素个数\",\"b如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置\",\"c如果该位置下的元素个数没有超过6，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置\",\"5所有元素转移完了之后，将新数组赋值给HashMap对象的table属性\",\"ConcurrentHashMap的扩容机制\",\"1.7版本\",\"11.7版本的ConcurrentHashMap是基于Segment分段实现的\",\"2每个Segment相对于一个小型的HashMap\",\"3每个Segment内部会进行扩容，和HashMap的扩容逻辑类似\",\"4先生成新的数组，然后转移元素到新数组中\",\"5扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值\",\"1.8版本\",\"11.8版本的ConcurrentHashMap不再基于Segment实现\",\"2当某个线程进行put时，如果发现ConcurrentHashMap正在进行扩容那么该线程一起进行扩容\",\"3如果某个线程put时，发现没有正在进行扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进行扩容\",\"4ConcurrentHashMap是支持多个线程同时扩容的\",\"5扩容之前也先生成一个新的数组\",\"6在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作\",\"ThreadLocal的底层原理\",\"1ThreadLocal是Java中所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据\",\"2ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在一个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值\",\"3如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key，value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏，解决办法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清楚Entry对象\",\"4ThreadLocal经典的应用场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同的方法之间进行传递，线程之间不共享同一个连接）\",\"作者：图灵课堂-------周瑜\",\"如何理解volatile关键字\",\"在并发领域中，存在三大特性：原子性、有序性、可见性。volatile关键字用来修饰对象的属性，在并发环境下可以保证这个属性的可见性，对于加了volatile关键字的属性，在对这个属性进行修改时，会直接将CPU高级缓存中的数据写回到主内存，对这个变量的读取也会直接从主内存中读取，从而保证了可见性，底层是通过操作系统的内存屏障来实现的，由于使用了内存屏障，所以会禁止指令重排，所以同时也就保证了有序性，在很多并发场景下，如果用好volatile关键字可以很好的提高执行效率。\",\"ReentrantLock中的公平锁和非公平锁的底层实现\",\"首先不管是公平锁和非公平锁，它们的底层实现都会使用AQS来进行排队，它们的区别在于：线程在使用lock()方法加锁时，如果是公平锁，会先检查AQS队列中是否存在线程在排队，如果有线程在排队，则当前线程也进行排队，如果是非公平锁，则不会去检查是否有线程在排队，而是直接竞争锁。\",\"不管是公平锁还是非公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程，所以非公平锁只是体现在了线程加锁阶段，而没有体现在线程被唤醒阶段。\",\"另外，ReentrantLock是可重入锁，不管是公平锁还是非公平锁都是可重入的。\",\"公平锁加锁\",\"干\",\"左句镇0品宁\",\"从列中花\",\"W55:Kle\",\"加0次戴功\",\"刀始入射\",\"开始入队\",\"一倍入风\",\"O苏\",\"hees\",\"让默,姐一个程\",\"Node\",\"为宝为Nre时,为队列\",\"快\",\"THREAC-REEI\",\"Tra1-千配6\",\"入队应功\",\"人队日名\",\"长九时,营列巾口航标\",\"如才兰纳u味是队列\",\"为-1,在示前一个节用并\",\"啦:一个检SNaAca?\",\"立风完大务家代\",\"长在\",\"户川不的的品制构设堂\",\"WA?\",\"小方司\",\"​\",\"非公平锁加锁\",\"c州免防R\",\"星河曲力\",\"1线购T1\",\"凯艾\",\"中\",\"1oO55h\",\"开姓入队\",\"血皮制古HULL\",\"队列\",\"太\",\"的老六具\",\"uzm.t包线口g8\",\"梅-ecSSkgs\",\"办新一个五气料\",\"饮i否w>sk六虾杯\",\"气十炎下肉情无上,\",\"KS航k\",\"INGNR动\",\"ReentrantLock中tryLock()和lock()方法的区别\",\"1tryLock()表示尝试加锁，可能加到，也可能加不到，该方法不会阻塞线程，如果加到锁则返回true，没有加到则返回false\",\"2lock()表示阻塞加锁，线程会阻塞直到加到锁，方法也没有返回值\",\"CountDownLatch和Semaphore的区别和底层原理\",\"CountDownLatch表示计数器，可以给CountDownLatch设置一个数字，一个线程调用CountDownLatch的await()将会阻塞，其他线程可以调用CountDownLatch的countDown()方法来对CountDownLatch中的数字减一，当数字被减成0后，所有await的线程都将被唤醒。\",\"对应的底层原理就是，调用await()方法的线程会利用AQS排队，一旦数字被减为0，则会将AQS中排队的线程依次唤醒。\",\"Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量，通过acquire()来获取许可，如果没有许可可用则线程阻塞，并通过AQS来排队，可以通过release()方法来释放许可，当某个线程释放了某个许可后，会从AQS中正在排队的第一个线程开始依次唤醒，直到没有空闲许可。\",\"Sychronized的偏向锁、轻量级锁、重量级锁\",\"1偏向锁：在锁对象的对象头中记录一下当前获取到该锁的线程ID，该线程下次如果又来获取该锁就可以直接获取到了\",\"2轻量级锁：由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁，此时如果有第二个线程来竞争锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和重量级锁区分开来，轻量级锁底层是通过自旋来实现的，并不会阻塞线程\",\"3如果自旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞\",\"4自旋锁：自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较消耗时间，自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程一直在运行中，相对而言没有使用太多的操作系统资源，比较轻量。\",\"Sychronized和ReentrantLock的区别\",\"1sychronized是一个关键字，ReentrantLock是一个类\",\"2sychronized会自动的加锁与释放锁，ReentrantLock需要程序员手动加锁与释放锁\",\"3sychronized的底层是JVM层面的锁，ReentrantLock是API层面的锁\",\"4sychronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁\",\"5sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock通过代码中int类型的state标识来标识锁的状态\",\"6sychronized底层有一个锁升级的过程\",\"作者：图灵课堂-------周瑜\",\"线程池有哪些状态？每种状态的效果是怎样的？\",\"1RUNNING： Accept new tasks and process queued tasks，线程池正常运行，既接受新任务，也会处理队列中的任务\",\"2SHUTDOWN：Don't accept new tasks, but process queued tasks，当调用线程池的shutdown()方法时，线程池就进入SHUTDOWN状态，线程池不会接受新任务了，但是会继续处理队列中的任务\",\"3STOP：Don't accept new tasks, don't process queued tasks, and interrupt in-progress tasks，当调用线程池的shutdownnow()方法时，线程池就进入STOP状态，线程池既不会接受新任务了，也不会处理队列中的任务，并且正在运行的线程也会被中断\",\"4TIDYING：All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYING will run the terminated() hook method，当线程池中没有线程在运行后，线程池的状态就会自动变为TIDYING，并且会调用terminated()，该方法是空方法，留给程序员进行扩展。\",\"5TERMINATED：terminated() has completed，terminated()方法执行完之后，线程池状态就会变为TERMINATED\",\"线程池的底层工作原理\",\"线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时：\",\"1如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。\",\"2如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。\",\"3如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。\",\"4如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。\",\"5当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数\",\"JVM中哪些是线程共享区\",\"堆区和方法区是所有线程共享的，栈、本地方法栈、程序计数器是每个线程独有的\",\"JVM中哪些可以作为gc root\",\"什么是gc root，JVM在进行垃圾回收时，需要找到“垃圾”对象，也就是没有被引用的对象，但是直接找“垃圾”对象是比较耗时的，所以反过来，先找“非垃圾”对象，也就是正常对象，那么就需要从某些“根”开始去找，根据这些“根”的引用路径找到正常对象，而这些“根”有一个特征，就是它只会引用其他对象，而不会被其他对象引用，例如：栈中的本地变量、方法区中的静态变量、本地方法栈中的变量、正在运行的线程等可以作为gc root。\",\"你们项目如何排查JVM问题\",\"对于还在正常运行的系统：\",\"1可以使用jmap来查看JVM中各个区域的使用情况\",\"2可以通过jstack来查看线程的运行情况，比如哪些线程阻塞、是否出现了死锁\",\"3可以通过jstat命令来查看垃圾回收的情况，特别是fullgc，如果发现fullgc比较频繁，那么就得进行调优了\",\"4通过各个命令的结果，或者jvisualvm等工具来进行分析\",\"5首先，初步猜测频繁发生fullgc的原因，如果频繁发生fullgc但是又一直没有出现内存溢出，那么表示fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，避免这些对象进入到老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入到了老年代，尝试加大年轻代的大小，如果改完之后，fullgc减少，则证明修改有效\",\"6同时，还可以找到占用CPU最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存\",\"对于已经发生了OOM的系统：\",\"1一般生产系统中都会设置当系统发生了OOM时，生成当时的dump文件（-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/base）\",\"2我们可以利用jsisualvm等工具来分析dump文件\",\"3根据dump文件找到异常的实例对象，和异常的线程（占用CPU高），定位到具体的代码\",\"4然后再进行详细的分析和调试\",\"总之，调优不是一蹴而就的，需要分析、推理、实践、总结、再分析，最终定位到具体的问题\",\"说说类加载器双亲委派模型\",\"JVM中存在三个默认的类加载器：\",\"1BootstrapClassLoader\",\"2ExtClassLoader\",\"3AppClassLoader\",\"AppClassLoader的父加载器是ExtClassLoader，ExtClassLoader的父加载器是BootstrapClassLoader。\",\"JVM在加载一个类时，会调用AppClassLoader的loadClass方法来加载这个类，不过在这个方法中，会先使用ExtClassLoader的loadClass方法来加载类，同样ExtClassLoader的loadClass方法中会先使用BootstrapClassLoader来加载类，如果BootstrapClassLoader加载到了就直接成功，如果BootstrapClassLoader没有加载到，那么ExtClassLoader就会自己尝试加载该类，如果没有加载到，那么则会由AppClassLoader来加载这个类。\",\"所以，双亲委派指得是，JVM在加载类时，会委派给Ext和Bootstrap进行加载，如果没加载到才由自己进行加载。\",\"Tomcat中为什么要使用自定义类加载器\",\"一个Tomcat中可以部署多个应用，而每个应用中都存在很多类，并且各个应用中的类是独立的，全类名是可以相同的，比如一个订单系统中可能存在com.zhouyu.User类，一个库存系统中可能也存在com.zhouyu.User类，一个Tomcat，不管内部部署了多少应用，Tomcat启动之后就是一个Java进程，也就是一个JVM，所以如果Tomcat中只存在一个类加载器，比如默认的AppClassLoader，那么就只能加载一个com.zhouyu.User类，这是有问题的，而在Tomcat中，会为部署的每个应用都生成一个类加载器实例，名字叫做WebAppClassLoader，这样Tomcat中每个应用就可以使用自己的类加载器去加载自己的类，从而达到应用之间的类隔离，不出现冲突。另外Tomcat还利用自定义加载器实现了热加载功能。\",\"Tomcat如何进行优化？\",\"对于Tomcat调优，可以从两个方面来进行调整：内存和线程。\",\"首先启动Tomcat，实际上就是启动了一个JVM，所以可以按JVM调优的方式来进行调整，从而达到Tomcat优化的目的。\",\"另外Tomcat中设计了一些缓存区，比如appReadBufSize、bufferPoolSize等缓存区来提高吞吐量。\",\"还可以调整Tomcat的线程，比如调整minSpareThreads参数来改变Tomcat空闲时的线程数，调整maxThreads参数来设置Tomcat处理连接的最大线程数。\",\"并且还可以调整IO模型，比如使用NIO、APR这种相比于BIO更加高效的IO模型。\",\"浏览器发出一个请求到收到响应经历了哪些步骤？\",\"1浏览器解析用户输入的URL，生成一个HTTP格式的请求\",\"2先根据URL域名从本地hosts文件查找是否有映射IP，如果没有就将域名发送给电脑所配置的DNS进行域名解析，得到IP地址\",\"3浏览器通过操作系统将请求通过四层网络协议发送出去\",\"4途中可能会经过各种路由器、交换机，最终到达服务器\",\"5服务器收到请求后，根据请求所指定的端口，将请求传递给绑定了该端口的应用程序，比如8080被tomcat占用了\",\"6tomcat接收到请求数据后，按照http协议的格式进行解析，解析得到所要访问的servlet\",\"7然后servlet来处理这个请求，如果是SpringMVC中的DispatcherServlet，那么则会找到对应的Controller中的方法，并执行该方法得到结果\",\"8Tomcat得到响应结果后封装成HTTP响应的格式，并再次通过网络发送给浏览器所在的服务器\",\"9浏览器所在的服务器拿到结果后再传递给浏览器，浏览器则负责解析并渲染\",\"谈谈你对IOC的理解\",\"通常，我们认为Spring有两大特性IoC和AOP，那到底该如何理解IoC呢？\",\"对于很多初学者来说，IoC这个概念给人的感觉就是我好像会，但是我说不出来。\",\"那么IoC到底是什么，接下来来说说我的理解，实际上这是一个非常大的问题，所以我们就把它拆细了来回答，IoC表示控制反转，那么：\",\"1什么是控制？控制了什么？\",\"2什么是反转？反转之前是谁控制的？反转之后是谁控制的？如何控制的？\",\"3为什么要反转？反转之前有什么问题？反转之后有什么好处？\",\"这就是解决这一类大问题的思路，大而化小。\",\"那么，我们先来解决第一个问题：什么是控制？控制了什么？\",\"我们在用Spring的时候，我们需要做什么：\",\"1建一些类，比如UserService、OrderService\",\"2用一些注解，比如@Autowired\",\"但是，我们也知道，当程序运行时，用的是具体的UserService对象、OrderService对象，那这些对象是什么时候创建的？谁创建的？包括对象里的属性是什么时候赋的值？谁赋的？所有这些都是我们程序员做的，以为我们只是写了类而已，所有的这些都是Spring做的，它才是幕后黑手。\",\"这就是控制：\",\"1控制对象的创建\",\"2控制对象内属性的赋值\",\"如果我们不用Spring，那我们得自己来做这两件事，反过来，我们用Spring，这两件事情就不用我们做了，我们要做的仅仅是定义类，以及定义哪些属性需要Spring来赋值（比如某个属性上加@Autowired），而这其实就是第二个问题的答案，这就是反转，表示一种对象控制权的转移。\",\"那反转有什么用，为什么要反转？\",\"如果我们自己来负责创建对象，自己来给对象中的属性赋值，会出现什么情况？\",\"比如，现在有三个类：\",\"1A类，A类里有一个属性C c；\",\"2B类，B类里也有一个属性C c；\",\"3C类\",\"现在程序要运行，这三个类的对象都需要创建出来，并且相应的属性都需要有值，那么除开定义这三个类之外，我们还得写：\",\"1A a = new A();\",\"2B b = new B();\",\"3C c = new C();\",\"4a.c = c;\",\"5b.c = c;\",\"这五行代码是不用Spring的情况下多出来的代码，而且，如果类在多一些，类中的属性在多一些，那相应的代码会更多，而且代码会更复杂。所以我们可以发现，我们自己来控制比交给Spring来控制，我们的代码量以及代码复杂度是要高很多的，反言之，将对象交给Spring来控制，减轻了程序员的负担。\",\"总结一下，IoC表示控制反转，表示如果用Spring，那么Spring会负责来创建对象，以及给对象内的属性赋值，也就是如果用Spring，那么对象的控制权会转交给Spring。\",\"Spring中的Bean创建的生命周期有哪些步骤\",\"Spring中一个Bean的创建大概分为以下几个步骤：\",\"1推断构造方法\",\"2实例化\",\"3填充属性，也就是依赖注入\",\"4处理Aware回调\",\"5初始化前，处理@PostConstruct注解\",\"6初始化，处理InitializingBean接口\",\"7初始化后，进行AOP\",\"当然其实真正的步骤更加细致，可以看下面的流程图\",\"Spring启动\",\"单例BeanDotinition\",\"填充口性\",\"单创日can生成\",\"初始化\",\"实斛化化\",\"初始化前\",\"历beanDefinitionMap\",\"扫播\",\"实耐化前\",\"合井BeanDefinition\",\"填充二性\",\"垃充属性后\",\"精选出单例BeanDrtnibon\",\"加式类\",\"生成BeanDefiniton\",\"推断梅造方法\",\"扭始合化\",\"pul\",\"beanDefinitionMapsbeanNa\",\"初始化后\",\"实的化\",\"实懈化\",\"汽历单哥BeanDefinition\",\"me,BeanDehinition\",\"实时化化后\",\"垃充属性\",\"执行回调\",\"初始化\",\"Spring中Bean是线程安全的吗\",\"Spring本身并没有针对Bean做线程安全的处理，所以：\",\"1如果Bean是无状态的，那么Bean则是线程安全的\",\"2如果Bean是有状态的，那么Bean则不是线程安全的\",\"另外，Bean是不是线程安全，跟Bean的作用域没有关系，Bean的作用域只是表示Bean的生命周期范围，对于任何生命周期的Bean都是一个对象，这个对象是不是线程安全的，还是得看这个Bean对象本身。\",\"ApplicationContext和BeanFactory有什么区别\",\"BeanFactory是Spring中非常核心的组件，表示Bean工厂，可以生成Bean，维护Bean，而ApplicationContext继承了BeanFactory，所以ApplicationContext拥有BeanFactory所有的特点，也是一个Bean工厂，但是ApplicationContext除开继承了BeanFactory之外，还继承了诸如EnvironmentCapable、MessageSource、ApplicationEventPublisher等接口，从而ApplicationContext还有获取系统环境变量、国际化、事件发布等功能，这是BeanFactory所不具备的\",\"Spring中的事务是如何实现的\",\"1Spring事务底层是基于数据库事务和AOP机制的\",\"2首先对于使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean\",\"3当调用代理对象的方法时，会先判断该方法上是否加了@Transactional注解\",\"4如果加了，那么则利用事务管理器创建一个数据库连接\",\"5并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步\",\"6然后执行当前方法，方法中会执行sql\",\"7执行完当前方法后，如果没有出现异常就直接提交事务\",\"8如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务\",\"9Spring事务的隔离级别对应的就是数据库的隔离级别\",\"10Spring事务的传播机制是Spring事务自己实现的，也是Spring事务中最复杂的\",\"11Spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制配置为需要新开一个事务，那么实际上就是先建立一个数据库连接，在此新数据库连接上执行sql\",\"Spring中什么时候@Transactional会失效\",\"因为Spring事务是基于代理来实现的，所以某个加了@Transactional的方法只有是被代理对象调用时，那么这个注解才会生效，所以如果是被代理对象来调用这个方法，那么@Transactional是不会失效的。\",\"同时如果某个方法是private的，那么@Transactional也会失效，因为底层cglib是基于父子类来实现的，子类是不能重载父类的private方法的，所以无法很好的利用代理，也会导致@Transactianal失效\",\"Spring容器启动流程是怎样的\",\"1在创建Spring容器，也就是启动Spring时：\",\"2首先会进行扫描，扫描得到所有的BeanDefinition对象，并存在一个Map中\",\"3然后筛选出非懒加载的单例BeanDefinition进行创建Bean，对于多例Bean不需要在启动过程中去进行创建，对于多例Bean会在每次获取Bean时利用BeanDefinition去创建\",\"4利用BeanDefinition创建Bean就是Bean的创建生命周期，这期间包括了合并BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发生在初始化后这一步骤中\",\"5单例Bean创建完了之后，Spring会发布一个容器启动事件\",\"6Spring启动结束\",\"7在源码中会更复杂，比如源码中会提供一些模板方法，让子类来实现，比如源码中还涉及到一些BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过BenaFactoryPostProcessor来实现的，依赖注入就是通过BeanPostProcessor来实现的\",\"8在Spring启动过程中还会去处理@Import等注解\",\"作者：图灵课堂-------周瑜\",\"为什么不推荐使用@Autowired字段注入\",\"1@Autowired注解是有Spring提供的，而一旦后续不用Spring了，想用其他的IoC容器时，那@Autowired注解就没有用了，所以建议用@Resource，因为它是Java层面提供的\",\"2另外推荐用构造方法进行依赖注入，因为我们使用字段注入是没有限制的，可以给很多个字段进行注入，而我们通过构造方法注入时，如果有很多属性需要注入，那么构造方法将会有非常多的入参，这时就会提醒你，是否这些依赖都是必须的\",\"Spring用到了哪些设计模式\",\"BeanFactory\",\"工厂模式\",\"FactoryBean\",\"ProxyFactory\",\"原型Bean\",\"原型模式\",\"PrototypeTargetSource\",\"PrototypeaspectlnstanceFactory\",\"单例Bean\",\"SingletonTargetsource\",\"单例模式\",\"DefaultBeanNameGenerator\",\"SimpleAutowireCandidateResolver\",\"AnnotationAwareOrderComparator\",\"BeanDefinition构造芸\",\"BeanDefinitionBuilder\",\"解析并梅造@Aspecu注解的Bean中所定义的Advisor\",\"构建器模式\",\"BeanFactoryAspecUAdvisorsBuilder\",\"StringBuilder\",\"@EventListener注解的方法适九成ApplicationListener\",\"ApplicationListenerMethodAdapter\",\"适配器模式\",\"AdvisorAdapter\",\"把Advison适配成Methodlnterceptor\",\"Spring中的设计模式-周瑜\",\"属性访问器,用来访问和设苦某个对象的某个三性\",\"PropertyAccessor\",\"访问者模式\",\"国际化资源访问器\",\"MessageSourceAccessor\",\"比单纯的Bean对象功能更加强大\",\"BeanWrapper\",\"装饰器模式回\",\"HttpRequestWrapper\",\"方式生成了代理对象的地方就用到了代理模式\",\"AOP\",\"代理模式\",\"@Configuration\",\"@Lazy\",\"事件监听机制\",\"ApplicationListener\",\"观察者模式国\",\"Proyfactoy可以提交此监听器,用来监听Proyfacton创建代理对象完成事件,添加Adi享件等\",\"AdvisedsupportListener\",\"Spring需要很据BeanDefinition来实例化Bean,但是具体可以选择不同的策路来进行实例化\",\"lnstantiationStrategy\",\"策略模式国\",\"beanName生成器\",\"BeanNameGenerato\",\"子类可以继续处理BeanfFacitory\",\"postProcessBeanFactory0\",\"模板方法模式4\",\"AbstractApplicationContext\",\"子类可以做一些额外的初始化\",\"onRefresho\",\"负责造一条Advisorchain,代理对象执行某个方法时会恢次条过Adisorchain中的每个ADiSOR\",\"DefaultAdvisorChainFactory\",\"责任链模式\",\"QualifierAnnotationAutowireCandidateResolver\",\"判新某个Bean能不能用来进行依赖注入强可以认为也是责任链\",\"SpringMVC的底层工作流程\",\"1用户发送请求至前端控制器DispatcherServlet。\",\"2DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。\",\"3处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。\",\"4DispatcherServlet 调用 HandlerAdapter 处理器适配器。\",\"5HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)\",\"6Controller 执行完成返回 ModelAndView。\",\"7HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。\",\"8DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。\",\"9ViewReslover 解析后返回具体 View。\",\"10DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。\",\"11DispatcherServlet 响应用户。\",\"SpringBoot中常用注解及其底层实现\",\"1@SpringBootApplication注解：这个注解标识了一个SpringBoot工程，它实际上是另外三个注解的组合，这三个注解是：\",\"a@SpringBootConfiguration：这个注解实际就是一个@Configuration，表示启动类也是一个配置类\",\"b@EnableAutoConfiguration：向Spring容器中导入了一个Selector，用来加载ClassPath下SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean\",\"c@ComponentScan：标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前目录\",\"2@Bean注解：用来定义Bean，类似于XML中的<bean>标签，Spring在启动时，会对加了@Bean注解的方法进行解析，将方法的名字做为beanName，并通过执行方法得到bean对象\",\"3@Controller、@Service、@ResponseBody、@Autowired都可以说\",\"SpringBoot是如何启动Tomcat的\",\"1首先，SpringBoot在启动时会先创建一个Spring容器\",\"2在创建Spring容器过程中，会利用@ConditionalOnClass技术来判断当前classpath中是否存在Tomcat依赖，如果存在则会生成一个启动Tomcat的Bean\",\"3Spring容器创建完之后，就会获取启动Tomcat的Bean，并创建Tomcat对象，并绑定端口等，然后启动Tomcat\",\"SpringBoot中配置文件的加载顺序是怎样的？\",\"优先级从高到低，高优先级的配置覆盖低优先级的配置，所有配置会形成互补配置。\",\"1命令行参数。所有的配置都可以在命令行上进行指定；\",\"2Java系统属性（System.getProperties()）；\",\"3操作系统环境变量 ；\",\"4jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件\",\"5jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 再来加载不带profile\",\"6jar包外部的application.properties或application.yml(不带spring.profile)配置文件\",\"7jar包内部的application.properties或application.yml(不带spring.profile)配置文件\",\"8@Configuration注解类上的@PropertySource\",\"Mybatis存在哪些优点和缺点\",\"优点：\",\"1基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL单独写，解除 sql 与程序代码的耦合，便于统一管理。\",\"2与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；\",\"3很好的与各种数据库兼容（ 因为 MyBatis 使用 JDBC 来连接数据库，所以只要JDBC 支持的数据库MyBatis 都支持）。\",\"4能够与 Spring 很好的集成；\",\"5提供映射标签， 支持对象与数据库的 ORM 字段关系映射； 提供对象关系映射标签， 支持对象关系组件维护。\",\"缺点：\",\"1SQL 语句的编写工作量较大， 尤其当字段多、关联表多时， 对开发人员编写SQL 语句的功底有一定要求。\",\"2SQL 语句依赖于数据库， 导致数据库移植性差， 不能随意更换数据库\",\"Mybatis中#{}和${}的区别是什么？\",\"1#{}是预编译处理、是占位符， ${}是字符串替换、是拼接符\",\"2Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 来赋值\",\"3Mybatis 在处理${}时， 就是把${}替换成变量的值，调用 Statement 来赋值\",\"4使用#{}可以有效的防止SQL注入，提高系统安全性\",\"什么是CAP理论\",\"CAP理论是分布式领域中非常重要的一个指导理论，C（Consistency）表示强一致性，A（Availability）表示可用性，P（Partition Tolerance）表示分区容错性，CAP理论指出在目前的硬件条件下，一个分布式系统是必须要保证分区容错性的，而在这个前提下，分布式系统要么保证CP，要么保证AP，无法同时保证CAP。\",\"分区容错性表示，一个系统虽然是分布式的，但是对外看上去应该是一个整体，不能由于分布式系统内部的某个结点挂点，或网络出现了故障，而导致系统对外出现异常。所以，对于分布式系统而言是一定要保证分区容错性的。\",\"强一致性表示，一个分布式系统中各个结点之间能及时的同步数据，在数据同步过程中，是不能对外提供服务的，不然就会造成数据不一致，所以强一致性和可用性是不能同时满足的。\",\"可用性表示，一个分布式系统对外要保证可用。\",\"什么是BASE理论\",\"由于不能同时满足CAP，所以出现了BASE理论：\",\"1BA：Basically Available，表示基本可用，表示可以允许一定程度的不可用，比如由于系统故障，请求时间变长，或者由于系统故障导致部分非核心功能不可用，都是允许的\",\"2S：Soft state：表示分布式系统可以处于一种中间状态，比如数据正在同步\",\"3E：Eventually consistent，表示最终一致性，不要求分布式系统数据实时达到一致，允许在经过一段时间后再达到一致，在达到一致过程中，系统也是可用的\",\"什么是RPC\",\"RPC，表示远程过程调用，对于Java这种面试对象语言，也可以理解为远程方法调用，RPC调用和HTTP调用是有区别的，RPC表示的是一种调用远程方法的方式，可以使用HTTP协议、或直接基于TCP协议来实现RPC，在Java中，我们可以通过直接使用某个服务接口的代理对象来执行方法，而底层则通过构造HTTP请求来调用远端的方法，所以，有一种说法是RPC协议是HTTP协议之上的一种协议，也是可以理解的。\",\"分布式ID是什么？有哪些解决方案？\",\"在开发中，我们通常会需要一个唯一ID来标识数据，如果是单体架构，我们可以通过数据库的主键，或直接在内存中维护一个自增数字来作为ID都是可以的，但对于一个分布式系统，就会有可能会出现ID冲突，此时有以下解决方案：\",\"1uuid，这种方案复杂度最低，但是会影响存储空间和性能\",\"2利用单机数据库的自增主键，作为分布式ID的生成器，复杂度适中，ID长度较之uuid更短，但是受到单机数据库性能的限制，并发量大的时候，此方案也不是最优方案\",\"3利用redis、zookeeper的特性来生成id，比如redis的自增命令、zookeeper的顺序节点，这种方案和单机数据库(mysql)相比，性能有所提高，可以适当选用\",\"4雪花算法，一切问题如果能直接用算法解决，那就是最合适的，利用雪花算法也可以生成分布式ID，底层原理就是通过某台机器在某一毫秒内对某一个数字自增，这种方案也能保证分布式架构中的系统id唯一，但是只能保证趋势递增。业界存在tinyid、leaf等开源中间件实现了雪花算法。\",\"分布式锁的使用场景是什么？有哪些实现方案？\",\"在单体架构中，多个线程都是属于同一个进程的，所以在线程并发执行时，遇到资源竞争时，可以利用ReentrantLock、synchronized等技术来作为锁，来控制共享资源的使用。\",\"而在分布式架构中，多个线程是可能处于不同进程中的，而这些线程并发执行遇到资源竞争时，利用ReentrantLock、synchronized等技术是没办法来控制多个进程中的线程的，所以需要分布式锁，意思就是，需要一个分布式锁生成器，分布式系统中的应用程序都可以来使用这个生成器所提供的锁，从而达到多个进程中的线程使用同一把锁。\",\"目前主流的分布式锁的实现方案有两种：\",\"1zookeeper：利用的是zookeeper的临时节点、顺序节点、watch机制来实现的，zookeeper分布式锁的特点是高一致性，因为zookeeper保证的是CP，所以由它实现的分布式锁更可靠，不会出现混乱\",\"2redis：利用redis的setnx、lua脚本、消费订阅等机制来实现的，redis分布式锁的特点是高可用，因为redis保证的是AP，所以由它实现的分布式锁可能不可靠，不稳定（一旦redis中的数据出现了不一致），可能会出现多个客户端同时加到锁的情况\",\"什么是分布式事务？有哪些实现方案？\",\"在分布式系统中，一次业务处理可能需要多个应用来实现，比如用户发送一次下单请求，就涉及到订单系统创建订单、库存系统减库存，而对于一次下单，订单创建与减库存应该是要同时成功或同时失败的，但在分布式系统中，如果不做处理，就很有可能出现订单创建成功，但是减库存失败，那么解决这类问题，就需要用到分布式事务。常用解决方案有：\",\"1本地消息表：创建订单时，将减库存消息加入在本地事务中，一起提交到数据库存入本地消息表，然后调用库存系统，如果调用成功则修改本地消息状态为成功，如果调用库存系统失败，则由后台定时任务从本地消息表中取出未成功的消息，重试调用库存系统\",\"2消息队列：目前RocketMQ中支持事务消息，它的工作原理是：\",\"a生产者订单系统先发送一条half消息到Broker，half消息对消费者而言是不可见的\",\"b再创建订单，根据创建订单成功与否，向Broker发送commit或rollback\",\"c并且生产者订单系统还可以提供Broker回调接口，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口来查询订单是否创建成功\",\"d一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束\",\"e如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理\",\"3Seata：阿里开源的分布式事务框架，支持AT、TCC等多种模式，底层都是基于两阶段提交理论来实现的\",\"7.CommitorRollBack\",\"accordingtotransactionstatus\",\"i.SendHaIfMsg\",\"3Execute\",\"2.HalfMsg\",\"Local\",\"Commit:SendMsg\",\"SendOK\",\"Lransaction\",\"Local\",\"MQSubscriber\",\"MQServer\",\"MQProducer\",\"Transaction\",\"4.CommitorRollBack\",\"6.CheckthestateofLocal\",\"Transaction\",\"5.Checkback\",\"Whenthefourth'step\",\"RollbackDeleteMsg\",\"confrmationisnotreceived\",\"什么是ZAB协议\",\"ZAB协议是Zookeeper用来实现一致性的原子广播协议，该协议描述了Zookeeper是如何实现一致性的，分为三个阶段：\",\"1领导者选举阶段：从Zookeeper集群中选出一个节点作为Leader，所有的写请求都会由Leader节点来处理\",\"2数据同步阶段：集群中所有节点中的数据要和Leader节点保持一致，如果不一致则要进行同步\",\"3请求广播阶段：当Leader节点接收到写请求时，会利用两阶段提交来广播该写请求，使得写请求像事务一样在其他节点上执行，达到节点上的数据实时一致\",\"但值得注意的是，Zookeeper只是尽量的在达到强一致性，实际上仍然只是最终一致性的。\",\"为什么Zookeeper可以用来作为注册中心\",\"可以利用Zookeeper的临时节点和watch机制来实现注册中心的自动注册和发现，另外Zookeeper中的数据都是存在内存中的，并且Zookeeper底层采用了nio，多线程模型，所以Zookeeper的性能也是比较高的，所以可以用来作为注册中心，但是如果考虑到注册中心应该是注册可用性的话，那么Zookeeper则不太合适，因为Zookeeper是CP的，它注重的是一致性，所以集群数据不一致时，集群将不可用，所以用Redis、Eureka、Nacos来作为注册中心将更合适。\",\"Zookeeper中的领导者选举的流程是怎样的？\",\"对于Zookeeper集群，整个集群需要从集群节点中选出一个节点作为Leader，大体流程如下：\",\"1集群中各个节点首先都是观望状态（LOOKING），一开始都会投票给自己，认为自己比较适合作为leader\",\"2然后相互交互投票，每个节点会收到其他节点发过来的选票，然后pk，先比较zxid，zxid大者获胜，zxid如果相等则比较myid，myid大者获胜\",\"3一个节点收到其他节点发过来的选票，经过PK后，如果PK输了，则改票，此节点就会投给zxid或myid更大的节点，并将选票放入自己的投票箱中，并将新的选票发送给其他节点\",\"4如果pk是平局则将接收到的选票放入自己的投票箱中\",\"5如果pk赢了，则忽略所接收到的选票\",\"6当然一个节点将一张选票放入到自己的投票箱之后，就会从投票箱中统计票数，看是否超过一半的节点都和自己所投的节点是一样的，如果超过半数，那么则认为当前自己所投的节点是leader\",\"7集群中每个节点都会经过同样的流程，pk的规则也是一样的，一旦改票就会告诉给其他服务器，所以最终各个节点中的投票箱中的选票也将是一样的，所以各个节点最终选出来的leader也是一样的，这样集群的leader就选举出来了\",\"Zookeeper集群中节点之间数据是如何同步的\",\"1首先集群启动时，会先进行领导者选举，确定哪个节点是Leader，哪些节点是Follower和Observer\",\"2然后Leader会和其他节点进行数据同步，采用发送快照和发送Diff日志的方式\",\"3集群在工作过程中，所有的写请求都会交给Leader节点来进行处理，从节点只能处理读请求\",\"4Leader节点收到一个写请求时，会通过两阶段机制来处理\",\"5Leader节点会将该写请求对应的日志发送给其他Follower节点，并等待Follower节点持久化日志成功\",\"6Follower节点收到日志后会进行持久化，如果持久化成功则发送一个Ack给Leader节点\",\"7当Leader节点收到半数以上的Ack后，就会开始提交，先更新Leader节点本地的内存数据\",\"8然后发送commit命令给Follower节点，Follower节点收到commit命令后就会更新各自本地内存数据\",\"9同时Leader节点还是将当前写请求直接发送给Observer节点，Observer节点收到Leader发过来的写请求后直接执行更新本地内存数据\",\"10最后Leader节点返回客户端写请求响应成功\",\"11通过同步机制和两阶段提交机制来达到集群中节点数据一致\",\"Dubbo支持哪些负载均衡策略\",\"1随机：从多个服务提供者随机选择一个来处理本次请求，调用量越大则分布越均匀，并支持按权重设置随机概率\",\"2轮询：依次选择服务提供者来处理请求， 并支持按权重进行轮询，底层采用的是平滑加权轮询算法\",\"3最小活跃调用数：统计服务提供者当前正在处理的请求，下次请求过来则交给活跃数最小的服务器来处理\",\"4一致性哈希：相同参数的请求总是发到同一个服务提供者\",\"https://www.yuque.com/renyong-jmovm/ds/gwu187#yGxRv\",\"Dubbo是如何完成服务导出的？\",\"1首先Dubbo会将程序员所使用的@DubboService注解或@Service注解进行解析得到程序员所定义的服务参数，包括定义的服务名、服务接口、服务超时时间、服务协议等等，得到一个ServiceBean。\",\"2然后调用ServiceBean的export方法进行服务导出\",\"3然后将服务信息注册到注册中心，如果有多个协议，多个注册中心，那就将服务按单个协议，单个注册中心进行注册\",\"4将服务信息注册到注册中心后，还会绑定一些监听器，监听动态配置中心的变更\",\"5还会根据服务协议启动对应的Web服务器或网络框架，比如Tomcat、Netty等\",\"Dubbo是如何完成服务引入的？\",\"1当程序员使用@Reference注解来引入一个服务时，Dubbo会将注解和服务的信息解析出来，得到当前所引用的服务名、服务接口是什么\",\"2然后从注册中心进行查询服务信息，得到服务的提供者信息，并存在消费端的服务目录中\",\"3并绑定一些监听器用来监听动态配置中心的变更\",\"4然后根据查询得到的服务提供者信息生成一个服务接口的代理对象，并放入Spring容器中作为Bean\",\"Dubbo的架构设计是怎样的？\",\"Dubbo中的架构设计是非常优秀的，分为了很多层次，并且每层都是可以扩展的，比如：\",\"1Proxy服务代理层，支持JDK动态代理、javassist等代理机制\",\"2Registry注册中心层，支持Zookeeper、Redis等作为注册中心\",\"3Protocol远程调用层，支持Dubbo、Http等调用协议\",\"4Transport网络传输层，支持netty、mina等网络传输框架\",\"5Serialize数据序列化层，支持JSON、Hessian等序列化机制\",\"各层说明\",\"●config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类\",\"●proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory\",\"●registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService\",\"●cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance\",\"●monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService\",\"●protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter\",\"●exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer\",\"●transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec\",\"●serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool\",\"关系说明\",\"●在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。\",\"●图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。\",\"●而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。\",\"●Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。\",\"●而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。\",\"●Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。\",\"Spring Cloud有哪些常用组件，作用是什么？\",\"1Eureka：注册中心\",\"2Nacos：注册中心、配置中心\",\"3Consul：注册中心、配置中心\",\"4Spring Cloud Config：配置中心\",\"5Feign/OpenFeign：RPC调用\",\"6Kong：服务网关\",\"7Zuul：服务网关\",\"8Spring Cloud Gateway：服务网关\",\"9Ribbon：负载均衡\",\"10Spring CLoud Sleuth：链路追踪\",\"11Zipkin：链路追踪\",\"12Seata：分布式事务\",\"13Dubbo：RPC调用\",\"14Sentinel：服务熔断\",\"15Hystrix：服务熔断\",\"Spring Cloud和Dubbo有哪些区别？\",\"Spring Cloud是一个微服务框架，提供了微服务领域中的很多功能组件，Dubbo一开始是一个RPC调用框架，核心是解决服务调用间的问题，Spring Cloud是一个大而全的框架，Dubbo则更侧重于服务调用，所以Dubbo所提供的功能没有Spring Cloud全面，但是Dubbo的服务调用性能比Spring Cloud高，不过Spring Cloud和Dubbo并不是对立的，是可以结合起来一起使用的。\",\"什么是服务雪崩？什么是服务限流？\",\"1当服务A调用服务B，服务B调用C，此时大量请求突然请求服务A，假如服务A本身能抗住这些请求，但是如果服务C抗不住，导致服务C请求堆积，从而服务B请求堆积，从而服务A不可用，这就是服务雪崩，解决方式就是服务降级和服务熔断。\",\"2服务限流是指在高并发请求下，为了保护系统，可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求压垮，在秒杀中，限流是非常重要的。\",\"a固定窗口（计数器）算法\",\"b滑动窗口算法\",\"c令牌桶算法\",\"d漏桶算法\",\"什么是服务熔断？什么是服务降级？区别是什么？\",\"1服务熔断是指，当服务A调用的某个服务B不可用时，上游服务A为了保证自己不受影响，从而不再调用服务B，直接返回一个结果，减轻服务A和服务B的压力，直到服务B恢复。\",\"2服务降级是指，当发现系统压力过载时，可以通过关闭某个服务，或限流某个服务来减轻系统压力，这就是服务降级。\",\"相同点：\",\"1都是为了防止系统崩溃\",\"2都让用户体验到某些功能暂时不可用\",\"不同点：熔断是下游服务故障触发的，降级是为了降低系统负载\",\"SOA、分布式、微服务之间有什么关系和区别？\",\"1分布式架构是指将单体架构中的各个部分拆分，然后部署不同的机器或进程中去，SOA和微服务基本上都是分布式架构的\",\"2SOA是一种面向服务的架构，系统的所有服务都注册在总线上，当调用服务时，从总线上查找服务信息，然后调用\",\"3微服务是一种更彻底的面向服务的架构，将系统中各个功能个体抽成一个个小的应用程序，基本保持一个应用对应的一个服务的架构\",\"BIO、NIO、AIO分别是什么\",\"1BIO：同步阻塞IO，使用BIO读取数据时，线程会阻塞住，并且需要线程主动去查询是否有数据可读，并且需要处理完一个Socket之后才能处理下一个Socket\",\"2NIO：同步非阻塞IO，使用NIO读取数据时，线程不会阻塞，但需要线程主动的去查询是否有IO事件\",\"3AIO：也叫做NIO 2.0，异步非阻塞IO，使用AIO读取数据时，线程不会阻塞，并且当有数据可读时会通知给线程，不需要线程主动去查询\",\"零拷贝是什么\",\"零拷贝指的是，应用程序在需要把内核中的一块区域数据转移到另外一块内核区域去时，不需要经过先复制到用户空间，再转移到目标内核区域去了，而直接实现转移。\",\"​\",\"Netty是什么？和Tomcat有什么区别？特点是什么？\",\"Netty是一个基于NIO的异步网络通信框架，性能高，封装了原生NIO编码的复杂度，开发者可以直接使用Netty来开发高效率的各种网络服务器，并且编码简单。\",\"Tomcat是一个Web服务器，是一个Servlet容器，基本上Tomcat内部只会运行Servlet程序，并处理HTTP请求，而Netty封装的是底层IO模型，关注的是网络数据的传输，而不关心具体的协议，可定制性更高。\",\"Netty的特点：\",\"1异步、NIO的网络通信框架\",\"2高性能\",\"3高扩展，高定制性\",\"4易用性\",\"Netty的线程模型是怎么样的\",\"Netty同时支持Reactor单线程模型 、Reactor多线程模型和Reactor主从多线程模型，用户可根据启动参数配置在这三种模型之间切换。\",\"client\",\"mainReactor\",\"subReactor\",\"client\",\"send\",\"read\",\"send\",\"reade\",\"acceptor\",\"client\",\"sende\",\"read\",\"computeencode\",\"decode\",\"Thread\",\"worker\",\"threads\",\"Pool\",\"encode\",\"decode\",\"compute\",\"encode\",\"decodecompute\",\"queuedtasks\",\"服务端启动时，通常会创建两个NioEventLoopGroup实例，对应了两个独立的Reactor线程池，bossGroup负责处理客户端的连接请求，workerGroup负责处理I/O相关的操作，执行系统Task、定时任务Task等。用户可根据服务端引导类ServerBootstrap配置参数选择Reactor线程模型，进而最大限度地满足用户的定制化需求。\",\"Netty的高性能体现在哪些方面\",\"1NIO模型，用最少的资源做更多的事情。\",\"2内存零拷贝，尽量减少不必要的内存拷贝，实现了更高效率的传输。\",\"3内存池设计，申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。\",\"4串行化处理读写 ：避免使用锁带来的性能开销。即消息的处理尽可能再同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队里-多个工作线程模型性能更优。\",\"5高性能序列化协议 ：支持protobuf等高性能序列化协议。\",\"6高效并发编程的体现 ：volatile的大量、正确使用；CAS和原子类的广泛使用；线程安全容器的使用；通过读写锁提升并发性能。\",\"Redis有哪些数据结构？分别有哪些典型的应用场景？\",\"Redis的数据结构有：\",\"1字符串：可以用来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利用了这种数据结构，还包括可以实现计数器、分布式ID\",\"2哈希表：可以用来存储一些key-value对，更适合用来存储对象\",\"3列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据\",\"4集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现类似，我和某人共同关注的人、朋友圈点赞等功能\",\"5有序集合：集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能\",\"Redis分布式锁底层是如何实现的？\",\"1首先利用setnx来保证：如果key不存在才能获取到锁，如果key存在，则获取不到锁\",\"2然后还要利用lua脚本来保证多个redis操作的原子性\",\"3同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约\",\"4同时还要考虑到redis节点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到\",\"Redis主从复制的核心原理\",\"全量同步：\",\"1一般发生在从节点初始化的时候\",\"2从节点发送SYNC命令连接主节点\",\"3主节点接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件，并使用缓冲区replication buffer记录在这个过程中接收到的写命令\",\"4主节点BGSAVE命令执行完后，向所有从节点发送RDB文件，并在发送缓冲区replication buffer记录的写命令\",\"5从节点收到RDB文件后丢弃所有旧数据，载入收到的RDB文件中的数据\",\"6主节点RDB文件发送完毕后，开始向从节点发送缓冲区replication buffer中的写命令\",\"7从节点完成RDB的载入后，开始接收客户端命令，并执行来自主节点缓冲区replication buffer的写命令\",\"增量同步：\",\"Redis主节点每执行一个写命令就会向从节点异步发送相同的写命令，从节点接收并执行收到的写命令\",\"缓存穿透、缓存击穿、缓存雪崩分别是什么\",\"缓存中存放的大多都是热点数据，目的就是防止请求可以直接从缓存中获取到数据，而不用访问Mysql。\",\"1缓存雪崩：如果缓存中某一时刻大批热点数据同时过期，那么就可能导致大量请求直接访问Mysql了，解决办法就是在过期时间上增加一点随机值，另外如果搭建一个高可用的Redis集群也是防止缓存雪崩的有效手段\",\"2缓存击穿：和缓存雪崩类似，缓存雪崩是大批热点数据失效，而缓存击穿是指某一个热点key突然失效，也导致了大量请求直接访问Mysql数据库，这就是缓存击穿，解决方案就是考虑这个热点key不设过期时间\",\"3缓存穿透：假如某一时刻访问redis的大量key都在redis中不存在（比如黑客故意伪造一些乱七八糟的key），那么也会给数据造成压力，这就是缓存穿透，解决方案是使用布隆过滤器，它的作用就是如果它认为一个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加一层布隆过滤器来拦截不存在的key\",\"Redis和Mysql如何保证数据一致\",\"1先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不一致\",\"2先删除Redis缓存数据，再更新Mysql，再次查询的时候在将数据添加到缓存中，这种方案能解决1方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了Redis缓存数据，正在更新Mysql，此时另外一个查询再查询，那么就会把Mysql中老数据又查到Redis中\",\"3延时双删，步骤是：先删除Redis缓存数据，再更新Mysql，延迟几百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，有其他线程读了Mysql，把老数据读到了Redis中，那么也会被删除掉，从而把数据保持一致\",\"Explain语句结果中各个字段分表表示什么\",\"列名\",\"描述\",\"id\",\"查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id值，某些子查询会被优化为join查询，那么出现的id会一样\",\"select_type\",\"SELECT关键字对应的那个查询的类型\",\"table\",\"表名\",\"partitions\",\"匹配的分区信息\",\"type\",\"针对单表的查询方式（全表扫描、索引）\",\"possible_keys\",\"可能用到的索引\",\"key\",\"实际上使用的索引\",\"key_len\",\"实际使用到的索引长度\",\"ref\",\"当使用索引列等值查询时，与索引列进行等值匹配的对象信息\",\"rows\",\"预估的需要读取的记录条数\",\"filtered\",\"某个表经过搜索条件过滤后剩余记录条数的百分比\",\"Extra\",\"一些额外的信息，比如排序等\",\"索引覆盖是什么\",\"索引覆盖就是一个SQL在执行时，可以利用索引来快速查找，并且此SQL所要查询的字段在当前索引对应的字段中都包含了，那么就表示此SQL走完索引后不用回表了，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回了\",\"最左前缀原则是什么\",\"当一个SQL想要利用索引是，就一定要提供该索引所对应的字段中最左边的字段，也就是排在最前面的字段，比如针对a,b,c三个字段建立了一个联合索引，那么在写一个sql时就一定要提供a字段的条件，这样才能用到联合索引，这是由于在建立a,b,c三个字段的联合索引时，底层的B+树是按照a,b,c三个字段从左往右去比较大小进行排序的，所以如果想要利用B+树进行快速查找也得符合这个规则\",\"Innodb是如何实现事务的\",\"Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以一个update语句为例：\",\"1Innodb在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool中\",\"2执行update语句，修改Buffer Pool中的数据，也就是内存中的数据\",\"3针对update语句生成一个RedoLog对象，并存入LogBuffer中\",\"4针对update语句生成undolog日志，用于事务回滚\",\"5如果事务提交，那么则把RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中\",\"6如果事务回滚，则利用undolog日志进行回滚\",\"B树和B+树的区别，为什么Mysql使用B+树\",\"B树的特点：\",\"1节点排序\",\"2一个节点了可以存多个元素，多个元素也排序了\",\"B+树的特点：\",\"1拥有B树的特点\",\"2叶子节点之间有指针\",\"3非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序\",\"Mysql索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高，在Mysql中一个Innodb页就是一个B+树节点，一个Innodb页默认16kb，所以一般情况下一颗两层的B+树可以存2000万行左右的数据，然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。\",\"Mysql锁有哪些，如何理解\",\"按锁粒度分类：\",\"1行锁：锁某行数据，锁粒度最小，并发度高\",\"2表锁：锁整张表，锁粒度最大，并发度低\",\"3间隙锁：锁的是一个区间\",\"还可以分为：\",\"1共享锁：也就是读锁，一个事务给某行数据加了读锁，其他事务也可以读，但是不能写\",\"2排它锁：也就是写锁，一个事务给某行数据加了写锁，其他事务不能读，也不能写\",\"还可以分为：\",\"1乐观锁：并不会真正的去锁某行记录，而是通过一个版本号来实现的\",\"2悲观锁：上面所的行锁、表锁等都是悲观锁\",\"在事务的隔离级别实现中，就需要利用锁来解决幻读\",\"作者：图灵课堂-------周瑜\",\"InnoDB中的B+树的高度该如何计算\",\"3\",\"页地\",\"页地\",\"页地\",\"页地\",\"址\",\"址\",\"址\",\"址\",\"5235E\",\"7455G\",\"3322C\",\"1111A\",\"4311D\",\"6644F\",\"2222B\",\"8888H\",\"InnoDB中主键索引对应的B+树：\",\"1叶子节点存储的是完整的一条条的行数据\",\"2非叶子节点存储的是主键和页地址\",\"假设一行数据为1kb，主键为bigint（一个主键占8b），由于Innodb中一页为16kb，一页就是B+树中的一个节点，那也就是B+树中的一个节点能存储16条数据（16kb/1kb），或者一个节点能存储主键：页地址对为16kb/(8b+6b)=1170对，每对对应一个数据页，所以两层高的B+树能存储的数据条数为1170*16=18724条\",\"页地\",\"页地\",\"址\",\"址\",\"页地\",\"页地\",\"页地\",\"页地\",\"址\",\"址\",\"址\",\"址\",\"5235E\",\"7455G\",\"3322C\",\"111A\",\"8888H\",\"2222B\",\"4311D\",\"6644F\",\"如果是三层高的B+树，那就是1170117016=21,907,748条，也就是2000万条左右。\",\"根据这个例子，我们可以结合实际请求，算出两层和三层时能存储的数据条数，然后看目前表里有多少条数据，从而知道B+数的高度是多少。\",\"Mysql慢查询该如何优化？\",\"1检查是否走了索引，如果没有则优化SQL利用索引\",\"2检查所利用的索引，是否是最优索引\",\"3检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据\",\"4检查表中数据是否过多，是否应该进行分库分表了\",\"5检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源\",\"消息队列有哪些作用\",\"1解耦：使用消息队列来作为两个系统之间的通讯方式，两个系统不需要相互依赖了\",\"2异步：系统A给消息队列发送完消息之后，就可以继续做其他事情了\",\"3流量削峰：如果使用消息队列的方式来调用某个系统，那么消息将在队列中排队，由消费者自己控制消费速度\",\"死信队列是什么？延时队列是什么？\",\"1死信队列也是一个消息队列，它是用来存放那些没有成功消费的消息的，通常可以用来作为消息重试\",\"2延时队列就是用来存放需要在指定时间被处理的元素的队列，通常可以用来处理一些具有过期性操作的业务，比如十分钟内未支付则取消订单\",\"Kafka为什么吞吐量高\",\"Kafka的生产者采用的是异步发送消息机制，当发送一条消息时，消息并没有发送到Broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送给Broker。这种做法减少了网络io，从而提高了消息发送的吞吐量，但是如果消息生产者宕机，会导致消息丢失，业务出错，所以理论上kafka利用此机制提高了性能却降低了可靠性。\",\"Kafka的Pull和Push分别有什么优缺点\",\"1pull表示消费者主动拉取，可以批量拉取，也可以单条拉取，所以pull可以由消费者自己控制，根据自己的消息处理能力来进行控制，但是消费者不能及时知道是否有消息，可能会拉到的消息为空\",\"2push表示Broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按自己的能力来消费消息，推过来多少消息，消费者就得消费多少消息，所以可能会造成网络堵塞，消费者压力大等问题\",\"RocketMQ的事务消息是如何实现的\",\"7.CommitorRollBack\",\"accordingtotransactionstatus\",\"i.SendHaIfMsg\",\"3Execute\",\"2.HalfMsg\",\"Local\",\"Commit:SendMsg\",\"SendOK\",\"Lransaction\",\"Local\",\"MQSubscriber\",\"MQServer\",\"MQProducer\",\"Transaction\",\"4.CommitorRollBack\",\"6.CheckthestateofLocal\",\"Transaction\",\"5.Checkback\",\"Whenthefourth'step\",\"RollbackDeleteMsg\",\"confrmationisnotreceived\",\"a生产者订单系统先发送一条half消息到Broker，half消息对消费者而言是不可见的\",\"b再创建订单，根据创建订单成功与否，向Broker发送commit或rollback\",\"c并且生产者订单系统还可以提供Broker回调接口，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口来查询订单是否创建成功\",\"d一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束\",\"e如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理\",\"消息队列如何保证消息可靠传输\",\"消息可靠传输代表了两层意思，既不能多也不能少。\",\"1为了保证消息不多，也就是消息不能重复，也就是生产者不能重复生产消息，或者消费者不能重复消费消息\",\"2首先要确保消息不多发，这个不常出现，也比较难控制，因为如果出现了多发，很大的原因是生产者自己的原因，如果要避免出现问题，就需要在消费端做控制\",\"3要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通过幂等性，也能解决生产者重复发送消息的问题\",\"4消息不能少，意思就是消息不能丢失，生产者发送的消息，消费者一定要能消费到，对于这个问题，就要考虑两个方面\",\"5生产者发送消息时，要确认broker确实收到并持久化了这条消息，比如RabbitMQ的confirm机制，Kafka的ack机制都可以保证生产者能正确的将消息发送给broker\",\"6broker要等待消费者真正确认消费到了消息时才删除掉消息，这里通常就是消费端ack机制，消费者接收到一条消息后，如果确认没问题了，就可以给broker发送一个ack，broker接收到ack后才会删除消息\",\"TCP的三次握手和四次挥手\",\"TCP协议是7层网络协议中的传输层协议，负责数据的可靠传输。\",\"在建立TCP连接时，需要通过三次握手来建立，过程是：\",\"1客户端向服务端发送一个SYN\",\"2服务端接收到SYN后，给客户端发送一个SYN_ACK\",\"3客户端接收到SYN_ACK后，再给服务端发送一个ACK\",\"在断开TCP连接时，需要通过四次挥手来断开，过程是：\",\"1客户端向服务端发送FIN\",\"2服务端接收FIN后，向客户端发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了，不过服务端这边可能还有数据正在处理\",\"3服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接\",\"4客户端收到服务端的FIN，向服务端发送ACK，表示客户端也会断开连接了\"]},\"217\":{\"h\":\"Docker详解与部署微服务实战\",\"t\":[\"2013年发布至今， Docker 一直广受瞩目，被认为可能会改变软件行业。\",\"但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？今天就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。\",\"​ \",\"Docker简介\",\"Docker是一个开源的容器引擎，它有助于更快地交付应用。 Docker可将应用程序和基础设施层隔离，并且能将基础设施当作程序一样进行管理。使用 Docker可更快地打包、测试以及部署应用程序，并可以缩短从编写到部署运行代码的周期。\",\"Docker的优点如下：\",\"1、简化程序\",\"Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。\",\"2、避免选择恐惧症\",\"如果你有选择恐惧症，还是资深患者。Docker 帮你 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。\",\"3、节省开支\",\"一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。\",\"Docker的架构\",\"​ \",\"Docker daemon（ Docker守护进程）\",\"Docker daemon是一个运行在宿主机（ DOCKER-HOST）的后台进程。可通过 Docker客户端与之通信。\",\"Client（ Docker客户端）\",\"Docker客户端是 Docker的用户界面，它可以接受用户命令和配置标识，并与 Docker daemon通信。图中， docker build等都是 Docker的相关命令。\",\"Images（ Docker镜像）\",\"Docker镜像是一个只读模板，它包含创建 Docker容器的说明。它和系统安装光盘有点像，使用系统安装光盘可以安装系统，同理，使用Docker镜像可以运行 Docker镜像中的程序。\",\"Container（容器）\",\"容器是镜像的可运行实例。镜像和容器的关系有点类似于面向对象中，类和对象的关系。可通过 Docker API或者 CLI命令来启停、移动、删除容器。\",\"Registry\",\"Docker Registry是一个集中存储与分发镜像的服务。构建完 Docker镜像后，就可在当前宿主机上运行。但如果想要在其他机器上运行这个镜像，就需要手动复制。此时可借助 Docker Registry来避免镜像的手动复制。\",\"一个 Docker Registry可包含多个 Docker仓库，每个仓库可包含多个镜像标签，每个标签对应一个 Docker镜像。这跟 Maven的仓库有点类似，如果把 Docker Registry比作 Maven仓库的话，那么 Docker仓库就可理解为某jar包的路径，而镜像标签则可理解为jar包的版本号。\",\"Docker Registry可分为公有Docker Registry和私有Docker Registry。 最常⽤的Docker Registry莫过于官⽅的Docker Hub， 这也是默认的Docker Registry。 Docker Hub上存放着⼤量优秀的镜像， 我们可使⽤Docker命令下载并使⽤。\",\"Docker 的安装\",\"Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。\",\"Docker CE 的安装请参考官方文档，我们这里以CentOS为例：\",\"1、Docker 要求 CentOS 系统的内核版本高于 3.10\",\"通过 uname -r 命令查看你当前的内核版本\",\"uname -r \",\"2、使用 root 权限登录 Centos。确保 yum 包更新到最新。\",\"yum -y update \",\"3、卸载旧版本(如果安装过旧版本的话)\",\"sudo yum remove -y docker* \",\"4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\",\"yum install -y yum-utils \",\"5、设置yum源，并更新 yum 的包索引\",\"yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum makecache fast \",\"​ \",\"6、可以查看所有仓库中所有docker版本，并选择特定版本安装\",\"yum list docker-ce --showduplicates | sort -r \",\"​ \",\"7、安装docker\",\" yum install -y docker-ce-3:19.03.9-3.el7.x86_64 # 这是指定版本安装 \",\"8、启动并加入开机启动\",\"systemctl start docker && systemctl enable docker \",\"9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)\",\"docker version \",\"​ \",\"注意：一般需要配置docker镜像加速器\",\"我们可以借助阿里云的镜像加速器，登录阿里云(https://cr.console.aliyun.com/#/accelerator)\",\"可以看到镜像加速地址如下图：\",\"​ \",\"cd /etc/docker \",\"查看有没有 daemon.json。这是docker默认的配置文件。\",\"如果没有新建，如果有，则修改。\",\"vim daemon.json { \\\"registry-mirrors\\\": [\\\"https://m9r2r2uj.mirror.aliyuncs.com\\\"] } \",\"保存退出。\",\"重启docker服务\",\"systemctl daemon-reload systemctl restart docker \",\"成功！\",\"10、卸载docker\",\"yum remove -y docker* rm -rf /etc/systemd/system/docker.service.d rm -rf /var/lib/docker rm -rf /var/run/docker \",\"Docker常用命令\",\"镜像相关命令\",\"1、搜索镜像\",\"可使用 docker search命令搜索存放在 Docker Hub中的镜像。执行该命令后， Docker就会在Docker Hub中搜索含有 java这个关键词的镜像仓库。\",\"docker search java \",\"以上列表包含五列，含义如下：\",\"- NAME:镜像仓库名称。\",\"- DESCRIPTION:镜像仓库描述。\",\"- STARS：镜像仓库收藏数，表示该镜像仓库的受欢迎程度，类似于 GitHub的 stars0\",\"- OFFICAL:表示是否为官方仓库，该列标记为[0K]的镜像均由各软件的官方项目组创建和维护。\",\"- AUTOMATED：表示是否是自动构建的镜像仓库。\",\"2、下载镜像\",\"使用命令docker pull命令即可从 Docker Registry上下载镜像，执行该命令后，Docker会从 Docker Hub中的 java仓库下载最新版本的 Java镜像。如果要下载指定版本则在java后面加冒号指定版本，例如：docker pull java:8\",\" docker pull java:8 \",\"​ \",\" docker pull nginx \",\"​ \",\"3、列出镜像\",\"使用 docker images命令即可列出已下载的镜像\",\"docker images \",\"​ \",\"以上列表含义如下\",\"- REPOSITORY：镜像所属仓库名称。\",\"- TAG:镜像标签。默认是 latest,表示最新。\",\"- IMAGE ID：镜像 ID，表示镜像唯一标识。\",\"- CREATED：镜像创建时间。\",\"- SIZE: 镜像大小。\",\"4、删除本地镜像\",\"使用 docker rmi命令即可删除指定镜像，强制删除加 -f\",\" docker rmi java \",\"删除所有镜像\",\"docker rmi $(docker images -q) \",\"容器相关命令\",\"1、新建并启动容器\",\"使用以下docker run命令即可新建并启动一个容器，该命令是最常用的命令，它有很多选项，下面将列举一些常用的选项。\",\"-d选项：表示后台运行\",\"-P选项：随机端口映射\",\"-p选项：指定端口映射，有以下四种格式。\",\"-- ip:hostPort:containerPort\",\"-- ip::containerPort\",\"-- hostPort:containerPort\",\"-- containerPort\",\"--net选项：指定网络模式，该选项有以下可选参数：\",\"--net=bridge:默认选项，表示连接到默认的网桥。\",\"--net=host:容器使用宿主机的网络。\",\"--net=container:NAME-or-ID：告诉 Docker让新建的容器使用已有容器的网络配置。\",\"--net=none：不配置该容器的网络，用户可自定义网络配置。\",\" docker run -d -p 91:80 nginx \",\"这样就能启动一个 Nginx容器。在本例中，为 docker run添加了两个参数，含义如下：\",\"-d 后台运行\",\"-p 宿主机端口:容器端口 #开放容器端口到宿主机端口\",\"访问 http://Docker宿主机 IP:91/，将会看到nginx的主界面如下：\",\"需要注意的是，使用 docker run命令创建容器时，会先检查本地是否存在指定镜像。如果本地不存在该名称的镜像， Docker就会自动从 Docker Hub下载镜像并启动一个 Docker容器。\",\"2、列出容器\",\"用 docker ps命令即可列出运行中的容器\",\"docker ps \",\"如需列出所有容器（包括已停止的容器），可使用-a参数。该列表包含了7列，含义如下\",\"- CONTAINER_ID：表示容器 ID。\",\"- IMAGE:表示镜像名称。\",\"- COMMAND：表示启动容器时运行的命令。\",\"- CREATED：表示容器的创建时间。\",\"- STATUS：表示容器运行的状态。UP表示运行中， Exited表示已停止。\",\"- PORTS:表示容器对外的端口号。\",\"- NAMES:表示容器名称。该名称默认由 Docker自动生成，也可使用 docker run命令的--name选项自行指定。\",\"3、停止容器\",\"使用 docker stop命令，即可停止容器\",\" docker stop f0b1c8ab3633 \",\"其中f0b1c8ab3633是容器 ID,当然也可使用 docker stop容器名称来停止指定容器\",\"4、强制停止容器\",\"可使用 docker kill命令发送 SIGKILL信号来强制停止容器\",\"docker kill f0b1c8ab3633 \",\"5、启动已停止的容器\",\"使用docker run命令，即可新建并启动一个容器。对于已停止的容器，可使用 docker start命令来启动\",\"docker start f0b1c8ab3633 \",\"6、查看容器所有信息\",\"docker inspect f0b1c8ab3633 \",\"7、查看容器日志\",\"docker container logs f0b1c8ab3633 \",\"8、查看容器里的进程\",\"docker top f0b1c8ab3633 \",\"9、容器与宿主机相互复制文件\",\"从容器里面拷文件到宿主机：\",\"docker cp 容器id:要拷贝的文件在容器里面的路径 宿主机的相应路径 如：docker cp 7aa5dc458f9d:/etc/nginx/nginx.conf /mydata/nginx \",\"从宿主机拷文件到容器里面：\",\"docker cp 要拷贝的宿主机文件路径 容器id:要拷贝到容器里面对应的路径\",\"10、进入容器\",\"使用docker exec命令用于进入一个正在运行的docker容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了\",\"docker exec -it f0b1c8ab3633 /bin/bash (有的容器需要把 /bin/bash 换成 sh) \",\"11、容器内安装vim、ping、ifconfig等指令\",\"apt-get update apt-get install vim #安装vim apt-get install iputils-ping #安装ping apt-get install net-tools #安装ifconfig \",\"12、删除容器\",\"使用 docker rm命令即可删除指定容器\",\"docker rm f0b1c8ab3633 \",\"该命令只能删除已停止的容器，如需删除正在运行的容器，可使用-f参数\",\"强制删除所有容器\",\"docker rm -f $(docker ps -a -q) \"]},\"218\":{\"h\":\"将微服务运行在docker上\",\"t\":[\"使用Dockerfile构建Docker镜像\",\"Dockerfile是一个文本文件，其中包含了若干条指令，指令描述了构建镜像的细节\",\"先来编写一个最简单的Dockerfile，以前文下载的Nginx镜像为例，来编写一个Dockerfile修改该Nginx镜像的首页\",\"1、新建一个空文件夹docker-demo，在里面再新建文件夹app，在app目录下新建一个名为Dockerfile的文件，在里面增加如下内容：\",\"FROM nginx RUN echo '<h1>This is Tuling Nginx!!!</h1>' > /usr/share/nginx/html/index.html \",\"该Dockerfile非常简单，其中的 FROM、 RUN都是 Dockerfile的指令。 FROM指令用于指定基础镜像， RUN指令用于执行命令。\",\"2、在Dockerfile所在路径执行以下命令构建镜像：\",\"docker build -t nginx:tuling . \",\"其中，-t指定镜像名字，命令最后的点（.）表示Dockerfile文件所在路径\",\"3、执行以下命令，即可使用该镜像启动一个 Docker容器\",\"docker run -d -p 92:80 nginx:tuling \",\"4、访问 http://Docker宿主机IP:92/，可看到下图所示界面\",\"​ \",\"Dockerfile常用指令\",\"命令\",\"用途\",\"FROM\",\"基础镜像文件\",\"RUN\",\"构建镜像阶段执行命令\",\"ADD\",\"添加文件，从src目录复制文件到容器的dest，其中 src可以是 Dockerfile所在目录的相对路径，也可以是一个 URL,还可以是一个压缩包\",\"COPY\",\"拷贝文件，和ADD命令类似，但不支持URL和压缩包\",\"CMD\",\"容器启动后执行命令\",\"EXPOSE\",\"声明容器在运行时对外提供的服务端口\",\"WORKDIR\",\"指定容器工作路径\",\"ENV\",\"指定环境变量\",\"ENTRYPINT\",\"容器入口， ENTRYPOINT和 CMD指令的目的一样，都是指定 Docker容器启动时执行的命令，可多次设置，但只有最后一个有效。\",\"USER\",\"该指令用于设置启动镜像时的用户或者 UID,写在该指令后的 RUN、 CMD以及 ENTRYPOINT指令都将使用该用户执行命令。\",\"VOLUME\",\"指定挂载点，该指令使容器中的一个目录具有持久化存储的功能，该目录可被容器本身使用，也可共享给其他容器。当容器中的应用有持久化数据的需求时可以在 Dockerfile中使用该指令。格式为： VOLUME[\\\"/data\\\"]。\",\"注意：RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。\",\"注意，指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。\",\"使用Dockerfile构建微服务镜像\",\"以项目05-ms-eureka-server为例，将该微服务的可运行jar包构建成docker镜像\",\"1、将jar包上传linux服务器/usr/local/docker-app/docker-demo/app/eureka目录，在jar包所在目录创建名为Dockerfile的文件\",\"2、在Dockerfile中添加以下内容\",\"# 基于哪个镜像 From java:8 # 复制文件到容器 ADD microservice-eureka-server-0.0.1-SNAPSHOT.jar /app.jar # 声明需要暴露的端口 EXPOSE 8761 # 配置容器启动后执行的命令 ENTRYPOINT java ${JAVA_OPTS} -jar /app.jar \",\"3、使用docker build命令构建镜像\",\"docker build -t microservice-eureka-server:0.0.1 . \",\"# 格式： docker build -t 镜像名称:标签 Dockerfile的相对位置\",\"在这里，使用-t选项指定了镜像的标签。执行该命令后，终端将会输出如下的内容\",\"4、启动镜像，加-d可在后台启动\",\" docker run -d -p 8761:8761 microservice-eureka-server:0.0.1 \",\"使用 -v 可以挂载一个主机上的目录到容器的目录\",\"docker run -d -p 8761:8761 -v /log:/container-log microservice-eureka-server:0.0.1 \",\"加上JVM参数：\",\"# --cap-add=SYS_PTRACE 这个参数是让docker能支持在容器里能执行jdk自带类似jinfo，jmap这些命令，如果不需要在容器里执行这些命令可以不加 docker run -e JAVA_OPTS='-Xms1028M -Xmx1028M -Xmn512M -Xss512K -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M' --cap-add=SYS_PTRACE -d -p 8761:8761 microservice-eureka-server:0.0.1 \",\"5、访问http://Docker宿主机IP:8761/，可正常显示Eureka Server首页\",\"将微服务镜像发布到远程镜像仓库\",\"我们制作好了微服务镜像，一般需要发布到镜像仓库供别人使用，我们可以选择自建镜像仓库，也可以直接使用docker官方镜像仓库，这里我们选择docker官方镜像仓库：https://hub.docker.com/\",\"首先，我们需要在docke官方镜像仓库里注册一个账号\",\"然后，在linux服务器上用docker login命令登录镜像仓库\",\"要把镜像推送到镜像仓库，需要将镜像前面加个分组名(一般就是docker hub的账户名)，执行如下命令修改镜像名字\",\"docker tag microservice-eureka-server:0.0.1 zhuge666/microservice-eureka-server:0.0.1 \",\"最后将镜像推送到远程仓库\",\"docker push zhuge666/microservice-eureka-server:0.0.1 \",\"我们登录到docker镜像查看下刚刚推送的镜像，这样镜像就能给别人用了\",\"Docker虚拟化原理\",\"传统虚拟化和容器技术结构比较：传统虚拟化技术是在硬件层面实现虚拟化，增加了系统调用链路的环节，有性能损耗；容器虚拟化技术以共享宿主机Kernel的方式实现，几乎没有性能损耗。\",\"docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。避免了寻址、加载操作系统内核这些比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,这个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了这个过程,因此新建一个docker容器只需要几秒钟。\",\"​ \",\"Docker是如何将机器的资源进行隔离的？\",\"答案是联合文件系统，常见的有AUFS、Overlay、devicemapper、BTRFS和ZFS等。\",\"以Overlay2举例说明，Overlay2的架构图如下：\",\"原理：overlayfs在linux主机上只有两层，一个目录在下层，用来保存镜像(docker)，另外一个目录在上层，用来存储容器信息。在overlayfs中，底层的目录叫做lowerdir，顶层的目录称之为upperdir，对外提供统一的文件系统为merged。当需要修改一个文件时，使用**COW(Copy-on-write)**将文件从只读的Lower复制到可写的Upper进行修改，结果也保存在Upper层。在Docker中，底下的只读层就是image，可写层就是Container。\",\"写时复制 (CoW) 技术详解\",\"所有驱动都用到的技术—写时复制，Cow全称copy-on-write，表示只是在需要写时才去复制，这个是针对已有文件的修改场景。比如基于一个image启动多个Container，如果每个Container都去分配一个image一样的文件系统，那么将会占用大量的磁盘空间。而CoW技术可以让所有的容器共享image的文件系统，所有数据都从image中读取，只有当要对文件进行写操作时，才从image里把要写的文件复制到自己的文件系统进行修改。所以无论有多少个容器共享一个image，所做的写操作都是对从image中复制到自己的文件系统的副本上进行，并不会修改image的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个副本，每个容器修改的都是自己的副本，互相隔离，互不影响。使用CoW可以有效的提高磁盘的利用率。所以容器占用的空间是很少的。\",\"查看容器占用磁盘大小指令：\",\"# 查看所有容器的大小 cd /var/lib/docker/containers # 进入docker容器存储目录 du -sh * # 查看所有容器的大小 du -sh <容器完整id> #查看某一个容器的大小 \",\"用时分配 （allocate-on-demand）\",\"用时分配是针对原本没有这个文件的场景，只有在要新写入一个文件时才分配空间，这样可以提高存储资源的利用率。比如启动一个容器，并不会因为这个容器分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间。\",\"docker中的镜像分层技术的原理是什么呢？\",\"docker使用共享技术减少镜像存储空间，所有镜像层和容器层都保存在宿主机的文件系统/var/lib/docker/中，由存储驱动进行管理，尽管存储方式不尽相同，但在所有版本的Docker中都可以共享镜像层。在下载镜像时，Docker Daemon会检查镜像中的镜像层与宿主机文件系统中的镜像层进行对比，如果存在则不下载，只下载不存在的镜像层，这样可以非常节约存储空间。 \",\"​ \",\"最后附一个查看容器资源使用情况的指令：\",\"docker stats # 返回容器资源的实时使用情况，1秒刷新一次 docker stats --no-stream # 返回容器当时的资源使用情况 \",\"默认情况下，stats 命令会每隔 1 秒钟刷新一次输出的内容直到你按下 ctrl + c。下面是输出的主要内容：\",\"[CONTAINER]：以短格式显示容器的 ID。\",\"[CPU %]：CPU 的使用情况。\",\"[MEM USAGE / LIMIT]：当前使用的内存和最大可以使用的内存。\",\"[MEM %]：以百分比的形式显示内存使用情况。\",\"[NET I/O]：网络 I/O 数据。\",\"[BLOCK I/O]：磁盘 I/O 数据。\",\"[PIDS]：PID 号。\",\"注意：容器的内存使用最大限制默认可以接近宿主机的物理内存，可以通过\\\"-m\\\"参数限制容器可以使用的最大内存：\",\"docker run -m 500M redis #限制容器的最大使用内存为500M \"]},\"219\":{\"h\":\"Docker Compose项目部署\",\"t\":[\"Docker Compose介绍\",\"使用微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例。如果每个微服务都要手动启停，那么效率之低、维护量之大可想而知。本节课将讨论如何使用 Docker Compose来轻松、高效地管理容器。为了简单起见将 Docker Compose简称为 Compose。\",\"Compose 是一个用于定义和运行多容器的Docker应用的工具。使用Compose，你可以在一个配置文件（yaml格式）中配置你应用的服务，然后使用一个命令，即可创建并启动配置中引用的所有服务。下面我们进入Compose的实战吧\",\"Docker Compose的安装\",\"Compose的安装有多种方式，例如通过shell安装、通过pip安装、以及将compose作为容器安装等等。本文讲解通过shell安装的方式。其他安装方式如有兴趣，可以查看Docker的官方文档：https://docs.docker.com/compose/install/\",\"# docker compose安装步骤 sudo yum update sudo yum install docker-compose-plugin # 查看版本 docker compose version rpm -e --nodeps `rpm -qa | grep docker-compose-plugin` \",\"Docker Compose入门示例\",\"Compose的使用非常简单，只需要编写一个docker-compose.yml，然后使用docker-compose 命令操作即可。docker-compose.yml描述了容器的配置，而docker-compose 命令描述了对容器的操作。我们首先通过一个示例快速入门：\",\"还记得上节课，我们使用Dockerfile为项目microservice-eureka-server构建Docker镜像吗？我们还以此项目为例测试\",\"我们在microservice-eureka-server-0.0.1-SNAPSHOT.jar所在目录的上一级目录，创建docker-compose.yml 文件。\",\"目录树结构如下：\",\"然后在docker-compose.yml 中添加内容如下：\",\"version: '3.8' services: eureka: #指定服务名 image: microservice-eureka-server:0.0.1 #指定镜像名称 build: ./eureka #指定Dockfile所在路径 ports: - \\\"8761:8761\\\" #指定端口映射 expose: - 8761 #声明容器对外暴露的端口 \",\"在docker-compose.yml 所在路径执行：\",\"docker compose up （后面加-d可以后台启动，加--build会重新构建镜像) \",\"如上图，compose启动会做几件事：\",\"1、创建一个默认的网络app_default，默认以compose所在文件目录名加\\\"_default\\\"命名，compose内的所有容器都会加入此网络，可以相互用服务名访问。\",\"2、如果镜像 microservice-eureka-server:0.0.1 不存在先构建镜像，如果镜像存在则不构建，加上 --build 参数可以强制先构建镜像，如果镜像之前构建过且构建文件没有变化或构建的内容没有变化，就算加上 --build 参数也不会重新构建。\",\"3、根据构建的镜像创建一个名称叫 app_eureka_1 的容器。\",\"4、启动容器。\",\"访问：http://宿主机IP:8761/ ，发现可以正常访问eureka主页。\",\"Docker Compose管理容器的结构\",\"Docker Compose将所管理的容器分为三层，分别是工程（ project），服务（service）以及容器（ container）。 Docker Compose运行目录下的所有文件（ docker-compose.yml、 extends文件或环境变量文件等）组成一个工程（默认为 docker-compose.yml所在目录的目录名称）。一个工程可包含多个服务，每个服务中定义了容器运行的镜像、参数和依赖，一个服务可包括多个容器实例。\",\"上节示例里工程名称是 docker-compose.yml 所在的目录名。该工程包含了1个服务，服务名称是 eureka，执行 docker-compose up时，启动了eureka服务的1个容器实例。\",\"同一个docker compose内部的容器之间可以用服务名相互访问，服务名就相当于hostname，可以直接 ping 服务名，得到的就是服务对应容器的ip，如果服务做了扩容，一个服务对应了多个容器，则 ping 服务名 会轮询访问服务对应的每台容器ip ，docker底层用了LVS等技术帮我们实现这个负载均衡。\",\"docker-compose.yml常用指令\",\"image\",\"指定镜像名称或者镜像id，如果该镜像在本地不存在，Compose会尝试pull下来。\",\"示例：\",\" image: java \",\"build\",\"指定Dockerfile文件的路径。可以是一个路径，例如：\",\"build: ./dir \",\"也可以是一个对象，用以指定Dockerfile和参数，例如：\",\"build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 \",\"command\",\"覆盖容器启动后默认执行的命令。\",\"示例：\",\"command: bundle exec thin -p 3000 \",\"也可以是一个list，类似于Dockerfile总的CMD指令，格式如下：\",\"command: [bundle, exec, thin, -p, 3000] \",\"links\",\"显示链接到其他服务中的容器。可以指定服务名称和链接的别名使用SERVICE:ALIAS 的形式，或者只指定服务名称，示例：\",\"web: links: - db - db:database - redis \",\"external_links\",\"表示链接到docker-compose.yml外部的容器，甚至并非Compose管理的容器，特别是对于那些提供共享容器或共同服务。格式跟links类似，示例：\",\"external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql \",\"ports\",\"暴露端口信息。使用宿主端口:容器端口的格式，或者仅仅指定容器的端口（此时宿主机将会随机指定端口），类似于docker run -p ，示例：\",\"ports: - \\\"3000\\\" - \\\"3000-3005\\\" - \\\"8000:8000\\\" - \\\"9090-9091:8080-8081\\\" - \\\"49100:22\\\" - \\\"127.0.0.1:8001:8001\\\" - \\\"127.0.0.1:5000-5010:5000-5010\\\" \",\"expose\",\"暴露端口，只将端口暴露给连接的服务，而不暴露给宿主机，示例：\",\"expose: - \\\"3000\\\" - \\\"8000\\\" \",\"volumes\",\"卷挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。示例：\",\"volumes: # Just specify a path and let the Engine create a volume - /var/lib/mysql # Specify an absolute path mapping - /opt/data:/var/lib/mysql # Path on the host, relative to the Compose file - ./cache:/tmp/cache # User-relative path - ~/configs:/etc/configs/:ro # Named volume - datavolume:/var/lib/mysql \",\"volumes_from\",\"从另一个服务或者容器挂载卷。可以指定只读或者可读写，如果访问模式没有指定，则默认是可读写。示例：\",\"volumes_from: - service_name - service_name:ro - container:container_name - container:container_name:rw \",\"environment\",\"设置环境变量。可以使用数组或者字典两种方式。只有一个key的环境变量可以在运行Compose的机器上找到对\",\"environment: RACK_ENV: development SHOW: 'true' SESSION_SECRET: environment: - RACK_ENV=development - SHOW=true - SESSION_SECRET \",\"env_file\",\"从文件中获取环境变量，可以为单独的文件路径或列表。如果通过 docker-compose -f FILE 指定了模板文件，则 env_file 中路径会基于模板文件路径。如果有变量名称与 environment 指令冲突，则以envirment 为准。示例：\",\"env_file: .env env_file: - ./common.env - ./apps/web.env - /opt/secrets.env \",\"extends\",\"继承另一个服务，基于已有的服务进行扩展。\",\"net\",\"设置网络模式。示例：\",\"net: \\\"bridge\\\" net: \\\"host\\\" net: \\\"none\\\" net: \\\"container:[service name or container name/id]\\\" \",\"dns\",\"配置dns服务器。可以是一个值，也可以是一个列表。示例：\",\"dns: 8.8.8.8 dns: - 8.8.8.8 - 9.9.9.9 \",\"dns_search\",\"配置DNS的搜索域，可以是一个值，也可以是一个列表，示例：\",\"dns_search: example.com dns_search: - dc1.example.com - dc2.example.com \",\"其他\",\"docker-compose.yml 还有很多其他命令，这里仅挑选常用命令进行讲解，其它不作赘述。如果感兴趣的，可以参考docker-compose.yml文件官方文档：https://docs.docker.com/compose/compose-file/\",\"用Docker Compose编排Spring Cloud电商项目微服务\",\"如果微服务较多，则可以用docker compose来统一编排，接下来我们用docker compose来统一编排电商项目的五个微服务：tulingmall-authcenter，tulingmall-gateway，tulingmall-member，tulingmall-order，tulingmall-product\",\"编排电商项目依赖环境\",\"1、创建一个空目录docker-mall\",\"2、在docker-mall目录下新建一个编排文件docker-compose-env.yml，内容如下：\",\"version: '3.8' services: mysql: image: mysql:5.7 container_name: mysql command: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci #覆盖容器启动后默认执行的启动mysql命令 restart: always #关机或者重启机器时，docker同时重启容器，一般mysql服务可以这么设置，保持服务一直都在 environment: MYSQL_ROOT_PASSWORD: root #设置root帐号密码 ports: - 3306:3306 volumes: - /mydata/mysql/data/db:/var/lib/mysql #数据文件挂载 - /mydata/mysql/data/conf:/etc/mysql/conf.d #配置文件挂载 - /mydata/mysql/log:/var/log/mysql #日志文件挂载 redis: image: redis:5.0 container_name: redis command: redis-server --appendonly yes volumes: - /mydata/redis/data:/data #数据文件挂载 ports: - 6379:6379 rabbitmq: image: rabbitmq:3.7.25-management container_name: rabbitmq volumes: - /mydata/rabbitmq/data:/var/lib/rabbitmq #数据文件挂载 - /mydata/rabbitmq/log:/var/log/rabbitmq #日志文件挂载 ports: - 5672:5672 - 15672:15672 elasticsearch: image: elasticsearch:6.4.0 container_name: elasticsearch environment: - \\\"cluster.name=elasticsearch\\\" #设置集群名称为elasticsearch - \\\"discovery.type=single-node\\\" #以单一节点模式启动 - \\\"ES_JAVA_OPTS=-Xms512m -Xmx512m\\\" #设置使用jvm内存大小，稍微配置大点，不然有可能启动不成功 volumes: - /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins #插件文件挂载 - /mydata/elasticsearch/data:/usr/share/elasticsearch/data #数据文件挂载 ports: - 9200:9200 - 9300:9300 kibana: image: kibana:6.4.0 container_name: kibana links: #同一个compose文件管理的服务可以直接用服务名访问，如果要给服务取别名则可以用links实现，如下面的es就是elasticsearch服务的别名 - elasticsearch:es #可以用es这个域名访问elasticsearch服务 depends_on: - elasticsearch #kibana在elasticsearch启动之后再启动 environment: - \\\"elasticsearch.hosts=http://es:9200\\\" #设置访问elasticsearch的地址 ports: - 5601:5601 logstash: image: logstash:6.4.0 container_name: logstash volumes: - /mydata/logstash/logstash-springboot.conf:/usr/share/logstash/pipeline/logstash.conf #挂载logstash的配置文件，docker对单个文件的挂载需要先在宿主机建好对应文件才能挂载成功 depends_on: - elasticsearch #kibana在elasticsearch启动之后再启动 links: - elasticsearch:es #可以用es这个域名访问elasticsearch服务 ports: - 4560:4560 mongo: image: mongo:3.2 container_name: mongo volumes: - /mydata/mongo/db:/data/db #数据文件挂载 ports: - 27017:27017 nacos: image: nacos/nacos-server:1.4.2 container_name: nacos environment: - MODE=standalone volumes: - /mydata/nacos/logs/:/home/nacos/logs ports: - \\\"8848:8848\\\" zookeeper: image: zookeeper:3.5 ports: - 2181:2181 volumes: - /mydata/zookeeper/data:/data - /mydata/zookeeper/conf:/conf rocketmq: image: rocketmqinc/rocketmq container_name: rocketmq restart: always ports: - 9876:9876 volumes: - /mydata/rocketmq/logs:/home/rocketmq/logs - /mydata/rocketmq/store:/home/rocketmq/store command: sh mqnamesrv broker: image: rocketmqinc/rocketmq container_name: rmqbroker restart: always ports: - 10909:10909 - 10911:10911 - 10912:10912 volumes: - /mydata/rocketmq/logs:/home/rocketmq/logs - /mydata/rocketmq/store:/home/rocketmq/store - /mydata/rocketmq/conf/broker.conf:/opt/rocketmq-4.4.0/conf/broker.conf #这个配置需要先在宿主机对应目录放好broker.conf配置文件,文件内容参考下面文档 command: sh mqbroker -n namesrv:9876 -c ../conf/broker.conf depends_on: - rocketmq environment: - JAVA_HOME=/usr/lib/jvm/jre console: image: styletang/rocketmq-console-ng container_name: rocketmq-console-ng restart: always ports: - 8076:8080 depends_on: - rocketmq environment: - JAVA_OPTS= -Dlogging.level.root=info -Drocketmq.namesrv.addr=rocketmq:9876 - Dcom.rocketmq.sendMessageWithVIPChannel=false \",\"broker.conf文件内容如下：\",\"brokerName = broker-a brokerId = 0 deleteWhen = 04 fileReservedTime = 48 brokerRole = ASYNC_MASTER flushDiskType = ASYNC_FLUSH # 宿主机IP brokerIP1=192.168.65.42 \",\"3、启动compose所有容器，在docker-mall目录执行如下命令：\",\"docker compose -f docker-compose-env.yml up -d \",\"常用的一些docker-compose命令：\",\"# 查看compose内的容器 docker compose -f docker-compose-app.yml ps # 关闭或启动或重启compose内的某个容器 docker compose -f docker-compose-app.yml stop/start/restart <服务名> # 关闭或重启compose所有容器 docker compose -f docker-compose-app.yml stop/restart # 查看compose所有容器的运行日志 docker compose -f docker-compose-app.yml logs -f # 查看compose下某个容器的运行日志 docker compose -f docker-compose-app.yml logs -f <服务名> # 也可以把compose的容器日志输出到日志文件里去，然后用tail -f 随时查看 docker compose -f docker-compose-app.yml logs -f >> myDockerCompose.log & # 重新构建有变化的镜像并更新到容器再启动 docker compose -f docker-compose-app.yml up --build -d # 重新创建docker-compose.yml配置有变化的容器并启动 docker compose -f docker-compose-app.yml up --force-recreate -d #停掉容器再删除容器 docker compose -f docker-compose-app.yml down \",\"编排电商微服务\",\"1、在docker-mall目录下分别创建tulingmall-authcenter，tulingmall-gateway，tulingmall-member，tulingmall-order，tulingmall-product目录。\",\"2、修改电商项目上面这几个微服务配置文件里的中间件配置为上面docker compose里的服务名，并打好jar包放入上面对应的文件夹。\",\"以tulingmall-product服务为例，对应修改后的配置文件如下(注意：大家按照自己下载项目的配置文件去修改，不要直接用我这里的配置，有可能版本不对)\",\"bootstrap.yml文件配置：\",\"spring: application: name: tulingmall-product cloud: nacos: config: server-addr: nacos:8848 #配置中心的地址 file-extension: yml #配置文件结尾的配置 shared-dataids: tulingmall-nacos.yml,tulingmall-db-common.yml #图灵商城公共配置 profiles: active: dev \",\"tulingmall-product-dev.yml文件配置：\",\"server: port: 8866 tomcat: max-threads: 100 spring: application: name: tulingmall-product redis: host: redis port: 6379 password: #密码 timeout: 5000ms lettuce: pool: max-active: 50 max-wait: -1ms max-idle: 8 min-idle: 0 management: #开启SpringBoot Admin的监控 endpoints: web: exposure: include: '*' endpoint: health: show-details: always seata: config: nacos: server-addr: nacos:8848 type: nacos registry: type: nacos tx-service-group: my_test_tx_group client: support: spring: datasource-autoproxy: true #zk配置 zk: curator: retryCount: 5 #重试次数 elapsedTimeMs: 5000 # connectUrl: zookeeper:2181 #zk地址 sessionTimeOutMs: 60000 #会话超时时间 connectionTimeOutMs: 5000 #连接超时时间 \",\"tulingmall-nacos.yml文件配置：\",\"spring: cloud: nacos: discovery: server-addr: nacos:8848 \",\"tulingmall-db-common.yml文件配置：\",\"spring: datasource: url: jdbc:mysql://db:3306/micromall?serverTimezone=UTC&useSSL=false&useUnicode=true&characterEncoding=UTF-8 username: root password: root druid: initial-size: 5 #连接池初始化大小 min-idle: 10 #最小空闲连接数 max-active: 20 #最大连接数 web-stat-filter: exclusions: \\\"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\\\" #不统计这些请求数据 stat-view-servlet: #访问监控网页的登录用户名和密码 login-username: druid login-password: druid mybatis: mapper-locations: - classpath:dao/*.xml - classpath*:com/**/mapper/*.xml \",\"3、在每个微服务目录下新建一个Dockerfile，内容如下，以tulingmall-product服务为例，其它微服务都类似修改：\",\"# 基于哪个镜像 From java:8 # 复制文件到容器 ADD tulingmall-product-0.0.1-SNAPSHOT.jar /app.jar # 配置容器启动后执行的命令 ENTRYPOINT [\\\"java\\\",\\\"-jar\\\",\\\"/app.jar\\\"] \",\"​\",\"4、在docker-mall目录下新建微服务编排文件docker-compose-app.yml，内容如下：\",\"version: '3.8' services: tulingmall-authcenter: image: mall/tulingmall-authcenter:0.0.1 #指定镜像名称 build: ./tulingmall-authcenter #指定Dockfile所在路径 container_name: tulingmall-authcenter #指定启动容器名称 ports: - 9999:9999 volumes: - /etc/localtime:/etc/localtime:ro #同步宿主机与容器时间，ro代表readonly只读 environment: - JAVA_TOOL_OPTIONS=-Xmx1g -Xms1g -XX:MaxMetaspaceSize=512m -javaagent:/agent/skywalking-agent.jar -DSW_AGENT_NAME=tulingmall-order -DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.65.204:11800 external_links: #访问不在同一个compose文件管理的服务需要用external_links，前提是这些服务都在同一个网络下才能正常访问 - nacos:nacos #可以用nacos这个域名访问nacos服务 - mysql:db #可以用db这个域名访问mysql服务 cap_add: - SYS_PTRACE #这个参数是让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令，如果不需要在容器里执行这些命令可以不加 tulingmall-gateway: image: mall/tulingmall-gateway:0.0.1 build: ./tulingmall-gateway container_name: tulingmall-gateway ports: - 8888:8888 volumes: - /etc/localtime:/etc/localtime:ro #同步宿主机与容器时间 environment: - JAVA_TOOL_OPTIONS=-Xmx1g -Xms1g -XX:MaxMetaspaceSize=512m -javaagent:/agent/skywalking-agent.jar -DSW_AGENT_NAME=tulingmall-order -DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.65.204:11800 depends_on: - tulingmall-authcenter #gateway在authcenter启动之后再启动 external_links: - nacos:nacos cap_add: - SYS_PTRACE #这个参数是让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令，如果不需要在容器里执行这些命令可以不加 tulingmall-member: image: mall/tulingmall-member:0.0.1 build: ./tulingmall-member container_name: tulingmall-member ports: - 8877:8877 volumes: - /etc/localtime:/etc/localtime:ro #同步宿主机与容器时间 environment: - JAVA_TOOL_OPTIONS=-Xmx1g -Xms1g -XX:MaxMetaspaceSize=512m -javaagent:/agent/skywalking-agent.jar -DSW_AGENT_NAME=tulingmall-order -DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.65.204:11800 external_links: - nacos:nacos - mysql:db #可以用db这个域名访问mysql服务 - mongo - redis - rabbitmq cap_add: - SYS_PTRACE #这个参数是让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令，如果不需要在容器里执行这些命令可以不加 tulingmall-product: image: mall/tulingmall-product:0.0.1 build: ./tulingmall-product container_name: tulingmall-product ports: - 8866:8866 volumes: - /etc/localtime:/etc/localtime:ro #同步宿主机与容器时间 environment: - JAVA_TOOL_OPTIONS=-Xmx1g -Xms1g -XX:MaxMetaspaceSize=512m -javaagent:/agent/skywalking-agent.jar -DSW_AGENT_NAME=tulingmall-order -DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.65.204:11800 external_links: - nacos:nacos - mysql:db #可以用db这个域名访问mysql服务 - redis - zookeeper cap_add: - SYS_PTRACE #这个参数是让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令，如果不需要在容器里执行这些命令可以不加 tulingmall-order: image: mall/tulingmall-order:0.0.1 build: ./tulingmall-order container_name: tulingmall-order ports: - 8844:8844 volumes: - /etc/localtime:/etc/localtime:ro #同步宿主机与容器时间 environment: - JAVA_TOOL_OPTIONS=-Xmx1g -Xms1g -XX:MaxMetaspaceSize=512m -javaagent:/agent/skywalking-agent.jar -DSW_AGENT_NAME=tulingmall-order -DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.65.204:11800 external_links: - nacos:nacos - mysql:db #可以用db这个域名访问mysql服务 - redis - rabbitmq - namesrv:rockermq cap_add: - SYS_PTRACE #这个参数是让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令，如果不需要在容器里执行这些命令可以不加 \",\"5、启动compose的所有微服务容器，在docker-mall目录执行如下命令：\",\"#这里启动的微服务跟上面启动的mysql，redis这些中间件服务因为都在docker-mall目录下，即都是同一个工程下，默认都在相同的网络下，可以相互访问 docker compose -f docker-compose-app.yml up -d \",\"6、访问下微服务的api看是否都正常，访问接口参数参看视频，不一定访问我列的这几个接口，其它的接口也行\",\"1、通过网关访问登录接口获取token，post方式： http://192.168.65.61:8888/sso/login?username=test&password=test 2、通过网关访问添加购物车接口，post方式： http://192.168.65.61:8888/cart/add 3、通过网关访问查询购物车接口，get方式： http://192.168.65.61:8888/cart/list 4、通过网关访问创建订单接口，post方式： http://192.168.65.61:8888/order/generateOrder \",\"动态扩容微服务(单物理机内扩容)\",\"有时我们需要扩容微服务，比如我们想把用户和订单微服务各部署两个微服务，则需要将docker-compose.yml里的服务的端口映射和容器名称都注释掉，因为不可能两个订单服务的容器映射到宿主机的同一个端口，修改之后的docker-compose-app.yml内容如下：\",\"version: '3.8' services: tulingmall-authcenter: image: mall/tulingmall-authcenter:0.0.1 #指定镜像名称 build: ./tulingmall-authcenter #指定Dockfile所在路径 container_name: tulingmall-authcenter #指定启动容器名称 ports: - 9999:9999 volumes: - /etc/localtime:/etc/localtime:ro #同步宿主机与容器时间，ro代表readonly只读 environment: - JAVA_TOOL_OPTIONS=-Xmx1g -Xms1g -XX:MaxMetaspaceSize=256m -javaagent:/agent/skywalking-agent.jar -DSW_AGENT_NAME=tulingmall-order -DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.65.204:11800 external_links: #访问不在同一个compose文件管理的服务需要用external_links，前提是这些服务都在同一个网络下才能正常访问 - nacos:nacos #可以用nacos这个域名访问nacos服务 - mysql:db #可以用db这个域名访问mysql服务 cap_add: - SYS_PTRACE #这个参数是让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令，如果不需要在容器里执行这些命令可以不加 tulingmall-gateway: image: mall/tulingmall-gateway:0.0.1 build: ./tulingmall-gateway container_name: tulingmall-gateway ports: - 8888:8888 volumes: - /etc/localtime:/etc/localtime:ro #同步宿主机与容器时间 environment: - JAVA_TOOL_OPTIONS=-Xmx1g -Xms1g -XX:MaxMetaspaceSize=256m -javaagent:/agent/skywalking-agent.jar -DSW_AGENT_NAME=tulingmall-order -DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.65.204:11800 depends_on: - tulingmall-authcenter #gateway在authcenter启动之后再启动 external_links: - nacos:nacos cap_add: - SYS_PTRACE #这个参数是让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令，如果不需要在容器里执行这些命令可以不加 tulingmall-member: image: mall/tulingmall-member:0.0.1 build: ./tulingmall-member container_name: tulingmall-member ports: - 8877:8877 volumes: - /etc/localtime:/etc/localtime:ro #同步宿主机与容器时间 environment: - JAVA_TOOL_OPTIONS=-Xmx1g -Xms1g -XX:MaxMetaspaceSize=256m -javaagent:/agent/skywalking-agent.jar -DSW_AGENT_NAME=tulingmall-order -DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.65.204:11800 external_links: - nacos:nacos - mysql:db #可以用db这个域名访问mysql服务 - mongo - redis - rabbitmq cap_add: - SYS_PTRACE #这个参数是让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令，如果不需要在容器里执行这些命令可以不加 tulingmall-product: image: mall/tulingmall-product:0.0.1 build: ./tulingmall-product # container_name: tulingmall-product # ports: # - 8866:8866 volumes: - /etc/localtime:/etc/localtime:ro #同步宿主机与容器时间 environment: - JAVA_TOOL_OPTIONS=-Xmx1g -Xms1g -XX:MaxMetaspaceSize=256m -javaagent:/agent/skywalking-agent.jar -DSW_AGENT_NAME=tulingmall-order -DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.65.204:11800 deploy: replicas:2 external_links: - nacos:nacos - mysql:db #可以用db这个域名访问mysql服务 - redis - zookeeper cap_add: - SYS_PTRACE #这个参数是让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令，如果不需要在容器里执行这些命令可以不加 tulingmall-order: image: mall/tulingmall-order:0.0.1 build: ./tulingmall-order # container_name: tulingmall-order # ports: # - 8844:8844 volumes: - /etc/localtime:/etc/localtime:ro #同步宿主机与容器时间 environment: - JAVA_TOOL_OPTIONS=-Xmx1g -Xms1g -XX:MaxMetaspaceSize=256m -javaagent:/agent/skywalking-agent.jar -DSW_AGENT_NAME=tulingmall-order -DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.65.204:11800 external_links: - nacos:nacos - mysql:db #可以用db这个域名访问mysql服务 - redis - rabbitmq - namesrv:rockermq cap_add: - SYS_PTRACE #这个参数是让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令，如果不需要在容器里执行这些命令可以不加 \",\"执行如下扩容命令，服务一旦扩容对应了多个容器，则访问服务名docker会自动帮我们负载均衡去访问服务对应的每台容器：\",\"docker compose -f docker-compose-app.yml up --force-recreate -d #必须先正常编排微服务，然后才能动态扩容,文件有变动，需要重新创建容器 docker compose -f docker-compose-app.yml scale tulingmall-order=2 tulingmall-product=2 #如果要缩容执行如下操作 docker compose -f docker-compose-app.yml scale tulingmall-order=1 tulingmall-product=1 \",\"注意：docker compose主要用在单物理机内扩容的情况，要做多机扩容还需自己在多个机器上做很多定制化配置，当然，要做多物理机扩容一般都会用docker swarm或kubernetes。\"]},\"220\":{\"h\":\"idea加密连接服务器docker\"},\"221\":{\"h\":\"配置证书\"},\"222\":{\"h\":\"创建一个存放证书目录\",\"t\":[\"mkdir -p /usr/local/ca cd /usr/local/ca \"]},\"223\":{\"h\":\"创建一键生成证书脚本\",\"t\":[\"vi ca.sh \",\"按 A 按键切换为输入模式，然后把下面代码粘贴上去\",\"#!/bin/bash SERVER=\\\"服务器公网IP\\\" PASSWORD=\\\"密码\\\" COUNTRY=\\\"CN\\\" STATE=\\\"hangzhou\\\" CITY=\\\"hangzhou\\\" ORGANIZATION=\\\"jiangqingdong\\\" ORGANIZATIONAL_UNIT=\\\"dev\\\" EMAIL=\\\"邮箱\\\" echo \\\"starting...\\\" cd /usr/local/ca openssl genrsa -aes256 -passout pass:$PASSWORD -out ca-key.pem 4096 openssl req -new -x509 -passin \\\"pass:$PASSWORD\\\" -days 3650 -key ca-key.pem -sha256 -out ca.pem -subj \\\"/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$SERVER/emailAddress=$EMAIL\\\" openssl genrsa -out server-key.pem 4096 openssl req -subj \\\"/CN=$SERVER\\\" -new -key server-key.pem -out server.csr sh -c 'echo \\\"subjectAltName = IP:'$SERVER',IP:0.0.0.0\\\" >> extfile.cnf' sh -c 'echo \\\"extendedKeyUsage = serverAuth\\\" >> extfile.cn' sh -c 'echo \\\"extendedKeyUsage = serverAuth\\\" >> extfile.cnf' openssl x509 -req -days 3650 -in server.csr -CA ca.pem -CAkey ca-key.pem -passin \\\"pass:$PASSWORD\\\" -CAcreateserial -out server-cert.pem -extfile extfile.cnf openssl genrsa -out key.pem 4096 openssl req -subj \\\"/CN=client\\\" -new -key key.pem -out client.csr sh -c 'echo extendedKeyUsage=clientAuth >> extfile-client.cnf' openssl x509 -req -days 3650 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -passin \\\"pass:$PASSWORD\\\" -CAcreateserial -out cert.pem -extfile extfile-client.cnf rm client.csr server.csr cp server-*.pem /etc/docker/ cp ca.pem /etc/docker/ echo \\\"========end========\\\" \"]},\"224\":{\"h\":\"保存脚本后执行\",\"t\":[\"sh ca.sh \"]},\"225\":{\"h\":\"修改Docker配置\",\"t\":[\"使 Docker 守护程序仅接收来自提供 CA 信任的证书的客户端的链接\",\"vim /lib/systemd/system/docker.service \",\"将 ExecStart 属性值进行替换\",\"ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/usr/local/ca/ca.pem --tlscert=/usr/local/ca/server-cert.pem --tlskey=/usr/local/ca/server-key.pem -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock \"]},\"226\":{\"h\":\"重载服务并重启docker\",\"t\":[\"systemctl daemon-reload && systemctl restart docker \"]},\"227\":{\"h\":\"保存证书客户端文件到本地\"},\"228\":{\"h\":\"测试证书是否配置成功\",\"t\":[\"docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=key.pem -H=服务器外网ip:2375 version \"]},\"229\":{\"h\":\"使用idea连接\"},\"230\":{\"h\":\"容器访问宿主机ip\",\"t\":[\"在 Docker 20.10 及以上版本中，Docker 访问宿主机的方式有所变化：\",\"在 Docker 命令行中，添加：\",\"--add-host=host.docker.internal:host-gateway \",\"在 docker-compose 中，添加：\",\"extra_hosts: - host.docker.internal:host-gateway \",\"即可通过 host.docker.internal 域名访问宿主机。\"]},\"231\":{\"h\":\"Dockerfile\",\"t\":[\"在介绍 Dockerfile 最佳实践前，这里再强调一下，生产实践中一定优先使用 Dockerfile 的方式构建镜像。 因为使用 Dockerfile 构建镜像可以带来很多好处：\",\"易于版本化管理，Dockerfile 本身是一个文本文件，方便存放在代码仓库做版本管理，可以很方便地找到各个版本之间的变更历史；\",\"过程可追溯，Dockerfile 的每一行指令代表一个镜像层，根据 Dockerfile 的内容即可很明确地查看镜像的完整构建过程；\",\"屏蔽构建环境异构，使用 Dockerfile 构建镜像无须考虑构建环境，基于相同 Dockerfile 无论在哪里运行，构建结果都一致。\",\"虽然有这么多好处，但是如果你 Dockerfile 使用不当也会引发很多问题。比如镜像构建时间过长，甚至镜像构建失败；镜像层数过多，导致镜像文件过大。所以，这一课时我就教你如何在生产环境中编写最优的 Dockerfile。\",\"在介绍 Dockerfile 最佳实践前，我们再聊一下我们平时书写 Dockerfile 应该尽量遵循的原则。\",\"Dockerfile 书写原则\",\"遵循以下 Dockerfile 书写原则，不仅可以使得我们的 Dockerfile 简洁明了，让协作者清楚地了解镜像的完整构建流程，还可以帮助我们减少镜像的体积，加快镜像构建的速度和分发速度。\",\"（1）单一职责\",\"由于容器的本质是进程，一个容器代表一个进程，因此不同功能的应用应该尽量拆分为不同的容器，每个容器只负责单一业务进程。\",\"（2）提供注释信息\",\"Dockerfile 也是一种代码，我们应该保持良好的代码编写习惯，晦涩难懂的代码尽量添加注释，让协作者可以一目了然地知道每一行代码的作用，并且方便扩展和使用。\",\"（3）保持容器最小化\",\"应该避免安装无用的软件包，比如在一个 nginx 镜像中，我并不需要安装 vim 、gcc 等开发编译工具。这样不仅可以加快容器构建速度，而且可以避免镜像体积过大。\",\"（4）合理选择基础镜像\",\"容器的核心是应用，因此只要基础镜像能够满足应用的运行环境即可。例如一个Java类型的应用运行时只需要JRE，并不需要JDK，因此我们的基础镜像只需要安装JRE环境即可。\",\"（5）使用 .dockerignore 文件\",\"在使用git时，我们可以使用.gitignore文件忽略一些不需要做版本管理的文件。同理，使用.dockerignore文件允许我们在构建时，忽略一些不需要参与构建的文件，从而提升构建效率。.dockerignore的定义类似于.gitignore。\",\".dockerignore的本质是文本文件，Docker 构建时可以使用换行符来解析文件定义，每一行可以忽略一些文件或者文件夹。具体使用方式如下：\",\"规则\",\"含义\",\"#\",\"# 开头的表示注释，# 后面所有内容将会被忽略\",\"/tmp\",\"匹配当前目录下任何以 tmp 开头的文件或者文件夹\",\"*.md\",\"匹配以 .md 为后缀的任意文件\",\"tem?\",\"匹配以 tem 开头并且以任意字符结尾的文件，？代表任意一个字符\",\"!README.md\",\"! 表示排除忽略。例如 .dockerignore 定义如下：*.md!README.md表示除了 README.md 文件外所有以 .md 结尾的文件。\",\"（6）尽量使用构建缓存\",\"Docker 构建过程中，每一条 Dockerfile 指令都会提交为一个镜像层，下一条指令都是基于上一条指令构建的。如果构建时发现要构建的镜像层的父镜像层已经存在，并且下一条命令使用了相同的指令，即可命中构建缓存。\",\"Docker 构建时判断是否需要使用缓存的规则如下：\",\"从当前构建层开始，比较所有的子镜像，检查所有的构建指令是否与当前完全一致，如果不一致，则不使用缓存；\",\"一般情况下，只需要比较构建指令即可判断是否需要使用缓存，但是有些指令除外（例如ADD和COPY）；\",\"对于ADD和COPY指令不仅要校验命令是否一致，还要为即将拷贝到容器的文件计算校验和（根据文件内容计算出的一个数值，如果两个文件计算的数值一致，表示两个文件内容一致 ），命令和校验和完全一致，才认为命中缓存。\",\"因此，基于 Docker 构建时的缓存特性，我们可以把不轻易改变的指令放到 Dockerfile 前面（例如安装软件包），而可能经常发生改变的指令放在 Dockerfile 末尾（例如编译应用程序）。\",\"例如，我们想要定义一些环境变量并且安装一些软件包，可以按照如下顺序编写 Dockerfile：\",\"FROM centos:7 # 设置环境变量指令放前面 ENV PATH /usr/local/bin:$PATH # 安装软件指令放前面 RUN yum install -y make # 把业务软件的配置,版本等经常变动的步骤放最后 ... \",\"按照上面原则编写的 Dockerfile 在构建镜像时，前面步骤命中缓存的概率会增加，可以大大缩短镜像构建时间。\",\"（7）正确设置时区\",\"我们从 Docker Hub 拉取的官方操作系统镜像大多数都是 UTC 时间（世界标准时间）。如果你想要在容器中使用中国区标准时间（东八区），请根据使用的操作系统修改相应的时区信息，下面我介绍几种常用操作系统的修改方式：\",\"Ubuntu 和Debian 系统\",\"Ubuntu 和Debian 系统可以向 Dockerfile 中添加以下指令：\",\"RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime RUN echo \\\"Asia/Shanghai\\\" >> /etc/timezone \",\"CentOS系统\",\"CentOS 系统则向 Dockerfile 中添加以下指令：\",\"RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \",\"（8）使用国内软件源加快镜像构建速度\",\"由于我们常用的官方操作系统镜像基本都是国外的，软件服务器大部分也在国外，所以我们构建镜像的时候想要安装一些软件包可能会非常慢。\",\"这里我以 CentOS 7 为例，介绍一下如何使用 163 软件源（国内有很多大厂，例如阿里、腾讯、网易等公司都免费提供的软件加速源）加快镜像构建。\",\"首先在容器构建目录创建文件 CentOS7-Base-163.repo，文件内容如下：\",\"# CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client. You should use this for CentOS updates # unless you are manually picking other mirrors. # # If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead. # # [base] name=CentOS-$releasever - Base - 163.com #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os baseurl=http://mirrors.163.com/centos/$releasever/os/$basearch/ gpgcheck=1 gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7 #released updates [updates] name=CentOS-$releasever - Updates - 163.com #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=updates baseurl=http://mirrors.163.com/centos/$releasever/updates/$basearch/ gpgcheck=1 gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7 #additional packages that may be useful [extras] name=CentOS-$releasever - Extras - 163.com #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=extras baseurl=http://mirrors.163.com/centos/$releasever/extras/$basearch/ gpgcheck=1 gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7 #additional packages that extend functionality of existing packages [centosplus] name=CentOS-$releasever - Plus - 163.com baseurl=http://mirrors.163.com/centos/$releasever/centosplus/$basearch/ gpgcheck=1 enabled=0 gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7 \",\"然后在 Dockerfile 中添加如下指令：\",\"COPY CentOS7-Base-163.repo /etc/yum.repos.d/CentOS7-Base.repo \",\"执行完上述步骤后，再使用yum install命令安装软件时就会默认从 163 获取软件包，这样可以大大提升构建速度。\",\"（9）最小化镜像层数\",\"在构建镜像时尽可能地减少 Dockerfile 指令行数。例如我们要在 CentOS 系统中安装make和net-tools两个软件包，应该在 Dockerfile 中使用以下指令：\",\"RUN yum install -y make net-tools \",\"而不应该写成这样：\",\"RUN yum install -y make RUN yum install -y net-tools \",\"了解完 Dockerfile 的书写原则后，我们再来具体了解下这些原则落实到具体的 Dockerfile 指令应该如何书写。\",\"Dockerfile 指令书写建议\",\"下面是我们常用的一些指令，这些指令对于刚接触 Docker 的人来说会非常容易出错，下面我对这些指令的书写建议详细讲解一下。\",\"（1）RUN\",\"RUN指令在构建时将会生成一个新的镜像层并且执行RUN指令后面的内容。\",\"使用RUN指令时应该尽量遵循以下原则：\",\"当RUN指令后面跟的内容比较复杂时，建议使用反斜杠（\\\\） 结尾并且换行；\",\"RUN指令后面的内容尽量按照字母顺序排序，提高可读性。\",\"例如，我想在官方的 CentOS 镜像下安装一些软件，一个建议的 Dockerfile 指令如下：\",\"FROM centos:7 RUN yum install -y automake \\\\ curl \\\\ python \\\\ vim \",\"（2）CMD 和 ENTRYPOINT\",\"CMD和ENTRYPOINT指令都是容器运行的命令入口，这两个指令使用中有很多相似的地方，但是也有一些区别。\",\"这两个指令的相同之处，CMD和ENTRYPOINT的基本使用格式分为两种。\",\"第一种为CMD/ENTRYPOINT[\\\"command\\\" , \\\"param\\\"]。这种格式是使用 Linux 的exec实现的， 一般称为exec模式，这种书写格式为CMD/ENTRYPOINT后面跟 json 数组，也是Docker 推荐的使用格式。\",\"另外一种格式为CMD/ENTRYPOINTcommand param ，这种格式是基于 shell 实现的， 通常称为shell模式。当使用shell模式时，Docker 会以 /bin/sh -c command 的方式执行命令。\",\"使用 exec 模式启动容器时，容器的 1 号进程就是 CMD/ENTRYPOINT 中指定的命令，而使用 shell 模式启动容器时相当于我们把启动命令放在了 shell 进程中执行，等效于执行 /bin/sh -c \\\"task command\\\" 命令。因此 shell 模式启动的进程在容器中实际上并不是 1 号进程。\",\"这两个指令的区别：\",\"Dockerfile 中如果使用了ENTRYPOINT指令，启动 Docker 容器时需要使用 --entrypoint 参数才能覆盖 Dockerfile 中的ENTRYPOINT指令 ，而使用CMD设置的命令则可以被docker run后面的参数直接覆盖。\",\"ENTRYPOINT指令可以结合CMD指令使用，也可以单独使用，而CMD指令只能单独使用。\",\"看到这里你也许会问，我什么时候应该使用ENTRYPOINT,什么时候使用CMD呢？\",\"如果你希望你的镜像足够灵活，推荐使用CMD指令。如果你的镜像只执行单一的具体程序，并且不希望用户在执行docker run时覆盖默认程序，建议使用ENTRYPOINT。\",\"最后再强调一下，无论使用CMD还是ENTRYPOINT，都尽量使用exec模式。\",\"（3）ADD 和 COPY\",\"ADD和COPY指令功能类似，都是从外部往容器内添加文件。但是COPY指令只支持基本的文件和文件夹拷贝功能，ADD则支持更多文件来源类型，比如自动提取 tar 包，并且可以支持源文件为 URL 格式。\",\"那么在日常应用中，我们应该使用哪个命令向容器里添加文件呢？你可能在想，既然ADD指令支持的功能更多，当然应该使用ADD指令了。然而事实恰恰相反，我更推荐你使用COPY指令，因为COPY指令更加透明，仅支持本地文件向容器拷贝，而且使用COPY指令可以更好地利用构建缓存，有效减小镜像体积。\",\"当你想要使用ADD向容器中添加 URL 文件时，请尽量考虑使用其他方式替代。例如你想要在容器中安装 memtester（一种内存压测工具），你应该避免使用以下格式：\",\"ADD http://pyropus.ca/software/memtester/old-versions/memtester-4.3.0.tar.gz /tmp/ RUN tar -xvf /tmp/memtester-4.3.0.tar.gz -C /tmp RUN make -C /tmp/memtester-4.3.0 && make -C /tmp/memtester-4.3.0 install \",\"下面是推荐写法：\",\"RUN wget -O /tmp/memtester-4.3.0.tar.gz http://pyropus.ca/software/memtester/old-versions/memtester-4.3.0.tar.gz \\\\ && tar -xvf /tmp/memtester-4.3.0.tar.gz -C /tmp \\\\ && make -C /tmp/memtester-4.3.0 && make -C /tmp/memtester-4.3.0 install \",\"（4）WORKDIR\",\"为了使构建过程更加清晰明了，推荐使用 WORKDIR 来指定容器的工作路径，应该尽量避免使用 RUN cd /work/path && do some work 这样的指令。\",\"最后给出几个常用软件的官方 Dockerfile 示例链接，希望可以对你有所帮助。\",\"Go\",\"Nginx\",\"Hy\",\"结语\",\"好了，到此为止，相信你已经对 Dockerfile 的书写原则和一些重要指令有了较深的认识。\",\"当你需要编写编译型语言（例如 Golang、Java）的 Dockerfile 时，如何分离编译环境和运行环境，使得镜像体积尽可能小呢？思考后，可以把你的想法写在留言区。\"]},\"232\":{\"h\":\"精选评论\"},\"233\":{\"h\":\"Ben.Zhong：\",\"t\":[\"把 编译环境 单独打包镜像，只提供编译好的二进制（注意运行 CPU 架构）。运行环境单独做镜像，只考虑基础运行环境的配置。好处还是很明显，程序发布单独版本管理，运行环境也单独组合。还有好处就是，运行环境打补丁升级等等，不用影响程序发布。\"]},\"234\":{\"h\":\"讲师回复：\",\"t\":[\" 是的，这位同学理解很到位，分离编译环境和运行环境对于生产环境很重要\"]},\"235\":{\"h\":\"潘：\",\"t\":[\"这个docker学习通俗易懂\"]},\"236\":{\"h\":\"*庚：\",\"t\":[\"为什么推荐exec模式\"]},\"237\":{\"h\":\"讲师回复：\",\"t\":[\" exec 可以保证我们的业务进程就是 1 号进程，这对于需要处理 SIGTERM 信号量实现优雅终止十分重要。\"]},\"238\":{\"h\":\"**的蜗牛：\",\"t\":[\"「尽量使用构建缓存」放在后面命中缓存的概率是一样的，构建镜像的整体时间原则上也一样。所以对这个原则不是很理解？\"]},\"239\":{\"h\":\"讲师回复：\",\"t\":[\" 简单来说就是如果第n层有改动，则n层以后的缓存都会失效，⼤多数情况下判断有⽆改动的⽅法是判断这层的指令和缓存中的构建 指令是否⼀致，但是对于COPY和ADD命令会计算镜像内的⽂件和构建⽬录⽂件的校验和然后做⽐较来判断本层是否有改动。\"]},\"240\":{\"h\":\"*朋：\",\"t\":[\"docker-compose. yml中，service下配置了volumn，在全局中也有volumn的声明，这个声明有什么用\"]},\"241\":{\"h\":\"讲师回复：\",\"t\":[\" 全局中声明 volumns，在 service 中使用，这样设计是为了方便多个 service 中的服务共享相同的 volumn\"]},\"242\":{\"h\":\"kopelan：\",\"t\":[\"hi，dockerfile中的ENV是否也是每局一层呢？比如我要配置多个ENV环境变量，我应该怎么写？另外我看教程中ENV 有写作ENV key value，也有写作ENV key=value，这个有什么区别呢？\"]},\"243\":{\"h\":\"讲师回复：\",\"t\":[\" 定义多个 ENV 直接多行写就行,基本不会占用额外空间, 一般推荐写成 ENV key=value 的形式\"]},\"244\":{\"h\":\"**斯：\",\"t\":[\"要尽量减小,镜像的体积！ 为什么基础底层镜像不使用alpine呢\"]},\"245\":{\"h\":\"讲师回复：\",\"t\":[\" 生产中如果公司镜像统一,底层镜像尽量使用工具较多的镜像, alpine 虽然小,但是功能相对也少,而底层镜像只需要拉取一次.\"]},\"246\":{\"h\":\"**佳：\",\"t\":[\"老师，请教一个Linux的问题。为什么以下两个命令输出的结果不一样呢？我想这也是要尽量用exec的原因是吗？echo HOME=$HOMEsh -c echo\\\">HOME=$HOME\"]},\"247\":{\"h\":\"讲师回复：\",\"t\":[\" 第一个命令相当于在容器主进程下执行命令，第二个命令是先创建一个 sh 进程，然后再执行相关的命令\"]},\"248\":{\"h\":\"**博：\",\"t\":[\"不太懂编译环境和运行环境，比如我现在的dockerFile，jar包直接运行了FROM openjdk:8-jre-alpineCOPY . /usr/src/myappWORKDIR /usr/src/myappENTRYPOINT [\\\"java\\\", \\\"-jar\\\", \\\"channeladminservice.jar\\\"]CMD [\\\"--spring.profiles.active=cloud-smoke\\\"]\"]},\"249\":{\"h\":\"讲师回复：\",\"t\":[\" 编译环境是指编译运行程序所需要的环境，运行环境即我们的应用程序想要正常运行所依赖的环境。例如我们编译 Java 应用程序需要 JDK 环境，而真正运行我们的 Java 程序则仅需要 JRE 环境即可。\"]},\"250\":{\"h\":\"**升：\",\"t\":[\"真的很赞啊，写得太好了\"]},\"251\":{\"h\":\"*峰：\",\"t\":[\"能否分享下java栈最优dockfile\"]},\"252\":{\"h\":\"讲师回复：\",\"t\":[\" 这个需要根据不同的业务场景来制定的，推荐使用多阶段编译的方式，将编译环境和运行环境分开，然后遵循第6讲 Dockerfile 最佳实践中的原则编写 Dockerfile 即可\"]},\"253\":{\"h\":\"**1156：\",\"t\":[\"CMD [\\\"nginx\\\", \\\"-g\\\", \\\"daemon off;\\\"]这个-g和daemon off是什么意思\"]},\"254\":{\"h\":\"讲师回复：\",\"t\":[\" 就是让 nginx 以前台的方式启动，启动后不退出当前窗口\",\"b\"]},\"255\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"256\":{\"h\":\"Pages\"},\"257\":{\"h\":\"面试\"}},\"dirtCount\":0,\"index\":[[\"峰\",{\"0\":{\"251\":1}}],[\"真的很赞啊\",{\"1\":{\"250\":1}}],[\"真正的网址是\",{\"1\":{\"42\":1}}],[\"升\",{\"0\":{\"250\":1}}],[\"升序是什么\",{\"1\":{\"216\":1}}],[\"升序索引底层实现\",{\"1\":{\"216\":1}}],[\"环境即可\",{\"1\":{\"249\":1}}],[\"环境\",{\"1\":{\"249\":1}}],[\"环境中运行库程序时选择使用的\",{\"1\":{\"64\":1}}],[\"博\",{\"0\":{\"248\":1}}],[\"佳\",{\"0\":{\"246\":1}}],[\"斯\",{\"0\":{\"244\":1}}],[\"朋\",{\"0\":{\"240\":1}}],[\"朋友圈点赞等功能\",{\"1\":{\"216\":1}}],[\"⼤多数情况下判断有⽆改动的⽅法是判断这层的指令和缓存中的构建\",{\"1\":{\"239\":1}}],[\"庚\",{\"0\":{\"236\":1}}],[\"潘\",{\"0\":{\"235\":1}}],[\"精选评论\",{\"0\":{\"232\":1}}],[\"精选出单例beandrtnibon\",{\"1\":{\"216\":1}}],[\"思考后\",{\"1\":{\"231\":1}}],[\"好了\",{\"1\":{\"231\":1}}],[\"好处还是很明显\",{\"1\":{\"233\":1}}],[\"好处又在哪里\",{\"1\":{\"217\":1}}],[\"好处\",{\"1\":{\"64\":1}}],[\"希望可以对你有所帮助\",{\"1\":{\"231\":1}}],[\"希尔排序\",{\"1\":{\"64\":1}}],[\"然而事实恰恰相反\",{\"1\":{\"231\":1}}],[\"然后遵循第6讲\",{\"1\":{\"252\":1}}],[\"然后把下面代码粘贴上去\",{\"1\":{\"223\":1}}],[\"然后把每个区域可能造成内存的溢出的情况说明\",{\"1\":{\"64\":1}}],[\"然后才能动态扩容\",{\"1\":{\"219\":1}}],[\"然后用tail\",{\"1\":{\"219\":1}}],[\"然后使用docker\",{\"1\":{\"219\":1}}],[\"然后使用一个命令\",{\"1\":{\"219\":1}}],[\"然后\",{\"1\":{\"218\":1}}],[\"然后发布到任何流行的\",{\"1\":{\"217\":1}}],[\"然后直接向业务返回成功\",{\"1\":{\"216\":1}}],[\"然后直接调用\",{\"1\":{\"216\":1}}],[\"然后看目前表里有多少条数据\",{\"1\":{\"216\":1}}],[\"然后部署不同的机器或进程中去\",{\"1\":{\"216\":1}}],[\"然后在docker\",{\"1\":{\"219\":1}}],[\"然后在\",{\"1\":{\"216\":1,\"231\":1}}],[\"然后pk\",{\"1\":{\"216\":1}}],[\"然后调用\",{\"1\":{\"216\":1}}],[\"然后调用库存系统\",{\"1\":{\"216\":1}}],[\"然后调用kafkaconsumer\",{\"1\":{\"64\":1}}],[\"然后启动tomcat\",{\"1\":{\"216\":1}}],[\"然后判断是否超过阈值\",{\"1\":{\"216\":1}}],[\"然后转移元素到新数组中\",{\"1\":{\"216\":1}}],[\"然后再执行相关的命令\",{\"1\":{\"247\":1}}],[\"然后再不断扩展其功能\",{\"1\":{\"216\":1}}],[\"然后再根据实现这些接口的集合的特点来选用\",{\"1\":{\"91\":1}}],[\"然后不断优化性能\",{\"1\":{\"216\":1}}],[\"然后获取应用实例地址\",{\"1\":{\"216\":1}}],[\"然后分别创建一个降序索引\",{\"1\":{\"216\":1}}],[\"然后分别使用不同的线程池去处理\",{\"1\":{\"64\":1}}],[\"然后将指针指向新的\",{\"1\":{\"94\":1}}],[\"然后给每一段数据配一把锁\",{\"1\":{\"83\":1}}],[\"然后通过利用b+树叶子节点存储了所有数据并且进行了排序\",{\"1\":{\"216\":1}}],[\"然后通过一个节点中可以存储多个元素\",{\"1\":{\"216\":1}}],[\"然后通过\",{\"1\":{\"77\":1}}],[\"然后记录最后一条的时间\",{\"1\":{\"64\":1}}],[\"然后被清理掉\",{\"1\":{\"64\":1}}],[\"然后由\",{\"1\":{\"64\":1}}],[\"然后会根据你说的源码问一些细节的问题\",{\"1\":{\"64\":1}}],[\"然后会从任务队列里提取事件\",{\"1\":{\"57\":1}}],[\"然后解析\",{\"1\":{\"57\":1}}],[\"获取软件包\",{\"1\":{\"231\":1}}],[\"腾讯\",{\"1\":{\"231\":1}}],[\"国内有很多大厂\",{\"1\":{\"231\":1}}],[\"国际化资源访问器\",{\"1\":{\"216\":1}}],[\"国际化\",{\"1\":{\"216\":1}}],[\"东八区\",{\"1\":{\"231\":1}}],[\"世界标准时间\",{\"1\":{\"231\":1}}],[\"拉取的官方操作系统镜像大多数都是\",{\"1\":{\"231\":1}}],[\"拉链法\",{\"1\":{\"77\":1,\"90\":1}}],[\"末尾\",{\"1\":{\"231\":1}}],[\"匹配以\",{\"1\":{\"231\":2}}],[\"匹配当前目录下任何以\",{\"1\":{\"231\":1}}],[\"匹配的分区信息\",{\"1\":{\"216\":1}}],[\"含义\",{\"1\":{\"231\":1}}],[\"含义如下\",{\"1\":{\"217\":3}}],[\"规则\",{\"1\":{\"231\":1}}],[\"规范主要\",{\"1\":{\"64\":1}}],[\"晦涩难懂的代码尽量添加注释\",{\"1\":{\"231\":1}}],[\"遵循以下\",{\"1\":{\"231\":1}}],[\"书写原则\",{\"1\":{\"231\":2}}],[\"书非常厚而且知识偏理论\",{\"1\":{\"36\":1}}],[\"屏蔽构建环境异构\",{\"1\":{\"231\":1}}],[\"易于版本化管理\",{\"1\":{\"231\":1}}],[\"域名访问宿主机\",{\"1\":{\"230\":1}}],[\"域名系统\",{\"1\":{\"8\":2}}],[\"守护程序仅接收来自提供\",{\"1\":{\"225\":1}}],[\"守护着一个hashentry数组里的元素\",{\"1\":{\"83\":1}}],[\"邮箱\",{\"1\":{\"223\":1}}],[\"密码\",{\"1\":{\"219\":1,\"223\":1}}],[\"密钥成对出现\",{\"1\":{\"35\":1}}],[\"密钥只有一个\",{\"1\":{\"35\":1}}],[\"停掉容器再删除容器\",{\"1\":{\"219\":1}}],[\"停止容器\",{\"1\":{\"217\":1}}],[\"停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认\",{\"1\":{\"23\":1}}],[\"停止等待协议是为了实现可靠传输的\",{\"1\":{\"23\":1}}],[\"停止等待arq协议\",{\"0\":{\"23\":1}}],[\"挂载logstash的配置文件\",{\"1\":{\"219\":1}}],[\"挂起当前事务\",{\"1\":{\"64\":2}}],[\"插件文件挂载\",{\"1\":{\"219\":1}}],[\"插入和删除元素的话\",{\"1\":{\"68\":1}}],[\"插入和删除是否受元素位置的影响\",{\"1\":{\"68\":1}}],[\"插入\",{\"1\":{\"64\":1}}],[\"插入时把自己加到header\",{\"1\":{\"64\":1}}],[\"插入排序\",{\"0\":{\"2\":1}}],[\"稍微配置大点\",{\"1\":{\"219\":1}}],[\"覆盖容器启动后默认执行的启动mysql命令\",{\"1\":{\"219\":1}}],[\"覆盖容器启动后默认执行的命令\",{\"1\":{\"219\":1}}],[\"~\",{\"1\":{\"219\":1}}],[\"~15\",{\"1\":{\"94\":1}}],[\"卷挂载路径设置\",{\"1\":{\"219\":1}}],[\"暴露端口\",{\"1\":{\"219\":1}}],[\"暴露端口信息\",{\"1\":{\"219\":1}}],[\"示例链接\",{\"1\":{\"231\":1}}],[\"示例\",{\"1\":{\"219\":12}}],[\"示例代码\",{\"1\":{\"64\":1}}],[\"命名\",{\"1\":{\"219\":1}}],[\"命令和校验和完全一致\",{\"1\":{\"231\":1}}],[\"命令行中\",{\"1\":{\"230\":1}}],[\"命令描述了对容器的操作\",{\"1\":{\"219\":1}}],[\"命令操作即可\",{\"1\":{\"219\":1}}],[\"命令会每隔\",{\"1\":{\"218\":1}}],[\"命令最后的点\",{\"1\":{\"218\":1}}],[\"命令查看你当前的内核版本\",{\"1\":{\"217\":1}}],[\"命令\",{\"1\":{\"170\":1,\"218\":1,\"231\":1}}],[\"命令以及\",{\"1\":{\"51\":1}}],[\"`rpm\",{\"1\":{\"219\":1}}],[\"磁盘\",{\"1\":{\"218\":1}}],[\"秒钟刷新一次输出的内容直到你按下\",{\"1\":{\"218\":1}}],[\"技术详解\",{\"1\":{\"218\":1}}],[\"底下的只读层就是image\",{\"1\":{\"218\":1}}],[\"底层镜像尽量使用工具较多的镜像\",{\"1\":{\"245\":1}}],[\"底层的目录叫做lowerdir\",{\"1\":{\"218\":1}}],[\"底层的b+树是按照a\",{\"1\":{\"216\":1}}],[\"底层都是基于两阶段提交理论来实现的\",{\"1\":{\"216\":1}}],[\"底层并没有真正支持\",{\"1\":{\"216\":2}}],[\"底层为数组\",{\"1\":{\"98\":1}}],[\"底层具体实现\",{\"0\":{\"82\":1}}],[\"底层采用的是平滑加权轮询算法\",{\"1\":{\"216\":1}}],[\"底层采用\",{\"1\":{\"81\":1,\"89\":1}}],[\"底层就是基于\",{\"1\":{\"74\":1}}],[\"底层使用的是\",{\"1\":{\"68\":2}}],[\"底层数据结构\",{\"1\":{\"68\":1,\"73\":1,\"81\":1}}],[\"底层实现是怎么样的\",{\"1\":{\"64\":1}}],[\"底层原理就是通过某台机器在某一毫秒内对某一个数字自增\",{\"1\":{\"216\":1}}],[\"底层原理\",{\"1\":{\"64\":1}}],[\"底层是通过操作系统的内存屏障来实现的\",{\"1\":{\"216\":1}}],[\"底层是这样的\",{\"1\":{\"216\":1}}],[\"底层是\",{\"1\":{\"77\":1}}],[\"底层是链表\",{\"1\":{\"69\":1}}],[\"底层是数组\",{\"1\":{\"69\":1}}],[\"底层是怎么实现的\",{\"1\":{\"64\":2}}],[\"底层是用tcp还是udp\",{\"0\":{\"62\":1}}],[\"顶层的目录称之为upperdir\",{\"1\":{\"218\":1}}],[\"顶级域名服务器缓存\",{\"1\":{\"44\":1}}],[\"顶级域名服务器发送一个请求\",{\"1\":{\"42\":1}}],[\"终端将会输出如下的内容\",{\"1\":{\"218\":1}}],[\"声明容器对外暴露的端口\",{\"1\":{\"219\":1}}],[\"声明容器在运行时对外提供的服务端口\",{\"1\":{\"218\":1}}],[\"声明需要暴露的端口\",{\"1\":{\"218\":1}}],[\"格式跟links类似\",{\"1\":{\"219\":1}}],[\"格式\",{\"1\":{\"218\":1,\"231\":1}}],[\"格式为\",{\"1\":{\"218\":1}}],[\"格式如下\",{\"1\":{\"50\":1,\"219\":1}}],[\"拷贝文件\",{\"1\":{\"218\":1}}],[\"换成\",{\"1\":{\"217\":1}}],[\"换句话说使用扰动函数之后可以减少碰撞\",{\"1\":{\"77\":1}}],[\"宿主机ip\",{\"1\":{\"219\":2}}],[\"宿主机的相应路径\",{\"1\":{\"217\":1}}],[\"宿主机端口\",{\"1\":{\"217\":1}}],[\"告诉\",{\"1\":{\"217\":1}}],[\"搜索镜像\",{\"1\":{\"217\":1}}],[\"卸载docker\",{\"1\":{\"217\":1}}],[\"卸载旧版本\",{\"1\":{\"217\":1}}],[\"登录阿里云\",{\"1\":{\"217\":1}}],[\"验证安装是否成功\",{\"1\":{\"217\":1}}],[\"启动后不退出当前窗口\",{\"1\":{\"254\":1}}],[\"启动\",{\"1\":{\"231\":1}}],[\"启动compose的所有微服务容器\",{\"1\":{\"219\":1}}],[\"启动compose所有容器\",{\"1\":{\"219\":1}}],[\"启动了eureka服务的1个容器实例\",{\"1\":{\"219\":1}}],[\"启动容器\",{\"1\":{\"219\":1}}],[\"启动镜像\",{\"1\":{\"218\":1}}],[\"启动已停止的容器\",{\"1\":{\"217\":1}}],[\"启动并加入开机启动\",{\"1\":{\"217\":1}}],[\"启动类加载器\",{\"1\":{\"64\":1}}],[\"安装软件指令放前面\",{\"1\":{\"231\":1}}],[\"安装ifconfig\",{\"1\":{\"217\":1}}],[\"安装ping\",{\"1\":{\"217\":1}}],[\"安装vim\",{\"1\":{\"217\":1}}],[\"安装docker\",{\"1\":{\"217\":1}}],[\"安装需要的软件包\",{\"1\":{\"217\":1}}],[\"安全检查\",{\"1\":{\"64\":1}}],[\"安全限制\",{\"1\":{\"64\":1}}],[\"安全性没有\",{\"1\":{\"35\":1}}],[\"安全性和资源消耗\",{\"1\":{\"35\":1}}],[\"安全性更高\",{\"1\":{\"32\":1}}],[\"企业版包含了一些收费服务\",{\"1\":{\"217\":1}}],[\"缩写为\",{\"1\":{\"217\":2}}],[\"社区版\",{\"1\":{\"217\":1}}],[\"移动\",{\"1\":{\"217\":1}}],[\"移除了在\",{\"1\":{\"64\":1}}],[\"改变了高性能必然高价格的思维定势\",{\"1\":{\"217\":1}}],[\"云计算时代到来\",{\"1\":{\"217\":1}}],[\"帮你\",{\"1\":{\"217\":1}}],[\"帮助大家理解它\",{\"1\":{\"217\":1}}],[\"便可以实现虚拟化\",{\"1\":{\"217\":1}}],[\"便于统一管理\",{\"1\":{\"216\":1}}],[\"教你如何将它用于日常开发\",{\"1\":{\"217\":1}}],[\"今天就来详细解释\",{\"1\":{\"217\":1}}],[\"许多人并不清楚\",{\"1\":{\"217\":1}}],[\"算出两层和三层时能存储的数据条数\",{\"1\":{\"216\":1}}],[\"算法\",{\"0\":{\"208\":1},\"1\":{\"64\":2,\"216\":1}}],[\"算法参见\",{\"1\":{\"64\":1}}],[\"假设一行数据为1kb\",{\"1\":{\"216\":1}}],[\"假如某一时刻访问redis的大量key都在redis中不存在\",{\"1\":{\"216\":1}}],[\"假如服务a本身能抗住这些请求\",{\"1\":{\"216\":1}}],[\"假如你去银行取钱\",{\"1\":{\"216\":1}}],[\"假如你的项目出现性能瓶颈了\",{\"1\":{\"64\":2}}],[\"址\",{\"1\":{\"216\":10}}],[\"范围查找等sql语句\",{\"1\":{\"216\":1}}],[\"某些子查询会被优化为join查询\",{\"1\":{\"216\":1}}],[\"某个表经过搜索条件过滤后剩余记录条数的百分比\",{\"1\":{\"216\":1}}],[\"某个自动配置类或某个bean是否真正生效\",{\"1\":{\"216\":1}}],[\"某个进程杀不掉的原因\",{\"1\":{\"64\":1}}],[\"描述\",{\"1\":{\"216\":1}}],[\"描述一下arraylist和linkedlist各自实现和区别\",{\"1\":{\"64\":1}}],[\"步骤是\",{\"1\":{\"216\":1}}],[\"载入收到的rdb文件中的数据\",{\"1\":{\"216\":1}}],[\"期间不进行线程切换\",{\"1\":{\"216\":1}}],[\"申请的内存可以重用\",{\"1\":{\"216\":1}}],[\"申请了哪些内存\",{\"1\":{\"64\":1}}],[\"零拷贝指的是\",{\"1\":{\"216\":1}}],[\"零拷贝是什么\",{\"1\":{\"216\":1}}],[\"熔断是下游服务故障触发的\",{\"1\":{\"216\":1}}],[\"熔断机制的注解是\",{\"1\":{\"64\":1}}],[\"熔断机制通过hystrix实现\",{\"1\":{\"64\":1}}],[\"层是在传输层之上封装了\",{\"1\":{\"216\":1}}],[\"层只负责单向消息传输\",{\"1\":{\"216\":1}}],[\"层封装了所有接口的透明化代理\",{\"1\":{\"216\":1}}],[\"层\",{\"1\":{\"216\":2}}],[\"伪装成一个\",{\"1\":{\"216\":1}}],[\"划分逻辑拓普节点\",{\"1\":{\"216\":1}}],[\"拦截点\",{\"1\":{\"216\":1}}],[\"抽象\",{\"1\":{\"216\":1}}],[\"监控层\",{\"1\":{\"216\":1}}],[\"监听动态配置中心的变更\",{\"1\":{\"216\":1}}],[\"封装了原生nio编码的复杂度\",{\"1\":{\"216\":1}}],[\"封装请求响应模式\",{\"1\":{\"216\":1}}],[\"封装\",{\"1\":{\"216\":1}}],[\"封装多个提供者的路由及负载均衡\",{\"1\":{\"216\":1}}],[\"封装服务地址的注册与发现\",{\"1\":{\"216\":1}}],[\"路由层\",{\"1\":{\"216\":1}}],[\"路由器缓存\",{\"1\":{\"44\":1}}],[\"●而\",{\"1\":{\"216\":2}}],[\"●图中的\",{\"1\":{\"216\":1}}],[\"●在\",{\"1\":{\"216\":1}}],[\"●在mysql8中\",{\"1\":{\"216\":1}}],[\"●在mysql7中\",{\"1\":{\"216\":1}}],[\"●serialize\",{\"1\":{\"216\":1}}],[\"●transport\",{\"1\":{\"216\":1}}],[\"●exchange\",{\"1\":{\"216\":1}}],[\"●protocol\",{\"1\":{\"216\":1}}],[\"●proxy\",{\"1\":{\"216\":2}}],[\"●monitor\",{\"1\":{\"216\":1}}],[\"●cluster\",{\"1\":{\"216\":1}}],[\"●config\",{\"1\":{\"216\":1}}],[\"●registry\",{\"1\":{\"216\":2}}],[\"阿里开源的分布式事务框架\",{\"1\":{\"216\":1}}],[\"阿里云redis多线程性能提升思路解析\",{\"1\":{\"64\":1}}],[\"阿里云\",{\"1\":{\"64\":1}}],[\"阿里云面试分享\",{\"1\":{\"64\":1}}],[\"阿里云面试题\",{\"0\":{\"64\":1}}],[\"订单创建与减库存应该是要同时成功或同时失败的\",{\"1\":{\"216\":1}}],[\"订阅\",{\"1\":{\"64\":1}}],[\"库存系统减库存\",{\"1\":{\"216\":1}}],[\"意思就是消息不能丢失\",{\"1\":{\"216\":1}}],[\"意思就是\",{\"1\":{\"216\":1}}],[\"遇到资源竞争时\",{\"1\":{\"216\":1}}],[\"遇到网络问题\",{\"1\":{\"64\":1}}],[\"业界存在tinyid\",{\"1\":{\"216\":1}}],[\"业务出错\",{\"1\":{\"216\":1}}],[\"业务类型由终端tcp或udp端口地址来决定\",{\"1\":{\"64\":1}}],[\"业务操作完成后\",{\"1\":{\"64\":1}}],[\"允许在经过一段时间后再达到一致\",{\"1\":{\"216\":1}}],[\"允许有重复的元素\",{\"1\":{\"64\":1}}],[\"强制删除所有容器\",{\"1\":{\"217\":1}}],[\"强制删除加\",{\"1\":{\"217\":1}}],[\"强制停止容器\",{\"1\":{\"217\":1}}],[\"强一致性表示\",{\"1\":{\"216\":1}}],[\"强调事务的不可分割\",{\"1\":{\"64\":1}}],[\"替换成变量的值\",{\"1\":{\"216\":1}}],[\"替换为\",{\"1\":{\"216\":1}}],[\"号进程\",{\"1\":{\"231\":1,\"237\":1}}],[\"号进程就是\",{\"1\":{\"231\":1}}],[\"号\",{\"1\":{\"216\":1,\"218\":1}}],[\"号称是最占内存的数据结构\",{\"1\":{\"64\":1}}],[\"尤其当字段多\",{\"1\":{\"216\":1}}],[\"尤其是altertable的时候会让日志暴涨\",{\"1\":{\"64\":1}}],[\"尤其是在移动设备上\",{\"1\":{\"57\":1}}],[\"很大的原因是生产者自己的原因\",{\"1\":{\"216\":1}}],[\"很好的集成\",{\"1\":{\"216\":1}}],[\"很多书里面都说java是进行传值调用\",{\"1\":{\"64\":1}}],[\"很多地方用到缓存\",{\"1\":{\"64\":1}}],[\"很多很多\",{\"1\":{\"64\":1}}],[\"视图解析器\",{\"1\":{\"216\":1}}],[\"视频\",{\"1\":{\"20\":1}}],[\"收到请求调用\",{\"1\":{\"216\":1}}],[\"收到这个\",{\"1\":{\"18\":1}}],[\"判新某个bean能不能用来进行依赖注入强可以认为也是责任链\",{\"1\":{\"216\":1}}],[\"判断是否超过阈值\",{\"1\":{\"216\":1}}],[\"判断两个对象是不是同一个对象\",{\"1\":{\"96\":1}}],[\"判断当前元素存放的位置\",{\"1\":{\"77\":1}}],[\"判断链表中是否有环\",{\"1\":{\"64\":2}}],[\"判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对\",{\"1\":{\"64\":1}}],[\"判断做的事情的复杂度\",{\"1\":{\"64\":1}}],[\"责任链模式\",{\"1\":{\"216\":1}}],[\"方便存放在代码仓库做版本管理\",{\"1\":{\"231\":1}}],[\"方便快捷已经是\",{\"1\":{\"217\":1}}],[\"方式生成了代理对象的地方就用到了代理模式\",{\"1\":{\"216\":1}}],[\"方法区中的静态变量\",{\"1\":{\"216\":1}}],[\"方法执行完之后\",{\"1\":{\"216\":1}}],[\"方法时\",{\"1\":{\"216\":2}}],[\"方法也没有返回值\",{\"1\":{\"216\":1}}],[\"方法也就是扰动函数是为了防止一些实现比较差的\",{\"1\":{\"77\":1}}],[\"方法加锁时\",{\"1\":{\"216\":1}}],[\"方法可以设置一个超时时间\",{\"1\":{\"216\":1}}],[\"方法或take\",{\"1\":{\"216\":1}}],[\"方法或compare\",{\"1\":{\"85\":1}}],[\"方法比较的是对象的值\",{\"1\":{\"96\":1}}],[\"方法是比较的对象的内存地址\",{\"1\":{\"96\":1}}],[\"方法是被重写过的\",{\"1\":{\"96\":1}}],[\"方法来释放许可\",{\"1\":{\"216\":1}}],[\"方法来对countdownlatch中的数字减一\",{\"1\":{\"216\":1}}],[\"方法来比较两个对象的内容是否相等\",{\"1\":{\"96\":1}}],[\"方法来检查hashcode相等的对象是否真的相同\",{\"1\":{\"75\":1}}],[\"方法和使用自制的comparator方法或者以两个comparator来实现歌名排序和歌星名排序\",{\"1\":{\"85\":1}}],[\"方法用来排序\",{\"1\":{\"85\":2}}],[\"方法用来判断对象的相等性\",{\"1\":{\"74\":1}}],[\"方法更加简化\",{\"1\":{\"77\":1}}],[\"方法源码\",{\"1\":{\"77\":2}}],[\"方法向set中添加元素\",{\"1\":{\"74\":1}}],[\"方法保证\",{\"1\":{\"73\":1}}],[\"方法中会执行sql\",{\"1\":{\"216\":1}}],[\"方法中\",{\"1\":{\"69\":1}}],[\"方法的线程会利用aqs排队\",{\"1\":{\"216\":1}}],[\"方法的区别\",{\"1\":{\"216\":1}}],[\"方法的性能会稍差一点点\",{\"1\":{\"77\":1}}],[\"方法的插入\",{\"1\":{\"68\":1}}],[\"方法的时候\",{\"1\":{\"68\":1}}],[\"方法手动设置消费位置\",{\"1\":{\"64\":1}}],[\"方法调用时间\",{\"1\":{\"64\":1}}],[\"方法返回值等等\",{\"1\":{\"64\":1}}],[\"方法才能被唤醒\",{\"1\":{\"64\":1}}],[\"方法阻塞\",{\"1\":{\"64\":1}}],[\"方法\",{\"1\":{\"64\":9,\"68\":1,\"69\":2,\"77\":3,\"85\":1,\"96\":2,\"216\":1}}],[\"方法二\",{\"1\":{\"64\":1}}],[\"方法一\",{\"1\":{\"64\":1}}],[\"装饰器模式回\",{\"1\":{\"216\":1}}],[\"装饰者模式\",{\"1\":{\"64\":1}}],[\"构建时的缓存特性\",{\"1\":{\"231\":1}}],[\"构建时判断是否需要使用缓存的规则如下\",{\"1\":{\"231\":1}}],[\"构建时可以使用换行符来解析文件定义\",{\"1\":{\"231\":1}}],[\"构建过程中\",{\"1\":{\"231\":1}}],[\"构建结果都一致\",{\"1\":{\"231\":1}}],[\"构建镜像的整体时间原则上也一样\",{\"1\":{\"238\":1}}],[\"构建镜像无须考虑构建环境\",{\"1\":{\"231\":1}}],[\"构建镜像可以带来很多好处\",{\"1\":{\"231\":1}}],[\"构建镜像阶段执行命令\",{\"1\":{\"218\":1}}],[\"构建完\",{\"1\":{\"217\":1}}],[\"构建器模式\",{\"1\":{\"216\":1}}],[\"构成一个环\",{\"1\":{\"70\":1}}],[\"依赖注入就是通过beanpostprocessor来实现的\",{\"1\":{\"216\":1}}],[\"依次选择服务提供者来处理请求\",{\"1\":{\"216\":1}}],[\"依次递归\",{\"1\":{\"64\":1}}],[\"依次类推下去\",{\"1\":{\"42\":1}}],[\"属性值进行替换\",{\"1\":{\"225\":1}}],[\"属性访问器\",{\"1\":{\"216\":1}}],[\"属性填充\",{\"1\":{\"216\":1}}],[\"属性配置\",{\"1\":{\"64\":1}}],[\"扫描得到所有的beandefinition对象\",{\"1\":{\"216\":1}}],[\"扫播\",{\"1\":{\"216\":1}}],[\"禁止此连接的自动提交\",{\"1\":{\"216\":1}}],[\"维护量之大可想而知\",{\"1\":{\"219\":1}}],[\"维护bean\",{\"1\":{\"216\":1}}],[\"维护了一个排序顺序\",{\"1\":{\"64\":2}}],[\"汽历单哥beandefinition\",{\"1\":{\"216\":1}}],[\"扭始合化\",{\"1\":{\"216\":1}}],[\"垃充属性\",{\"1\":{\"216\":1}}],[\"垃充属性后\",{\"1\":{\"216\":1}}],[\"垃圾\",{\"1\":{\"216\":2}}],[\"垃圾回收\",{\"1\":{\"64\":2}}],[\"垃圾回收器都会进行清理来释放内存\",{\"1\":{\"64\":1}}],[\"垃圾回收器从被称为gc\",{\"1\":{\"64\":1}}],[\"垃圾收集机制\",{\"1\":{\"64\":1}}],[\"垃圾收集器\",{\"1\":{\"64\":3}}],[\"垃圾收集算法\",{\"1\":{\"64\":3}}],[\"填充二性\",{\"1\":{\"216\":1}}],[\"填充口性\",{\"1\":{\"216\":1}}],[\"合理选择基础镜像\",{\"1\":{\"231\":1}}],[\"合井beandefinition\",{\"1\":{\"216\":1}}],[\"合并结果集\",{\"0\":{\"116\":1}}],[\"历beandefinitionmap\",{\"1\":{\"216\":1}}],[\"减轻服务a和服务b的压力\",{\"1\":{\"216\":1}}],[\"减轻了程序员的负担\",{\"1\":{\"216\":1}}],[\"减少垃圾收集时的停顿时间\",{\"1\":{\"64\":1}}],[\"减少容器的解析\",{\"1\":{\"64\":1}}],[\"减少直接使用hibernate等工具的直接生成语句\",{\"1\":{\"64\":1}}],[\"减少额外的开销\",{\"1\":{\"64\":1}}],[\"减少了\",{\"1\":{\"216\":1}}],[\"减少了binlog日志量\",{\"1\":{\"64\":1}}],[\"减少了内存的开销\",{\"1\":{\"64\":1}}],[\"减少响应内容大小\",{\"1\":{\"58\":1}}],[\"减少数据的发送\",{\"1\":{\"21\":1}}],[\"谈谈你对ioc的理解\",{\"1\":{\"216\":1}}],[\"谈谈concurrenthashmap1\",{\"1\":{\"64\":2}}],[\"交换机\",{\"1\":{\"216\":1}}],[\"名字叫做webappclassloader\",{\"1\":{\"216\":1}}],[\"推过来多少消息\",{\"1\":{\"216\":1}}],[\"推断构造方法\",{\"1\":{\"216\":1}}],[\"推断梅造方法\",{\"1\":{\"216\":1}}],[\"推理\",{\"1\":{\"216\":1}}],[\"推荐使用多阶段编译的方式\",{\"1\":{\"252\":1}}],[\"推荐使用\",{\"1\":{\"231\":1}}],[\"推荐使用cmd指令\",{\"1\":{\"231\":1}}],[\"推荐使用zookeeper注册中心\",{\"1\":{\"64\":1}}],[\"推荐的使用格式\",{\"1\":{\"231\":1}}],[\"推荐阅读\",{\"1\":{\"78\":1}}],[\"推荐一篇讲的比较细致的文章\",{\"1\":{\"19\":1}}],[\"占用cpu高\",{\"1\":{\"216\":1}}],[\"尝试加大年轻代的大小\",{\"1\":{\"216\":1}}],[\"初步猜测频繁发生fullgc的原因\",{\"1\":{\"216\":1}}],[\"初始容量大小和每次扩充容量大小的不同\",{\"1\":{\"73\":1}}],[\"初始化后等步骤\",{\"1\":{\"216\":1}}],[\"初始化后\",{\"1\":{\"216\":1}}],[\"初始化前\",{\"1\":{\"216\":2}}],[\"初始化\",{\"1\":{\"216\":3}}],[\"初始化一个可以缓存线程的线程池\",{\"1\":{\"64\":1}}],[\"初始化一个指定线程数的线程池\",{\"1\":{\"64\":1}}],[\"初始化或请求停机\",{\"1\":{\"64\":1}}],[\"留给程序员进行扩展\",{\"1\":{\"216\":1}}],[\"既不能多也不能少\",{\"1\":{\"216\":1}}],[\"既可以当做栈\",{\"1\":{\"216\":1}}],[\"既接受新任务\",{\"1\":{\"216\":1}}],[\"既然add指令支持的功能更多\",{\"1\":{\"231\":1}}],[\"既然是默认情况下\",{\"1\":{\"42\":1}}],[\"既然\",{\"1\":{\"31\":1}}],[\"气十炎下肉情无上\",{\"1\":{\"216\":1}}],[\"饮i否w>sk六虾杯\",{\"1\":{\"216\":1}}],[\"办新一个五气料\",{\"1\":{\"216\":1}}],[\"梅\",{\"1\":{\"216\":1}}],[\"太\",{\"1\":{\"216\":1}}],[\"血皮制古hull\",{\"1\":{\"216\":1}}],[\"凯艾\",{\"1\":{\"216\":1}}],[\"星河曲力\",{\"1\":{\"216\":1}}],[\"户川不的的品制构设堂\",{\"1\":{\"216\":1}}],[\"立风完大务家代\",{\"1\":{\"216\":1}}],[\"啦\",{\"1\":{\"216\":1}}],[\"营列巾口航标\",{\"1\":{\"216\":1}}],[\"人队日名\",{\"1\":{\"216\":1}}],[\"人工补偿\",{\"1\":{\"64\":1}}],[\"入队应功\",{\"1\":{\"216\":1}}],[\"千配6\",{\"1\":{\"216\":1}}],[\"千万不要使用普通for循环\",{\"1\":{\"69\":1}}],[\"姐一个程\",{\"1\":{\"216\":1}}],[\"刀始入射\",{\"1\":{\"216\":1}}],[\"干\",{\"1\":{\"216\":1}}],[\"手动清楚entry对象\",{\"1\":{\"216\":1}}],[\"手动调用threadlocal的remove方法\",{\"1\":{\"216\":1}}],[\"手舞足蹈\",{\"1\":{\"216\":1}}],[\"防止出现并发写入丢失数据的问题\",{\"1\":{\"216\":1}}],[\"防止包丢失\",{\"1\":{\"21\":1}}],[\"添加文件\",{\"1\":{\"218\":1}}],[\"添加adi享件等\",{\"1\":{\"216\":1}}],[\"添加\",{\"1\":{\"216\":1,\"230\":2}}],[\"添加到字符串常量池中\",{\"1\":{\"216\":1}}],[\"添加元素\",{\"1\":{\"81\":2}}],[\"符合所定义的条件才生效\",{\"1\":{\"216\":1}}],[\"除开要添加相关的依赖包之外\",{\"1\":{\"216\":1}}],[\"除此之外\",{\"1\":{\"64\":1}}],[\"除此之外其他任何类型的锁都不能再加了\",{\"1\":{\"64\":1}}],[\"代表任意一个字符\",{\"1\":{\"231\":1}}],[\"代表是把应用中的某个接口作为一个微服务注册到注册中心\",{\"1\":{\"216\":1}}],[\"代理对象执行某个方法时会恢次条过adisorchain中的每个adisor\",{\"1\":{\"216\":1}}],[\"代理模式\",{\"1\":{\"216\":1}}],[\"代码怎么实现\",{\"1\":{\"64\":1}}],[\"代码说话\",{\"1\":{\"64\":1}}],[\"代码的行为就有可能也随着变化\",{\"1\":{\"64\":1}}],[\"代码有功能上的错误\",{\"1\":{\"64\":1}}],[\"代码执行前浏览器必须保证\",{\"1\":{\"57\":1}}],[\"目录树结构如下\",{\"1\":{\"219\":1}}],[\"目的就是防止请求可以直接从缓存中获取到数据\",{\"1\":{\"216\":1}}],[\"目的是检测数据在传输过程中的任何变化\",{\"1\":{\"21\":1}}],[\"目前rocketmq中支持事务消息\",{\"1\":{\"216\":1}}],[\"目前主流的分布式锁的实现方案有两种\",{\"1\":{\"216\":1}}],[\"目前dubbo3\",{\"1\":{\"216\":1}}],[\"目前大部分的微服务框架都是应用级注册\",{\"1\":{\"216\":1}}],[\"机器上\",{\"1\":{\"217\":1}}],[\"机房1内的三台服务器会进行领导者选举\",{\"1\":{\"216\":1}}],[\"机制\",{\"1\":{\"64\":1}}],[\"机制的存在就是为了解决这个问题\",{\"1\":{\"31\":1}}],[\"领导者选举的过程中至少要有三台zkserver投了同一个zkserver\",{\"1\":{\"216\":1}}],[\"领取java工程师必备学习资料+面试突击pdf\",{\"1\":{\"6\":1,\"66\":1,\"75\":1}}],[\"刚刚在说明脑裂场景时\",{\"1\":{\"216\":1}}],[\"断了的网络突然联通了\",{\"1\":{\"216\":1}}],[\"断开一个\",{\"1\":{\"18\":1}}],[\"部署在了两个机房\",{\"1\":{\"216\":1}}],[\"想用其他的ioc容器时\",{\"1\":{\"216\":1}}],[\"想要提高这个集群的可用性\",{\"1\":{\"216\":1}}],[\"想提高数据集合的查询速度\",{\"1\":{\"216\":1}}],[\"本身是一个文本文件\",{\"1\":{\"231\":1}}],[\"本文讲解通过shell安装的方式\",{\"1\":{\"219\":1}}],[\"本节课将讨论如何使用\",{\"1\":{\"219\":1}}],[\"本篇文章着重来给大家讲一下zookeeper中的脑裂问题\",{\"1\":{\"216\":1}}],[\"本地方法栈中的变量\",{\"1\":{\"216\":1}}],[\"本地方法栈\",{\"1\":{\"216\":1}}],[\"本地消息表\",{\"1\":{\"64\":1}}],[\"本地域名会向\",{\"1\":{\"42\":1}}],[\"本地域名服务器会向根域名服务器发送一个请求\",{\"1\":{\"42\":1}}],[\"脑裂通常会出现在集群环境中\",{\"1\":{\"216\":1}}],[\"脑裂\",{\"1\":{\"216\":1}}],[\"周瑜\",{\"1\":{\"216\":8}}],[\"剩余任务都处理完之后\",{\"1\":{\"216\":1}}],[\"小方司\",{\"1\":{\"216\":1}}],[\"小的在右\",{\"1\":{\"216\":1}}],[\"小的在下\",{\"1\":{\"216\":1}}],[\"小红\",{\"1\":{\"87\":2}}],[\"感兴趣的同学可以关注一波公众号\",{\"1\":{\"216\":2}}],[\"顺序节点\",{\"1\":{\"216\":1}}],[\"顺序与插入顺序保持一致\",{\"1\":{\"216\":1}}],[\"顺序写入的话\",{\"1\":{\"64\":1}}],[\"细心的你应该可以发现\",{\"1\":{\"216\":1}}],[\"针对单表的查询方式\",{\"1\":{\"216\":1}}],[\"针对b\",{\"1\":{\"216\":1}}],[\"针对每个操作\",{\"1\":{\"64\":1}}],[\"降级是为了降低系统负载\",{\"1\":{\"216\":1}}],[\"降序索引底层实现\",{\"1\":{\"216\":1}}],[\"降序索引是索引的子集\",{\"1\":{\"216\":1}}],[\"降低了使用资源双方的依赖程度\",{\"1\":{\"64\":1}}],[\"降低可移植性\",{\"1\":{\"64\":1}}],[\"求树最大深度\",{\"0\":{\"214\":1}}],[\"求链表长度\",{\"0\":{\"209\":1}}],[\"遍历树\",{\"0\":{\"213\":1}}],[\"括号匹配问题\",{\"0\":{\"212\":1}}],[\"链路追踪\",{\"1\":{\"216\":2}}],[\"链路追踪你们怎么做的\",{\"0\":{\"203\":1}}],[\"链表节点\",{\"1\":{\"81\":1}}],[\"链表则是主要为了解决哈希冲突而存在的\",{\"1\":{\"81\":1,\"90\":2}}],[\"链表散列\",{\"1\":{\"77\":1}}],[\"链表需要遍历到特定位置才能访问特定位置的元素\",{\"1\":{\"69\":1}}],[\"链表\",{\"1\":{\"64\":2}}],[\"借用读写锁的思想\",{\"0\":{\"199\":1}}],[\"拆分你是怎么保证数据完整性的\",{\"0\":{\"194\":1}}],[\"拆包和装包是什么\",{\"0\":{\"124\":1}}],[\"买家卖家数据怎么存\",{\"0\":{\"192\":1}}],[\"淘宝场景\",{\"0\":{\"192\":1}}],[\"淘宝页面加载了\",{\"1\":{\"58\":1}}],[\"让协作者可以一目了然地知道每一行代码的作用\",{\"1\":{\"231\":1}}],[\"让协作者清楚地了解镜像的完整构建流程\",{\"1\":{\"231\":1}}],[\"让云空间得到更充分的利用\",{\"1\":{\"217\":1}}],[\"让开发者可以打包他们的应用以及依赖包到一个可移植的容器中\",{\"1\":{\"217\":1}}],[\"让子类来实现\",{\"1\":{\"216\":1}}],[\"让默\",{\"1\":{\"216\":1}}],[\"让你实现一个jvm\",{\"0\":{\"190\":1}}],[\"让java也可以像脚本语言一样来运行\",{\"1\":{\"64\":1}}],[\"俩种方式\",{\"0\":{\"173\":1}}],[\"适配器模式\",{\"1\":{\"216\":1}}],[\"适合使用\",{\"1\":{\"172\":1}}],[\"适用\",{\"1\":{\"94\":3}}],[\"适用于应用服务器\",{\"1\":{\"64\":1}}],[\"适用于科学技术和后台处理等\",{\"1\":{\"64\":1}}],[\"适用于何种场景\",{\"1\":{\"64\":2}}],[\"弹幕消息\",{\"1\":{\"172\":1}}],[\"共同喜好等功能\",{\"1\":{\"171\":1}}],[\"共同粉丝\",{\"1\":{\"171\":1}}],[\"共享内存方式的优缺点\",{\"1\":{\"64\":1}}],[\"共享内存\",{\"1\":{\"64\":3}}],[\"共享锁又叫做读锁\",{\"1\":{\"64\":1}}],[\"共享锁\",{\"1\":{\"64\":6}}],[\"轻易实现交集\",{\"1\":{\"171\":1}}],[\"轻量级锁底层是通过自旋来实现的\",{\"1\":{\"216\":1}}],[\"轻量级锁\",{\"0\":{\"117\":1},\"1\":{\"216\":1}}],[\"粉丝列表\",{\"1\":{\"170\":1}}],[\"粉丝数等\",{\"1\":{\"168\":1}}],[\"商品信息等等\",{\"1\":{\"169\":1}}],[\"微博等消息流数据\",{\"1\":{\"216\":1}}],[\"微博数\",{\"1\":{\"168\":1}}],[\"微服务之间有什么关系和区别\",{\"1\":{\"216\":1}}],[\"微服务中什么是应用级注册\",{\"1\":{\"216\":1}}],[\"微服务再细一点\",{\"0\":{\"146\":1}}],[\"微服务和分布式区别\",{\"0\":{\"145\":1}}],[\"出题考你\",{\"0\":{\"159\":1}}],[\"出现了两个\",{\"1\":{\"216\":1}}],[\"出现瓶颈时\",{\"1\":{\"46\":1}}],[\"出现差错情况\",{\"1\":{\"23\":1}}],[\"索引覆盖就是一个sql在执行时\",{\"1\":{\"216\":1}}],[\"索引覆盖是什么\",{\"1\":{\"216\":1}}],[\"索引字段是b\",{\"1\":{\"216\":1}}],[\"索引是用来提高查询速度的\",{\"1\":{\"216\":1}}],[\"索引\",{\"0\":{\"154\":1},\"1\":{\"216\":1}}],[\"线上的修改配置文件的环境比如数据库配置\",{\"0\":{\"140\":1}}],[\"线程会阻塞住\",{\"1\":{\"216\":1}}],[\"线程会阻塞直到加到锁\",{\"1\":{\"216\":1}}],[\"线程将被终止\",{\"1\":{\"216\":1}}],[\"线程在使用lock\",{\"1\":{\"216\":1}}],[\"线程在一定条件下\",{\"1\":{\"64\":1}}],[\"线程之间不共享同一个连接\",{\"1\":{\"216\":1}}],[\"线程不会阻塞\",{\"1\":{\"216\":2}}],[\"线程不被回收\",{\"1\":{\"216\":1}}],[\"线程不安全\",{\"1\":{\"64\":1}}],[\"线程是否安全\",{\"1\":{\"73\":1}}],[\"线程自己基本上不拥有系统资源\",{\"1\":{\"64\":1}}],[\"线程\",{\"1\":{\"64\":2}}],[\"线程间通信\",{\"1\":{\"64\":1}}],[\"线程执行完了或者因异常退出了run\",{\"1\":{\"64\":1}}],[\"线程重新转入就绪状态\",{\"1\":{\"64\":1}}],[\"线程对象创建后\",{\"1\":{\"64\":1}}],[\"线程一共有以下几种状态\",{\"1\":{\"64\":1}}],[\"线程的几种状态\",{\"1\":{\"64\":1}}],[\"线程的生命周期\",{\"1\":{\"64\":2}}],[\"线程状态监控\",{\"1\":{\"64\":1}}],[\"线程信息监控\",{\"1\":{\"64\":1}}],[\"线程监控\",{\"1\":{\"64\":1}}],[\"线程读取变量的值需要从主存中读取\",{\"1\":{\"64\":1}}],[\"线程等待时间与线程cpu时间之比\",{\"1\":{\"64\":1}}],[\"线程空闲后的存活时长\",{\"1\":{\"64\":1}}],[\"线程池可以动态的调整池中的线程数\",{\"1\":{\"216\":1}}],[\"线程池内部是通过队列+线程实现的\",{\"1\":{\"216\":1}}],[\"线程池状态就会变为terminated\",{\"1\":{\"216\":1}}],[\"线程池既不会接受新任务了\",{\"1\":{\"216\":1}}],[\"线程池不会接受新任务了\",{\"1\":{\"216\":1}}],[\"线程池就进入stop状态\",{\"1\":{\"216\":1}}],[\"线程池就进入shutdown状态\",{\"1\":{\"216\":1}}],[\"线程池就从\",{\"1\":{\"64\":1}}],[\"线程池正常运行\",{\"1\":{\"216\":1}}],[\"线程池正常运行中\",{\"1\":{\"216\":1}}],[\"线程池有哪些状态\",{\"1\":{\"216\":1}}],[\"线程池有哪几种状态\",{\"1\":{\"216\":1}}],[\"线程池处于tidying状态后\",{\"1\":{\"216\":1}}],[\"线程池停止了\",{\"1\":{\"216\":1}}],[\"线程池关闭了\",{\"1\":{\"216\":1}}],[\"线程池中的线程会不断地的从阻塞队列中获取任务\",{\"1\":{\"216\":1}}],[\"线程池中的线程是如何保活和回收的\",{\"1\":{\"216\":1}}],[\"线程池了解吗\",{\"0\":{\"115\":1}}],[\"线程池的底层工作原理\",{\"1\":{\"216\":1}}],[\"线程池的状态就会自动变为tidying\",{\"1\":{\"216\":1}}],[\"线程池的线程数可达到integer\",{\"1\":{\"64\":1}}],[\"线程池的基础概念\",{\"1\":{\"64\":1}}],[\"线程池的原理\",{\"1\":{\"64\":2}}],[\"线程池究竟设置多大要看你的线程池执行的什么任务了\",{\"1\":{\"64\":1}}],[\"线程池大小分配\",{\"1\":{\"64\":1}}],[\"线程池任务满载后采取的任务拒绝策略\",{\"1\":{\"64\":1}}],[\"线程池最大容纳线程数\",{\"1\":{\"64\":1}}],[\"线程本地存储\",{\"1\":{\"64\":1}}],[\"线程安全容器的使用\",{\"1\":{\"216\":1}}],[\"线程安全性\",{\"1\":{\"94\":1}}],[\"线程安全问题都是由全局变量及静态变量引起的\",{\"1\":{\"64\":1}}],[\"线程安全\",{\"1\":{\"64\":3,\"94\":1}}],[\"幻读可详细说\",{\"0\":{\"137\":1}}],[\"限流是非常重要的\",{\"1\":{\"216\":1}}],[\"限流\",{\"0\":{\"130\":1}}],[\"限制容器的最大使用内存为500m\",{\"1\":{\"218\":1}}],[\"限制\",{\"1\":{\"64\":4}}],[\"削峰\",{\"0\":{\"130\":1}}],[\"偏向锁就会升级为轻量级锁\",{\"1\":{\"216\":1}}],[\"偏向锁\",{\"0\":{\"117\":1}}],[\"偏移量等\",{\"1\":{\"64\":1}}],[\"$basearch\",{\"1\":{\"231\":4}}],[\"$releasever\",{\"1\":{\"231\":8}}],[\"$path\",{\"1\":{\"231\":1}}],[\"$password\",{\"1\":{\"223\":4}}],[\"$server\",{\"1\":{\"223\":1}}],[\"$\",{\"0\":{\"105\":1},\"1\":{\"216\":1,\"217\":2,\"218\":1}}],[\"情况\",{\"1\":{\"96\":2}}],[\"左句镇0品宁\",{\"1\":{\"216\":1}}],[\"左右的性能提升\",{\"1\":{\"94\":1}}],[\"左指针指向相邻的地址虚拟存储区域\",{\"1\":{\"64\":1}}],[\"继承另一个服务\",{\"1\":{\"219\":1}}],[\"继承自\",{\"1\":{\"90\":1}}],[\"继承于\",{\"1\":{\"89\":1}}],[\"继续处理\",{\"1\":{\"54\":1}}],[\"唯一\",{\"1\":{\"89\":2}}],[\"唯一索引\",{\"1\":{\"64\":1}}],[\"王五\",{\"1\":{\"87\":2}}],[\"李四\",{\"1\":{\"87\":2}}],[\"张三\",{\"1\":{\"87\":2}}],[\"像integer类等都已经实现了comparable接口\",{\"1\":{\"87\":1}}],[\"像常访问的各个门户站点的新闻频道\",{\"1\":{\"64\":1}}],[\"转成接口\",{\"1\":{\"216\":1}}],[\"转换为红黑树\",{\"1\":{\"84\":1}}],[\"转化为红黑树\",{\"1\":{\"64\":2}}],[\"寻址时间复杂度为o\",{\"1\":{\"84\":2}}],[\"扮演锁的角色\",{\"1\":{\"83\":1}}],[\"竞争会越来越激烈效率越低\",{\"1\":{\"81\":1}}],[\"红黑二叉树节点\",{\"1\":{\"81\":1}}],[\"红黑二叉树\",{\"1\":{\"81\":1,\"84\":1}}],[\"红黑树就是为了解决二叉查找树的缺陷\",{\"1\":{\"78\":1}}],[\"红黑树\",{\"1\":{\"64\":1,\"89\":1,\"90\":1,\"216\":1}}],[\"红黑树的实现原理和应用场景\",{\"1\":{\"64\":2}}],[\"取余\",{\"1\":{\"79\":1}}],[\"取余的操作来实现\",{\"1\":{\"79\":1}}],[\"取值为2\",{\"1\":{\"64\":1}}],[\"取值为1\",{\"1\":{\"64\":1}}],[\"取值为0\",{\"1\":{\"64\":1}}],[\"得到的就是服务对应容器的ip\",{\"1\":{\"219\":1}}],[\"得到的余数才能用来要存放的位置也就是对应的数组下标\",{\"1\":{\"79\":1}}],[\"得到服务的提供者信息\",{\"1\":{\"216\":1}}],[\"得到当前所引用的服务名\",{\"1\":{\"216\":1}}],[\"得到一个servicebean\",{\"1\":{\"216\":1}}],[\"得到ip地址\",{\"1\":{\"216\":1}}],[\"得到结果如下\",{\"1\":{\"216\":2}}],[\"得到key的值的同时得到key所对应的值\",{\"1\":{\"87\":1}}],[\"得到正确的结果\",{\"1\":{\"64\":1}}],[\"次方\",{\"1\":{\"79\":1}}],[\"次\",{\"1\":{\"77\":1}}],[\"次怎么办\",{\"1\":{\"64\":1}}],[\"空位都以0补齐\",{\"1\":{\"77\":1}}],[\"空间复杂度\",{\"1\":{\"64\":1}}],[\"空间\",{\"1\":{\"64\":1}}],[\"忽略一些不需要参与构建的文件\",{\"1\":{\"231\":1}}],[\"忽略符号位\",{\"1\":{\"77\":1}}],[\"忽略kill信号\",{\"1\":{\"64\":1}}],[\"^=\",{\"1\":{\"77\":1}}],[\"^\",{\"1\":{\"77\":5}}],[\"综上\",{\"1\":{\"75\":1}}],[\"摘自我的java启蒙书\",{\"1\":{\"75\":1}}],[\"源码详细分析\",{\"1\":{\"90\":1}}],[\"源码的话就应该知道\",{\"1\":{\"74\":1}}],[\"源码分析spring\",{\"1\":{\"64\":1}}],[\"吧\",{\"1\":{\"73\":1}}],[\"详细比如相同对象比较\",{\"0\":{\"96\":1}}],[\"详细可以查看\",{\"1\":{\"90\":1}}],[\"详细可以查看string类的api文档\",{\"1\":{\"87\":1}}],[\"详情请查看\",{\"1\":{\"80\":1}}],[\"详见笔主的这篇文章\",{\"1\":{\"72\":1}}],[\"详解+实例\",{\"1\":{\"64\":1}}],[\"详解java内存泄露和如何避免内存泄漏\",{\"1\":{\"64\":1}}],[\"详解\",{\"1\":{\"64\":2}}],[\"详解和实例\",{\"1\":{\"64\":1}}],[\"包\",{\"1\":{\"231\":1}}],[\"包更新到最新\",{\"1\":{\"217\":1}}],[\"包它有一个compare\",{\"1\":{\"85\":1}}],[\"包含一个\",{\"1\":{\"83\":1}}],[\"包含两个指针\",{\"1\":{\"70\":1}}],[\"包括已停止的容器\",{\"1\":{\"217\":1}}],[\"包括定义的服务名\",{\"1\":{\"216\":1}}],[\"包括对象里的属性是什么时候赋的值\",{\"1\":{\"216\":1}}],[\"包括k8s也是应用注册\",{\"1\":{\"216\":1}}],[\"包括b+树到底是如何生成的\",{\"1\":{\"216\":2}}],[\"包括一些常用的队列的说明\",{\"0\":{\"118\":1}}],[\"包括gc什么的\",{\"0\":{\"109\":1}}],[\"包括tcp\",{\"1\":{\"64\":1}}],[\"包括局部变量\",{\"1\":{\"64\":1}}],[\"包括用户缓存\",{\"1\":{\"64\":1}}],[\"包括年轻代和永久代\",{\"1\":{\"64\":1}}],[\"补充\",{\"1\":{\"94\":1}}],[\"补充内容\",{\"0\":{\"70\":1}}],[\"补偿事务\",{\"1\":{\"64\":1}}],[\"未实现\",{\"1\":{\"69\":1}}],[\"未提交读\",{\"1\":{\"64\":1}}],[\"循环\",{\"1\":{\"69\":1}}],[\"循环注入\",{\"1\":{\"64\":1}}],[\"间浪费主要体现在在list列表的结尾会预留一定的容量空间\",{\"1\":{\"68\":1}}],[\"间的通信和交互的规则\",{\"1\":{\"8\":1}}],[\"近似\",{\"1\":{\"68\":1}}],[\"\\be\",{\"1\":{\"68\":1}}],[\"完全不进行限制\",{\"1\":{\"64\":1}}],[\"硬链接和软链接的区别\",{\"1\":{\"64\":1}}],[\"硬件四层交换\",{\"1\":{\"64\":1}}],[\"案例分析\",{\"1\":{\"64\":1}}],[\"关机或者重启机器时\",{\"1\":{\"219\":1}}],[\"关注的是网络数据的传输\",{\"1\":{\"216\":1}}],[\"关系说明\",{\"1\":{\"216\":1}}],[\"关系型数据库\",{\"1\":{\"64\":1}}],[\"关系型和非关系型数据库区别\",{\"1\":{\"64\":1}}],[\"关联表多时\",{\"1\":{\"216\":1}}],[\"关键问题是\",{\"1\":{\"216\":1}}],[\"关键字修饰\",{\"1\":{\"94\":1}}],[\"关键字修饰字符数组来保存字符串\",{\"1\":{\"94\":1}}],[\"关于overcommit\",{\"1\":{\"64\":1}}],[\"关闭或重启compose所有容器\",{\"1\":{\"219\":1}}],[\"关闭或启动或重启compose内的某个容器\",{\"1\":{\"219\":1}}],[\"关闭连接\",{\"1\":{\"64\":1}}],[\"关闭与客户端的连接\",{\"1\":{\"18\":1}}],[\"聚簇索引\",{\"1\":{\"64\":1}}],[\"隔离\",{\"1\":{\"64\":1}}],[\"隔离性\",{\"1\":{\"64\":1}}],[\"十\",{\"1\":{\"64\":1}}],[\"浅谈算法和数据结构\",{\"1\":{\"64\":1}}],[\"浅谈hotspot逃逸分析\",{\"1\":{\"64\":1}}],[\"效率又提升n倍\",{\"1\":{\"84\":1}}],[\"效率非常低下\",{\"1\":{\"81\":1}}],[\"效率高一点\",{\"1\":{\"73\":1}}],[\"效率\",{\"1\":{\"73\":1}}],[\"效率实现\",{\"1\":{\"64\":1}}],[\"效率最高\",{\"1\":{\"64\":1}}],[\"页地址对为16kb\",{\"1\":{\"216\":1}}],[\"页地\",{\"1\":{\"216\":10}}],[\"页数多了之后效率低\",{\"1\":{\"64\":1}}],[\"页面在首次加载时必然会经历\",{\"1\":{\"57\":1}}],[\"页面的方法\",{\"1\":{\"8\":1}}],[\"几乎没有性能损耗\",{\"1\":{\"218\":1}}],[\"几乎效率低下\",{\"1\":{\"64\":1}}],[\"几种方式\",{\"0\":{\"100\":1}}],[\"几秒才显示出物品\",{\"1\":{\"58\":1}}],[\"组成一个工程\",{\"1\":{\"219\":1}}],[\"组成这组操作的各个逻辑单元\",{\"1\":{\"64\":1}}],[\"组合索引遇到的几种方式不同\",{\"0\":{\"154\":1}}],[\"组合索引的区别\",{\"1\":{\"64\":1}}],[\"全表扫描\",{\"1\":{\"216\":1}}],[\"全量同步\",{\"1\":{\"216\":1}}],[\"全类名是可以相同的\",{\"1\":{\"216\":1}}],[\"全文索引\",{\"1\":{\"64\":1}}],[\"全局中声明\",{\"1\":{\"241\":1}}],[\"全局\",{\"1\":{\"64\":1}}],[\"普通索引\",{\"1\":{\"64\":1}}],[\"联合索引\",{\"1\":{\"64\":1}}],[\"返回容器当时的资源使用情况\",{\"1\":{\"218\":1}}],[\"返回容器资源的实时使用情况\",{\"1\":{\"218\":1}}],[\"返回给\",{\"1\":{\"216\":1}}],[\"返回散列值也就是hashcode\",{\"1\":{\"77\":1}}],[\"返回响应\",{\"1\":{\"64\":1}}],[\"返回的\",{\"1\":{\"45\":1}}],[\"访问宿主机的方式有所变化\",{\"1\":{\"230\":1}}],[\"访问接口参数参看视频\",{\"1\":{\"219\":1}}],[\"访问下微服务的api看是否都正常\",{\"1\":{\"219\":1}}],[\"访问不在同一个compose文件管理的服务需要用external\",{\"1\":{\"219\":2}}],[\"访问监控网页的登录用户名和密码\",{\"1\":{\"219\":1}}],[\"访问http\",{\"1\":{\"218\":1}}],[\"访问者模式\",{\"1\":{\"216\":1}}],[\"访问\",{\"1\":{\"64\":1,\"217\":1,\"218\":1,\"219\":1}}],[\"特点是什么\",{\"1\":{\"216\":1}}],[\"特别是对于那些提供共享容器或共同服务\",{\"1\":{\"219\":1}}],[\"特别是fullgc\",{\"1\":{\"216\":1}}],[\"特别适合用于存储对象\",{\"1\":{\"169\":1}}],[\"特殊之处在于\",{\"1\":{\"171\":1}}],[\"特定的浏览器和服务器对url的长度有限制\",{\"1\":{\"64\":1}}],[\"特性\",{\"1\":{\"64\":1}}],[\"参数才能覆盖\",{\"1\":{\"231\":1}}],[\"参数和依赖\",{\"1\":{\"219\":1}}],[\"参数也不会重新构建\",{\"1\":{\"219\":1}}],[\"参数可以强制先构建镜像\",{\"1\":{\"219\":1}}],[\"参数限制容器可以使用的最大内存\",{\"1\":{\"218\":1}}],[\"参数优化\",{\"1\":{\"64\":1}}],[\"参考\",{\"0\":{\"37\":1},\"1\":{\"64\":28}}],[\"性能有所提高\",{\"1\":{\"216\":1}}],[\"性能高\",{\"1\":{\"170\":1,\"216\":1}}],[\"性能\",{\"1\":{\"94\":1}}],[\"性能测试如何定位瓶颈\",{\"1\":{\"64\":1}}],[\"性能瓶颈出现的位置\",{\"1\":{\"64\":2}}],[\"海量积分数据实时排名处理\",{\"1\":{\"64\":1}}],[\"归并排序\",{\"1\":{\"64\":1}}],[\"较复杂\",{\"1\":{\"64\":5}}],[\"较好的方法是先探测一下\",{\"1\":{\"26\":1}}],[\"稳定\",{\"1\":{\"64\":4}}],[\"稳定性\",{\"1\":{\"64\":1}}],[\"哈希分治法\",{\"1\":{\"64\":1}}],[\"哈希槽\",{\"1\":{\"64\":1}}],[\"逆波兰计算器\",{\"1\":{\"64\":1}}],[\"队列\",{\"1\":{\"64\":1,\"216\":1}}],[\"队列用的是linkedblockingqueue无界队列\",{\"1\":{\"64\":1}}],[\"别的还有spring的spring\",{\"1\":{\"64\":1}}],[\"画一画服务注册与发现的流程图\",{\"1\":{\"64\":1}}],[\"速度就只有100kb每秒\",{\"1\":{\"64\":1}}],[\"据kafka官网吹\",{\"1\":{\"64\":1}}],[\"识别新节点何时离开或连接\",{\"1\":{\"64\":1}}],[\"追上\",{\"1\":{\"64\":1}}],[\"追踪collections\",{\"1\":{\"64\":1}}],[\"宕机\",{\"1\":{\"64\":1}}],[\"副本最后一条消息的offset与leader副本的最后一条消息的offset之间的差值不能超出指定的阈值\",{\"1\":{\"64\":1}}],[\"副本所在节点必须维持着与zookeeper的连接\",{\"1\":{\"64\":1}}],[\"语句依赖于数据库\",{\"1\":{\"216\":1}}],[\"语句的功底有一定要求\",{\"1\":{\"216\":1}}],[\"语句的编写工作量较大\",{\"1\":{\"216\":1}}],[\"语句编程\",{\"1\":{\"216\":1}}],[\"语义\",{\"1\":{\"64\":5,\"216\":1}}],[\"语义方案\",{\"1\":{\"64\":2}}],[\"语音\",{\"1\":{\"20\":1}}],[\"谁赋的\",{\"1\":{\"216\":1}}],[\"谁创建的\",{\"1\":{\"216\":1}}],[\"谁也不删\",{\"1\":{\"64\":1}}],[\"谁会被gc\",{\"1\":{\"64\":1}}],[\"辅以ttl\",{\"1\":{\"64\":1}}],[\"热加载\",{\"1\":{\"64\":2}}],[\"热点分析\",{\"1\":{\"64\":1}}],[\"肯定要比通过反射调用的时间更短\",{\"1\":{\"64\":1}}],[\"|=\",{\"1\":{\"73\":5}}],[\"|\",{\"1\":{\"64\":10,\"217\":1,\"219\":1}}],[\"||\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1,\"69\":1,\"73\":1}}],[\"及以上版本中\",{\"1\":{\"230\":1}}],[\"及注解说明\",{\"1\":{\"64\":1}}],[\"及concurrentskiplistmap源码解析\",{\"1\":{\"64\":1}}],[\"导致镜像文件过大\",{\"1\":{\"231\":1}}],[\"导致服务c请求堆积\",{\"1\":{\"216\":1}}],[\"导致数据库移植性差\",{\"1\":{\"216\":1}}],[\"导致年轻代放不下\",{\"1\":{\"216\":1}}],[\"导致follower副本中保存的消息略少于leader副本\",{\"1\":{\"64\":1}}],[\"导致的ygc不断变长\",{\"1\":{\"64\":1}}],[\"导致子进程停留在僵死状态等待其父进程为其收尸\",{\"1\":{\"64\":1}}],[\"探索stringtable提升ygc性能\",{\"1\":{\"64\":1}}],[\"碎片\",{\"1\":{\"64\":1}}],[\"电信领域等\",{\"1\":{\"64\":1}}],[\"响应用户\",{\"1\":{\"216\":1}}],[\"响应时间优先的并发收集器\",{\"1\":{\"64\":1}}],[\"响应报文\",{\"0\":{\"56\":1}}],[\"响应报文也是由三部分组成\",{\"1\":{\"53\":1}}],[\"响应报头\",{\"0\":{\"55\":1}}],[\"响应报头和响应报文\",{\"1\":{\"53\":1}}],[\"配置证书\",{\"0\":{\"221\":1}}],[\"配置dns的搜索域\",{\"1\":{\"219\":1}}],[\"配置dns服务器\",{\"1\":{\"219\":1}}],[\"配置容器启动后执行的命令\",{\"1\":{\"218\":1,\"219\":1}}],[\"配置中心的地址\",{\"1\":{\"219\":1}}],[\"配置中心\",{\"1\":{\"216\":3}}],[\"配置层\",{\"1\":{\"216\":1}}],[\"配置文件结尾的配置\",{\"1\":{\"219\":1}}],[\"配置文件挂载\",{\"1\":{\"219\":1}}],[\"配置文件\",{\"1\":{\"216\":4}}],[\"配置\",{\"1\":{\"216\":1}}],[\"配置管理\",{\"1\":{\"64\":1}}],[\"配置年老代垃圾收集方式为并行收集\",{\"1\":{\"64\":1}}],[\"配置并行收集器的线程数\",{\"1\":{\"64\":1}}],[\"配置sringaop环绕通知\",{\"1\":{\"64\":1}}],[\"年轻代使用并发收集\",{\"1\":{\"64\":1}}],[\"年代晋升失败\",{\"1\":{\"64\":1}}],[\"此节点就会投给zxid或myid更大的节点\",{\"1\":{\"216\":1}}],[\"此方案也不是最优方案\",{\"1\":{\"216\":1}}],[\"此集群只会有一个leader\",{\"1\":{\"216\":1}}],[\"此外\",{\"1\":{\"64\":1}}],[\"此follower副本会被leader副本重新加入到isr中\",{\"1\":{\"64\":1}}],[\"此时宿主机将会随机指定端口\",{\"1\":{\"219\":1}}],[\"此时可借助\",{\"1\":{\"217\":1}}],[\"此时另外一个查询再查询\",{\"1\":{\"216\":1}}],[\"此时大量请求突然请求服务a\",{\"1\":{\"216\":1}}],[\"此时有以下解决方案\",{\"1\":{\"216\":1}}],[\"此时如果有第二个线程来竞争锁\",{\"1\":{\"216\":1}}],[\"此时这把锁是偏向锁\",{\"1\":{\"216\":1}}],[\"此时整个集群中只有一个leader\",{\"1\":{\"216\":1}}],[\"此时机房件的网络断开了\",{\"1\":{\"216\":1}}],[\"此时过半机制的条件是set\",{\"1\":{\"216\":1}}],[\"此时tomcat就能同时处理200个请求了\",{\"1\":{\"216\":1}}],[\"此时年轻代大小最好用\",{\"1\":{\"64\":1}}],[\"此时a收到了b第二次发送的确认消息\",{\"1\":{\"23\":1}}],[\"此值设置运行多少次gc以后对内存空间进行压缩\",{\"1\":{\"64\":1}}],[\"此值建议使用并行收集器时\",{\"1\":{\"64\":1}}],[\"此值最好配置与处理器数目相等\",{\"1\":{\"64\":1}}],[\"此配置仅对年轻代有效\",{\"1\":{\"64\":1}}],[\"典型配置\",{\"1\":{\"64\":2}}],[\"典型的key是string类型\",{\"1\":{\"67\":1}}],[\"典型的非对称加密算法有rsa\",{\"1\":{\"35\":1}}],[\"典型的对称加密算法有des\",{\"1\":{\"35\":1}}],[\"典型的场景是购物车\",{\"1\":{\"31\":1,\"32\":1}}],[\"吞吐量优先的并行收集器\",{\"1\":{\"64\":1}}],[\"串行化设计似乎cpu利用率不高\",{\"1\":{\"216\":1}}],[\"串行化的\",{\"1\":{\"64\":1}}],[\"串行收集器\",{\"1\":{\"64\":1}}],[\"管中窥豹\",{\"1\":{\"64\":1}}],[\"管道\",{\"1\":{\"64\":1}}],[\"弱和虚引用\",{\"1\":{\"64\":1}}],[\"软件源\",{\"1\":{\"231\":1}}],[\"软件服务器大部分也在国外\",{\"1\":{\"231\":1}}],[\"软\",{\"1\":{\"64\":1}}],[\"程序则仅需要\",{\"1\":{\"249\":1}}],[\"程序发布单独版本管理\",{\"1\":{\"233\":1}}],[\"程序计数器是每个线程独有的\",{\"1\":{\"216\":1}}],[\"程序错误或更常见些的软件升级中使用\",{\"1\":{\"64\":1}}],[\"程序参数传递时\",{\"1\":{\"64\":1}}],[\"程序运行可以没有堆\",{\"1\":{\"64\":1}}],[\"程序运行永远都是在栈中进行的\",{\"1\":{\"64\":1}}],[\"程序运行状态\",{\"1\":{\"64\":1}}],[\"明明在语法层面已经指定了b\",{\"1\":{\"216\":1}}],[\"明确以上两点后\",{\"1\":{\"64\":1}}],[\"明细\",{\"1\":{\"64\":1}}],[\"先来编写一个最简单的dockerfile\",{\"1\":{\"218\":1}}],[\"先删除redis缓存数据\",{\"1\":{\"216\":1}}],[\"先更新leader节点本地的内存数据\",{\"1\":{\"216\":1}}],[\"先比较zxid\",{\"1\":{\"216\":1}}],[\"先找\",{\"1\":{\"216\":1}}],[\"先将原数组分组\",{\"1\":{\"216\":1}}],[\"先计算出红黑树中每个元素对应在新数组中的下标位置\",{\"1\":{\"216\":1}}],[\"先把这个无序的数列\",{\"1\":{\"216\":1}}],[\"先要明确两点\",{\"1\":{\"64\":1}}],[\"先使用\",{\"1\":{\"47\":1}}],[\"长在\",{\"1\":{\"216\":1}}],[\"长九时\",{\"1\":{\"216\":1}}],[\"长度固定\",{\"1\":{\"64\":2}}],[\"长连接\",{\"1\":{\"33\":1}}],[\"持久\",{\"1\":{\"64\":1}}],[\"持久代溢出以及无法创建本地线程\",{\"1\":{\"64\":1}}],[\"持久性\",{\"1\":{\"64\":1}}],[\"栈\",{\"1\":{\"216\":1}}],[\"栈什么时候oom\",{\"0\":{\"184\":1}}],[\"栈的基本理解及大致实现\",{\"1\":{\"64\":1}}],[\"栈的大小通过\",{\"1\":{\"64\":1}}],[\"栈是程序运行最根本的东西\",{\"1\":{\"64\":1}}],[\"栈是运行时的单位\",{\"1\":{\"64\":1}}],[\"栈中的本地变量\",{\"1\":{\"216\":1}}],[\"栈中存的是基本数据类型和堆中对象的引用\",{\"1\":{\"64\":1}}],[\"栈中存什么\",{\"1\":{\"64\":1}}],[\"栈中不是也可以存储数据吗\",{\"1\":{\"64\":1}}],[\"栈因为运行时的需要\",{\"1\":{\"64\":1}}],[\"栈因为是运行单位\",{\"1\":{\"64\":1}}],[\"栈代表了处理逻辑\",{\"1\":{\"64\":1}}],[\"栈解决程序的运行问题\",{\"1\":{\"64\":1}}],[\"栈溢出\",{\"1\":{\"64\":2}}],[\"栈和持久代发生内存溢出\",{\"1\":{\"64\":1}}],[\"容器时需要使用\",{\"1\":{\"231\":1}}],[\"容器的\",{\"1\":{\"231\":1}}],[\"容器的核心是应用\",{\"1\":{\"231\":1}}],[\"容器的内存使用最大限制默认可以接近宿主机的物理内存\",{\"1\":{\"218\":1}}],[\"容器访问宿主机ip\",{\"0\":{\"230\":1}}],[\"容器虚拟化技术以共享宿主机kernel的方式实现\",{\"1\":{\"218\":1}}],[\"容器入口\",{\"1\":{\"218\":1}}],[\"容器启动后执行命令\",{\"1\":{\"218\":1}}],[\"容器内安装vim\",{\"1\":{\"217\":1}}],[\"容器id\",{\"1\":{\"217\":2}}],[\"容器与宿主机相互复制文件\",{\"1\":{\"217\":1}}],[\"容器端口的格式\",{\"1\":{\"219\":1}}],[\"容器端口\",{\"1\":{\"217\":1}}],[\"容器使用宿主机的网络\",{\"1\":{\"217\":1}}],[\"容器相关命令\",{\"1\":{\"217\":1}}],[\"容器是镜像的可运行实例\",{\"1\":{\"217\":1}}],[\"容器\",{\"1\":{\"217\":1}}],[\"容量变为原来的2倍\",{\"1\":{\"73\":1}}],[\"容量变为原来的2n+1\",{\"1\":{\"73\":1}}],[\"容量比内存小很多\",{\"1\":{\"64\":1}}],[\"容易实现\",{\"1\":{\"24\":1}}],[\"差集操作\",{\"1\":{\"216\":1}}],[\"差集的操作\",{\"1\":{\"171\":1}}],[\"差不多要翻倍\",{\"1\":{\"64\":1}}],[\"差错控制等\",{\"1\":{\"11\":1}}],[\"迁移到\",{\"1\":{\"64\":2}}],[\"位\",{\"1\":{\"64\":1}}],[\"位增加到了\",{\"1\":{\"64\":1}}],[\"位的\",{\"1\":{\"64\":5}}],[\"位数组成\",{\"1\":{\"54\":1}}],[\"选举的过程中为什么一定要有一个过半机制验证\",{\"1\":{\"216\":1}}],[\"选择垃圾收集器为并行收集器\",{\"1\":{\"64\":1}}],[\"选择排序\",{\"0\":{\"3\":1}}],[\"选项\",{\"1\":{\"64\":2}}],[\"释放掉对象的引用\",{\"1\":{\"64\":1}}],[\"堆区和方法区是所有线程共享的\",{\"1\":{\"216\":1}}],[\"堆排序\",{\"1\":{\"64\":1}}],[\"堆和栈中\",{\"1\":{\"64\":1}}],[\"堆栈分离的好处\",{\"1\":{\"64\":1}}],[\"堆中存的是对象\",{\"1\":{\"64\":1}}],[\"堆中存什么\",{\"1\":{\"64\":1}}],[\"堆中的对象是可以根据需要动态增长的\",{\"1\":{\"64\":1}}],[\"堆中的共享常量和缓存可以被所有栈访问\",{\"1\":{\"64\":1}}],[\"堆中不可到达的对象都会标记成垃圾\",{\"1\":{\"64\":1}}],[\"堆与栈的分离\",{\"1\":{\"64\":1}}],[\"堆解决的是数据存储的问题\",{\"1\":{\"64\":1}}],[\"堆学习之新生代老年代持久带的使用关系\",{\"1\":{\"64\":1}}],[\"堆溢出\",{\"1\":{\"64\":1}}],[\"堆空间也会一并被gc一次\",{\"1\":{\"64\":1}}],[\"凡是可以达到的点都会标记为存活\",{\"1\":{\"64\":1}}],[\"凡位于发送窗口内的分组可以连续发送出去\",{\"1\":{\"24\":1}}],[\"凡位于发送窗口内的分组可连续发送出去\",{\"1\":{\"23\":1}}],[\"永久代空间已经满了\",{\"1\":{\"64\":1}}],[\"永久代gc的原因\",{\"1\":{\"64\":1}}],[\"永久代对象如何gc\",{\"1\":{\"64\":1}}],[\"问通常多大\",{\"1\":{\"64\":1}}],[\"问题扩展\",{\"1\":{\"64\":2}}],[\"问题\",{\"1\":{\"64\":2}}],[\"老师\",{\"1\":{\"246\":1}}],[\"老年代中数组的访问方式\",{\"1\":{\"64\":1}}],[\"老年代\",{\"1\":{\"64\":1}}],[\"老生常谈\",{\"1\":{\"64\":2}}],[\"触摸java常量池\",{\"1\":{\"64\":1}}],[\"触发的场景\",{\"1\":{\"64\":1}}],[\"触发major\",{\"1\":{\"64\":1}}],[\"反言之\",{\"1\":{\"216\":1}}],[\"反过来\",{\"1\":{\"216\":1}}],[\"反正就一台点钞机\",{\"1\":{\"216\":1}}],[\"反正就是各种扩展\",{\"1\":{\"64\":1}}],[\"反转之后有什么好处\",{\"1\":{\"216\":1}}],[\"反转之后是谁控制的\",{\"1\":{\"216\":1}}],[\"反转之前有什么问题\",{\"1\":{\"216\":1}}],[\"反转之前是谁控制的\",{\"1\":{\"216\":1}}],[\"反转\",{\"1\":{\"86\":1}}],[\"反射和jvm的执行引擎有什么区别\",{\"0\":{\"120\":1}}],[\"反射中\",{\"1\":{\"64\":1}}],[\"反射代码破坏了抽象性\",{\"1\":{\"64\":1}}],[\"反射操作的效\",{\"1\":{\"64\":1}}],[\"反射包括了一些动态类型\",{\"1\":{\"64\":1}}],[\"反射被广泛地用于那些需要在运行时检测或修改程序行为的程序中\",{\"1\":{\"64\":1}}],[\"反射\",{\"1\":{\"64\":2}}],[\"反射是不是很慢\",{\"1\":{\"64\":2}}],[\"讲师回复\",{\"0\":{\"234\":1,\"237\":1,\"239\":1,\"241\":1,\"243\":1,\"245\":1,\"247\":1,\"249\":1,\"252\":1,\"254\":1}}],[\"讲一讲内存分代及生命周期\",{\"1\":{\"64\":1}}],[\"讲到jvm垃圾回收机制\",{\"1\":{\"64\":1}}],[\"讲到string常量池\",{\"1\":{\"64\":1}}],[\"讲到内存分配\",{\"1\":{\"64\":1}}],[\"讲讲mybatis的连接池\",{\"1\":{\"64\":1}}],[\"讲讲nio\",{\"1\":{\"64\":1}}],[\"讲讲io里面的常见类\",{\"1\":{\"64\":1}}],[\"列出容器\",{\"1\":{\"217\":1}}],[\"列出镜像\",{\"1\":{\"217\":1}}],[\"列名\",{\"1\":{\"216\":1}}],[\"列举出你说熟悉的设计模式\",{\"1\":{\"64\":1}}],[\"列转行\",{\"1\":{\"64\":1}}],[\"高效地管理容器\",{\"1\":{\"219\":1}}],[\"高定制性\",{\"1\":{\"216\":1}}],[\"高优先级的配置覆盖低优先级的配置\",{\"1\":{\"216\":1}}],[\"高性能的协调服务\",{\"1\":{\"64\":1}}],[\"高内聚\",{\"1\":{\"64\":1}}],[\"高并发情况下\",{\"1\":{\"64\":2}}],[\"高并发解决方案\",{\"1\":{\"64\":1}}],[\"低耦合\",{\"1\":{\"64\":1}}],[\"低效率\",{\"1\":{\"64\":1}}],[\"观察者模式国\",{\"1\":{\"216\":1}}],[\"观察者模式和redis的订阅和消费\",{\"0\":{\"143\":1}}],[\"观察者模式\",{\"1\":{\"64\":1}}],[\"饿汉\",{\"1\":{\"64\":1}}],[\"饱汉\",{\"1\":{\"64\":1}}],[\"条件\",{\"1\":{\"64\":1}}],[\"条军规\",{\"1\":{\"58\":1}}],[\"产生死锁的必要条件\",{\"1\":{\"64\":1}}],[\"控制了什么\",{\"1\":{\"216\":2}}],[\"控制器将无法将leadership转移到首选的副本\",{\"1\":{\"64\":1}}],[\"控制并发线程数的semaphore\",{\"1\":{\"64\":1}}],[\"控制信息还使接收端能够检测到所收到的帧中有误差错\",{\"1\":{\"11\":1}}],[\"控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束\",{\"1\":{\"11\":1}}],[\"造成\",{\"1\":{\"64\":2}}],[\"百万级数据库优化方案\",{\"1\":{\"64\":1}}],[\"百度好像最喜欢问这个问题\",{\"1\":{\"27\":1}}],[\"百度百科\",{\"1\":{\"8\":2}}],[\"集合是无序的\",{\"1\":{\"216\":1}}],[\"集合可以进行交集\",{\"1\":{\"216\":1}}],[\"集合类\",{\"0\":{\"98\":1}}],[\"集合框架底层数据结构总结\",{\"0\":{\"88\":1}}],[\"集合框架\",{\"0\":{\"65\":1}}],[\"集合表示的是目前\",{\"1\":{\"64\":1}}],[\"集群将不可用\",{\"1\":{\"216\":1}}],[\"集群中所有节点中的数据要和leader节点保持一致\",{\"1\":{\"216\":1}}],[\"集群服务器session同步\",{\"1\":{\"64\":1}}],[\"集群\",{\"1\":{\"64\":1,\"217\":1}}],[\"集群基础\",{\"1\":{\"64\":1}}],[\"集群session一致性和同步问题\",{\"1\":{\"64\":1}}],[\"集群如何同步会话状态\",{\"1\":{\"64\":2}}],[\"集成bean\",{\"1\":{\"64\":2}}],[\"指令是否⼀致\",{\"1\":{\"239\":1}}],[\"指令如下\",{\"1\":{\"231\":1}}],[\"指令书写建议\",{\"1\":{\"231\":1}}],[\"指令应该如何书写\",{\"1\":{\"231\":1}}],[\"指令行数\",{\"1\":{\"231\":1}}],[\"指令都会提交为一个镜像层\",{\"1\":{\"231\":1}}],[\"指令冲突\",{\"1\":{\"219\":1}}],[\"指令描述了构建镜像的细节\",{\"1\":{\"218\":1}}],[\"指定启动容器名称\",{\"1\":{\"219\":2}}],[\"指定了模板文件\",{\"1\":{\"219\":1}}],[\"指定了cmd命令以后\",{\"1\":{\"218\":1}}],[\"指定dockerfile文件的路径\",{\"1\":{\"219\":1}}],[\"指定dockfile所在路径\",{\"1\":{\"219\":3}}],[\"指定镜像名称或者镜像id\",{\"1\":{\"219\":1}}],[\"指定镜像名称\",{\"1\":{\"219\":3}}],[\"指定服务名\",{\"1\":{\"219\":1}}],[\"指定挂载点\",{\"1\":{\"218\":1}}],[\"指定环境变量\",{\"1\":{\"218\":1}}],[\"指定容器工作路径\",{\"1\":{\"218\":1}}],[\"指定网络模式\",{\"1\":{\"217\":1}}],[\"指定端口映射\",{\"1\":{\"217\":1,\"219\":1}}],[\"指的是数组的长度\",{\"1\":{\"77\":1}}],[\"指的是值是否相同\",{\"1\":{\"75\":1}}],[\"指向head\",{\"1\":{\"70\":1}}],[\"指向物理服务器\",{\"1\":{\"64\":1}}],[\"指示信息\",{\"1\":{\"54\":1}}],[\"镜像的体积\",{\"1\":{\"244\":1}}],[\"镜像的技术可以解决不同网络接入商和地域带来的用户访问速度差异\",{\"1\":{\"64\":1}}],[\"镜像下安装一些软件\",{\"1\":{\"231\":1}}],[\"镜像中\",{\"1\":{\"231\":1}}],[\"镜像中包含了运行环境和配置\",{\"1\":{\"217\":1}}],[\"镜像层数过多\",{\"1\":{\"231\":1}}],[\"镜像名称\",{\"1\":{\"218\":1}}],[\"镜像大小\",{\"1\":{\"217\":1}}],[\"镜像创建时间\",{\"1\":{\"217\":1}}],[\"镜像标签\",{\"1\":{\"217\":1}}],[\"镜像所属仓库名称\",{\"1\":{\"217\":1}}],[\"镜像仓库收藏数\",{\"1\":{\"217\":1}}],[\"镜像仓库描述\",{\"1\":{\"217\":1}}],[\"镜像仓库名称\",{\"1\":{\"217\":1}}],[\"镜像相关命令\",{\"1\":{\"217\":1}}],[\"镜像和容器的关系有点类似于面向对象中\",{\"1\":{\"217\":1}}],[\"镜像是大型网站常采用的提高性能和数据安全性的方式\",{\"1\":{\"64\":1}}],[\"镜像\",{\"1\":{\"64\":1,\"217\":2}}],[\"甚至镜像构建失败\",{\"1\":{\"231\":1}}],[\"甚至并非compose管理的容器\",{\"1\":{\"219\":1}}],[\"甚至于一个微服务框架\",{\"1\":{\"216\":1}}],[\"甚至很多台图片服务器\",{\"1\":{\"64\":1}}],[\"甚至他们的其他频道\",{\"1\":{\"64\":1}}],[\"拥有一套高效\",{\"1\":{\"64\":1}}],[\"拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大\",{\"1\":{\"26\":1}}],[\"拥塞避免\",{\"1\":{\"26\":2}}],[\"拥塞窗口\",{\"1\":{\"26\":1}}],[\"拥塞控制窗口的大小取决于网络的拥塞程度\",{\"1\":{\"26\":1}}],[\"拥塞控制是一个全局性的过程\",{\"1\":{\"26\":1}}],[\"拥塞控制所要做的都有一个前提\",{\"1\":{\"26\":1}}],[\"拥塞控制就是为了防止过多的数据注入到网络中\",{\"1\":{\"26\":1}}],[\"拥塞控制\",{\"0\":{\"26\":1},\"1\":{\"21\":1}}],[\"拥塞控制机制\",{\"1\":{\"20\":1}}],[\"权限登录\",{\"1\":{\"217\":1}}],[\"权限管理\",{\"1\":{\"64\":1}}],[\"权限控制\",{\"1\":{\"64\":1}}],[\"消费订阅等机制来实现的\",{\"1\":{\"216\":1}}],[\"消费者接收到一条消息后\",{\"1\":{\"216\":1}}],[\"消费者一定要能消费到\",{\"1\":{\"216\":1}}],[\"消费者压力大等问题\",{\"1\":{\"216\":1}}],[\"消费者就得消费多少消息\",{\"1\":{\"216\":1}}],[\"消费者库存系统就会来消费\",{\"1\":{\"216\":2}}],[\"消费者想要使用哪个接口\",{\"1\":{\"216\":1}}],[\"消费者可以从关系型数据库中找到对应的offset\",{\"1\":{\"64\":1}}],[\"消费者将关闭自动提交offset的功能且不再手动提交offset\",{\"1\":{\"64\":1}}],[\"消费者的\",{\"1\":{\"64\":1}}],[\"消除了\",{\"1\":{\"216\":1}}],[\"消耗最小的就是纯静态化的html页面\",{\"1\":{\"64\":1}}],[\"消息可靠传输代表了两层意思\",{\"1\":{\"216\":1}}],[\"消息可能会丢\",{\"1\":{\"64\":1}}],[\"消息并没有发送到broker而是缓存起来\",{\"1\":{\"216\":1}}],[\"消息列表等功能都可以用redis的\",{\"1\":{\"170\":1}}],[\"消息是持久性的\",{\"1\":{\"64\":1}}],[\"消息被广播给所有的用户\",{\"1\":{\"64\":1}}],[\"消息绝不会丢\",{\"1\":{\"64\":1}}],[\"消息队列等等都可以打包成一个镜像部署\",{\"1\":{\"217\":1}}],[\"消息队列如何保证消息可靠传输\",{\"1\":{\"216\":1}}],[\"消息队列有哪些作用\",{\"1\":{\"216\":1}}],[\"消息队列\",{\"1\":{\"64\":2}}],[\"消息模式\",{\"1\":{\"64\":1}}],[\"消息中间件收到业务操作结果后\",{\"1\":{\"64\":1}}],[\"消息中间件收到消息之后\",{\"1\":{\"64\":1}}],[\"消息中间件返回消息持久化结果\",{\"1\":{\"64\":1}}],[\"消息中间件如何保证消息的一致性\",{\"1\":{\"64\":1}}],[\"消息中间件如何保证消息的一致性和如何进行消息的重试机制\",{\"1\":{\"64\":1}}],[\"消息状态标记为待确认\",{\"1\":{\"64\":1}}],[\"消息响应\",{\"1\":{\"17\":1}}],[\"消息\",{\"1\":{\"17\":1,\"24\":1}}],[\"统计服务提供者当前正在处理的请求\",{\"1\":{\"216\":1}}],[\"统计海量数据中出现次数最多的前10个ip\",{\"1\":{\"64\":2}}],[\"统计的功能尽量做缓存\",{\"1\":{\"64\":1}}],[\"统一异常处理\",{\"1\":{\"64\":1}}],[\"统一\",{\"1\":{\"64\":1}}],[\"没怎么问我\",{\"0\":{\"150\":1}}],[\"没用到\",{\"0\":{\"146\":1}}],[\"没做过一问便知\",{\"1\":{\"64\":1}}],[\"没列出\",{\"1\":{\"64\":2}}],[\"没有使用\",{\"1\":{\"217\":1}}],[\"没有加到则返回false\",{\"1\":{\"216\":1}}],[\"没有这样的机制\",{\"1\":{\"73\":1}}],[\"没有实现\",{\"1\":{\"69\":1}}],[\"没有返回值的可以这么做\",{\"1\":{\"64\":1}}],[\"没有索引的表是锁定全表的\",{\"1\":{\"64\":1}}],[\"没有新的或复制的数据包被发送\",{\"1\":{\"26\":1}}],[\"没有\",{\"1\":{\"26\":1}}],[\"记得不完整\",{\"1\":{\"64\":2}}],[\"记录机制实现\",{\"1\":{\"64\":1}}],[\"静态变量只有读操作\",{\"1\":{\"64\":1}}],[\"举个简单的例子\",{\"1\":{\"216\":1}}],[\"举个例子\",{\"1\":{\"19\":1,\"96\":1,\"216\":1}}],[\"举例\",{\"1\":{\"172\":1}}],[\"举例说明\",{\"1\":{\"64\":1}}],[\"他们所适用的场景也不同\",{\"1\":{\"216\":1}}],[\"他们的底层数据结构不同\",{\"1\":{\"216\":1}}],[\"他们的处理方式是统一的\",{\"1\":{\"64\":2}}],[\"他们都有独立的图片服务器\",{\"1\":{\"64\":1}}],[\"他们支持事务消息的方式也是类似于采用的二阶段提交\",{\"1\":{\"64\":1}}],[\"他是比进程更小的能独立运行的基本单位\",{\"1\":{\"64\":1}}],[\"考察高效率\",{\"1\":{\"64\":1}}],[\"考察对技术细节的深入了解程度\",{\"1\":{\"64\":2}}],[\"考虑效率\",{\"1\":{\"64\":1}}],[\"子类可以做一些额外的初始化\",{\"1\":{\"216\":1}}],[\"子类可以继续处理beanffacitory\",{\"1\":{\"216\":1}}],[\"子类是不能重载父类的private方法的\",{\"1\":{\"216\":1}}],[\"子线程执行完之后\",{\"1\":{\"64\":1}}],[\"子加载器才会尝试自己去加载\",{\"1\":{\"64\":1}}],[\"衍伸出和synchronized相关很多的具体问题\",{\"1\":{\"64\":1}}],[\"死信队列是什么\",{\"1\":{\"216\":1}}],[\"死亡状态\",{\"1\":{\"64\":1}}],[\"死锁的产生\",{\"1\":{\"64\":1}}],[\"死锁检查\",{\"1\":{\"64\":1}}],[\"死锁场景\",{\"1\":{\"64\":1}}],[\"必须先正常编排微服务\",{\"1\":{\"219\":1}}],[\"必须首先获得对应的\",{\"1\":{\"83\":1}}],[\"必须等到这次访问结束以后才能对这个线程安全的方法进行访问\",{\"1\":{\"64\":1}}],[\"必须依靠其他线程调用notify\",{\"1\":{\"64\":1}}],[\"必须向上层返回失败结果\",{\"1\":{\"64\":1}}],[\"才认为命中缓存\",{\"1\":{\"231\":1}}],[\"才按需分配新空间\",{\"1\":{\"218\":1}}],[\"才从image里把要写的文件复制到自己的文件系统进行修改\",{\"1\":{\"218\":1}}],[\"才用\",{\"1\":{\"216\":1}}],[\"才能选出来一个leader\",{\"1\":{\"216\":1}}],[\"才可以使treemap中的数据按顺序排列\",{\"1\":{\"87\":1}}],[\"才使得java的垃圾回收成为可能\",{\"1\":{\"64\":1}}],[\"才有机会转到运行状态\",{\"1\":{\"64\":1}}],[\"才会符合过半机制\",{\"1\":{\"216\":1}}],[\"才会导致它占用的空间大小要比gbk大\",{\"1\":{\"64\":1}}],[\"才会继续\",{\"1\":{\"57\":1}}],[\"暂时停止运行\",{\"1\":{\"64\":1}}],[\"变得可运行\",{\"1\":{\"64\":1}}],[\"否则它会覆盖cmd命令\",{\"1\":{\"218\":1}}],[\"否则仍然提交事务\",{\"1\":{\"216\":1}}],[\"否则会产生比较大的影响\",{\"1\":{\"64\":1}}],[\"否则会出现java\",{\"1\":{\"64\":1}}],[\"否则事务回滚需要重新消费\",{\"1\":{\"64\":1}}],[\"否则就可能影响线程安全\",{\"1\":{\"64\":1}}],[\"否则创建大量的线程会导致严重的性能问题\",{\"1\":{\"64\":1}}],[\"否则认为是过期数据\",{\"1\":{\"64\":1}}],[\"固定大小的线程池\",{\"1\":{\"64\":1}}],[\"锁的是一个区间\",{\"1\":{\"216\":1}}],[\"锁粒度最大\",{\"1\":{\"216\":1}}],[\"锁粒度最小\",{\"1\":{\"216\":1}}],[\"锁整张表\",{\"1\":{\"216\":1}}],[\"锁某行数据\",{\"1\":{\"216\":1}}],[\"锁也不能被其他客户端获取到\",{\"1\":{\"216\":1}}],[\"锁信息保存在对象头中\",{\"1\":{\"216\":1}}],[\"锁细分\",{\"0\":{\"117\":1}}],[\"锁池\",{\"1\":{\"64\":1}}],[\"锁和同步都行\",{\"1\":{\"64\":1}}],[\"锁机制介绍\",{\"1\":{\"64\":2}}],[\"怎么也不会设置到200个线程\",{\"1\":{\"216\":1}}],[\"怎么分库分表\",{\"0\":{\"192\":1}}],[\"怎么扫描垃圾\",{\"0\":{\"190\":1}}],[\"怎么jvm中内存的使用情况\",{\"0\":{\"185\":1}}],[\"怎么实现\",{\"0\":{\"159\":1}}],[\"怎么写\",{\"0\":{\"142\":1}}],[\"怎么用的\",{\"0\":{\"141\":1}}],[\"怎么修改\",{\"0\":{\"140\":1}}],[\"怎么进行分页查询\",{\"1\":{\"64\":1}}],[\"怎么解决问题\",{\"1\":{\"64\":2}}],[\"怎么做优化\",{\"1\":{\"64\":2}}],[\"怎么提高并发量\",{\"1\":{\"64\":1}}],[\"怎么快速的完成页面的加载呢\",{\"1\":{\"58\":1}}],[\"处理器适配器\",{\"1\":{\"216\":1}}],[\"处理器映射器\",{\"1\":{\"216\":1}}],[\"处理initializingbean接口\",{\"1\":{\"216\":1}}],[\"处理\",{\"1\":{\"216\":1}}],[\"处理多个任务\",{\"1\":{\"64\":1}}],[\"处理如下\",{\"1\":{\"23\":1}}],[\"跳表\",{\"1\":{\"64\":1}}],[\"跳表skiplist\",{\"1\":{\"64\":1}}],[\"递归读取文件夹下的\",{\"1\":{\"64\":1}}],[\"递归读取文件夹下的文件\",{\"1\":{\"64\":1}}],[\"仅支持本地文件向容器拷贝\",{\"1\":{\"231\":1}}],[\"仅能获得\",{\"1\":{\"94\":1}}],[\"仅存储对象\",{\"1\":{\"74\":1}}],[\"仅仅是获取服务器资源\",{\"1\":{\"64\":1}}],[\"仅耗时较长的查询做优化\",{\"1\":{\"64\":1}}],[\"仅限于中文字符\",{\"1\":{\"64\":1}}],[\"仅需记录哪条数据被修改了\",{\"1\":{\"64\":1}}],[\"正确设置时区\",{\"1\":{\"231\":1}}],[\"正确使用\",{\"1\":{\"216\":1}}],[\"正在更新mysql\",{\"1\":{\"216\":1}}],[\"正在运行的线程等可以作为gc\",{\"1\":{\"216\":1}}],[\"正常情况下\",{\"1\":{\"216\":1}}],[\"正常情况下不会存在内存泄露\",{\"1\":{\"64\":1}}],[\"正常来说\",{\"1\":{\"216\":1}}],[\"正是因为堆和栈的分离的思想\",{\"1\":{\"64\":1}}],[\"正是因为它的强大\",{\"1\":{\"64\":1}}],[\"编译环境是指编译运行程序所需要的环境\",{\"1\":{\"249\":1}}],[\"编译环境\",{\"1\":{\"233\":1}}],[\"编译时增强的性能更好\",{\"1\":{\"64\":1}}],[\"编排电商微服务\",{\"1\":{\"219\":1}}],[\"编排电商项目依赖环境\",{\"1\":{\"219\":1}}],[\"编码\",{\"1\":{\"64\":1}}],[\"编码utf\",{\"1\":{\"64\":1}}],[\"缓冲队列workqueue满\",{\"1\":{\"216\":2}}],[\"缓冲区\",{\"1\":{\"64\":1}}],[\"缓存雪崩是大批热点数据失效\",{\"1\":{\"216\":1}}],[\"缓存雪崩分别是什么\",{\"1\":{\"216\":1}}],[\"缓存中存放的大多都是热点数据\",{\"1\":{\"216\":1}}],[\"缓存击穿\",{\"1\":{\"216\":1}}],[\"缓存穿透\",{\"1\":{\"216\":1}}],[\"缓存一词搞技术的都接触过\",{\"1\":{\"64\":1}}],[\"缓存线程池\",{\"1\":{\"64\":1}}],[\"缓存异步任务的队列\",{\"1\":{\"64\":1}}],[\"缓存\",{\"0\":{\"44\":1},\"1\":{\"43\":1,\"44\":1,\"54\":1,\"64\":3}}],[\"缓存处理\",{\"1\":{\"33\":1}}],[\"查出了多余数据\",{\"1\":{\"216\":1}}],[\"查询语句中每出现一个select关键字\",{\"1\":{\"216\":1}}],[\"查询\",{\"1\":{\"216\":1}}],[\"查询效率越低下\",{\"1\":{\"64\":1}}],[\"查询手机号所属地的笔试题\",{\"1\":{\"64\":2}}],[\"查找需要从第一行记录开始查找\",{\"1\":{\"216\":1}}],[\"查找算法\",{\"1\":{\"64\":1}}],[\"查找树与红黑树\",{\"1\":{\"64\":1}}],[\"查找\",{\"1\":{\"64\":1}}],[\"查看compose下某个容器的运行日志\",{\"1\":{\"219\":1}}],[\"查看compose所有容器的运行日志\",{\"1\":{\"219\":1}}],[\"查看compose内的容器\",{\"1\":{\"219\":1}}],[\"查看版本\",{\"1\":{\"219\":1}}],[\"查看某一个容器的大小\",{\"1\":{\"218\":1}}],[\"查看所有容器的大小\",{\"1\":{\"218\":2}}],[\"查看容器占用磁盘大小指令\",{\"1\":{\"218\":1}}],[\"查看容器里的进程\",{\"1\":{\"217\":1}}],[\"查看容器日志\",{\"1\":{\"217\":1}}],[\"查看容器所有信息\",{\"1\":{\"217\":1}}],[\"查看有没有\",{\"1\":{\"217\":1}}],[\"查看源码我们发现实际上\",{\"1\":{\"69\":1}}],[\"查看堆内类\",{\"1\":{\"64\":1}}],[\"查看线程内部运行情况\",{\"1\":{\"64\":1}}],[\"哪些节点是follower和observer\",{\"1\":{\"216\":1}}],[\"哪些操作\",{\"1\":{\"64\":1}}],[\"哪台机器处理请求并不重要\",{\"1\":{\"45\":1}}],[\"带spring\",{\"1\":{\"216\":2}}],[\"带优先级的无界阻塞队列\",{\"1\":{\"64\":1}}],[\"带宽优化及网络连接的使用\",{\"1\":{\"33\":1}}],[\"阻塞和唤醒这两个步骤都是需要操作系统去进行的\",{\"1\":{\"216\":1}}],[\"阻塞和非阻塞\",{\"1\":{\"64\":1}}],[\"阻塞队列和非阻塞队列\",{\"0\":{\"118\":1}}],[\"阻塞队列实现了blockingqueue接口\",{\"1\":{\"64\":1}}],[\"阻塞的情况分三种\",{\"1\":{\"64\":1}}],[\"阻塞状态是线程因为某种原因放弃cpu使用权\",{\"1\":{\"64\":1}}],[\"阻塞状态\",{\"1\":{\"64\":1}}],[\"阻塞后续资源下载的根本原因\",{\"1\":{\"57\":1}}],[\"延时队列是什么\",{\"1\":{\"216\":1}}],[\"延迟几百毫秒再删除redis缓存数据\",{\"1\":{\"216\":1}}],[\"延期阻塞队列\",{\"1\":{\"64\":1}}],[\"延伸考察concurrenthashmap与hashmap\",{\"1\":{\"64\":1}}],[\"丢数据\",{\"1\":{\"64\":1}}],[\"丢弃这个重复的m1消息\",{\"1\":{\"23\":1}}],[\"达到节点上的数据实时一致\",{\"1\":{\"216\":1}}],[\"达到扩容因子时\",{\"1\":{\"64\":1}}],[\"达到与场景2的同样效果\",{\"1\":{\"64\":1}}],[\"增量同步\",{\"1\":{\"216\":1}}],[\"增长方式一定是2的指数倍\",{\"1\":{\"64\":1}}],[\"增加了系统调用链路的环节\",{\"1\":{\"218\":1}}],[\"增加了一条双向链表\",{\"1\":{\"90\":1}}],[\"增加了list\",{\"1\":{\"64\":1}}],[\"增加方式的old\",{\"1\":{\"64\":1}}],[\"答案是联合文件系统\",{\"1\":{\"218\":1}}],[\"答案\",{\"1\":{\"216\":3}}],[\"答案就是能不从网络中加载的资源就不从网络中加载\",{\"1\":{\"58\":1}}],[\"答\",{\"1\":{\"64\":2}}],[\"复杂度适中\",{\"1\":{\"216\":1}}],[\"复杂性\",{\"1\":{\"64\":1}}],[\"复制文件到容器\",{\"1\":{\"218\":1,\"219\":1}}],[\"复制与集群\",{\"1\":{\"64\":1}}],[\"复制算法\",{\"1\":{\"64\":1}}],[\"复用技术可以让单个线程高效的处理多个连接请求\",{\"1\":{\"64\":1}}],[\"多个元素也排序了\",{\"1\":{\"216\":1}}],[\"多个工作线程模型性能更优\",{\"1\":{\"216\":1}}],[\"多个注册中心\",{\"1\":{\"216\":1}}],[\"多个线程是可能处于不同进程中的\",{\"1\":{\"216\":1}}],[\"多个线程都是属于同一个进程的\",{\"1\":{\"216\":1}}],[\"多做索引\",{\"1\":{\"64\":1}}],[\"多花点内存来做缓存\",{\"1\":{\"64\":1}}],[\"多种方式\",{\"1\":{\"64\":1}}],[\"多用户并发访问时如何解决\",{\"1\":{\"64\":1}}],[\"多线程模型\",{\"1\":{\"216\":1}}],[\"多线程顺序打印\",{\"0\":{\"211\":1}}],[\"多线程sleep和wait\",{\"0\":{\"99\":1}}],[\"多线程操作字符串缓冲区下操作大量数据\",{\"1\":{\"94\":1}}],[\"多线程操作导致死循环问题\",{\"0\":{\"80\":1}}],[\"多线程访问容器里不同数据段的数据\",{\"1\":{\"81\":1}}],[\"多线程之间通信的同步问题\",{\"1\":{\"64\":1}}],[\"多线程扩容可能死锁\",{\"1\":{\"64\":1}}],[\"多线程同时写入\",{\"1\":{\"64\":1}}],[\"多线程修改hashmap\",{\"1\":{\"64\":1}}],[\"多线程处理会涉及到线程切换而消耗cpu\",{\"1\":{\"64\":1}}],[\"多线程处理可能涉及到锁\",{\"1\":{\"64\":1}}],[\"多线程的问题\",{\"1\":{\"64\":1}}],[\"多版本兼容\",{\"1\":{\"64\":1}}],[\"扩容机制\",{\"1\":{\"72\":1}}],[\"扩展接口为\",{\"1\":{\"216\":8}}],[\"扩展hashmap增加双向链表的实现\",{\"1\":{\"64\":1}}],[\"扩展类加载器\",{\"1\":{\"64\":1}}],[\"扩缩容复杂等\",{\"1\":{\"64\":1}}],[\"单独打包镜像\",{\"1\":{\"233\":1}}],[\"单一职责\",{\"1\":{\"231\":1}}],[\"单一的kafka代理可以处理成千上万的客户端\",{\"1\":{\"64\":1}}],[\"单物理机内扩容\",{\"1\":{\"219\":1}}],[\"单个注册中心进行注册\",{\"1\":{\"216\":1}}],[\"单个索引\",{\"1\":{\"64\":1}}],[\"单创日can生成\",{\"1\":{\"216\":1}}],[\"单例bean\",{\"1\":{\"216\":1}}],[\"单例beandotinition\",{\"1\":{\"216\":1}}],[\"单例模式\",{\"1\":{\"64\":1,\"216\":1}}],[\"单线程操作字符串缓冲区下操作大量数据\",{\"1\":{\"94\":1}}],[\"单线程线程池\",{\"1\":{\"64\":1}}],[\"单线程的问题\",{\"1\":{\"64\":1}}],[\"单进程单线程只能跑满一个cpu核\",{\"1\":{\"64\":1}}],[\"单列模式\",{\"1\":{\"64\":1}}],[\"绝大部分请求是纯粹的内存操作\",{\"1\":{\"64\":1}}],[\"工厂方法模式的优点\",{\"1\":{\"64\":1}}],[\"工厂模式\",{\"1\":{\"64\":1,\"216\":1}}],[\"工作流引擎负责协调\",{\"1\":{\"64\":1}}],[\"工程师常用学习资源公众号后台回复关键字\",{\"1\":{\"91\":1}}],[\"工程师必备学习资源\",{\"1\":{\"91\":1}}],[\"工程师必备工具\",{\"1\":{\"59\":1}}],[\"工程师的水平\",{\"1\":{\"39\":1}}],[\"kopelan\",{\"0\":{\"242\":1}}],[\"kibana在elasticsearch启动之后再启动\",{\"1\":{\"219\":2}}],[\"kibana\",{\"1\":{\"219\":3}}],[\"kill\",{\"1\":{\"217\":1}}],[\"kill命令发送\",{\"1\":{\"217\":1}}],[\"kill的用法\",{\"1\":{\"64\":1}}],[\"ks航k\",{\"1\":{\"216\":1}}],[\"kle\",{\"1\":{\"216\":1}}],[\"kafka为什么吞吐量高\",{\"1\":{\"216\":1}}],[\"kafka为什么需要复制\",{\"1\":{\"64\":1}}],[\"kafka的ack机制都可以保证生产者能正确的将消息发送给broker\",{\"1\":{\"216\":1}}],[\"kafka的pull和push分别有什么优缺点\",{\"1\":{\"216\":1}}],[\"kafka的生产者采用的是异步发送消息机制\",{\"1\":{\"216\":1}}],[\"kafka的log存储解析\",{\"1\":{\"64\":1}}],[\"kafka的信息复制确保了任何已发布的消息不会丢失\",{\"1\":{\"64\":1}}],[\"kafka高效的文件存储设计\",{\"1\":{\"64\":1}}],[\"kafka深入理解\",{\"1\":{\"64\":1}}],[\"kafka文件存储机制那些事\",{\"1\":{\"64\":1}}],[\"kafka文件存储\",{\"1\":{\"64\":1}}],[\"kafka与传统的消息中间件对比\",{\"1\":{\"64\":2}}],[\"kafka与传统的消息传递技术相比优势之处在于\",{\"1\":{\"64\":1}}],[\"kafka服务器可以接收到的消息的最大大小是1000000字节\",{\"1\":{\"64\":1}}],[\"kafka服务器能接收到的最大信息是多少\",{\"1\":{\"64\":1}}],[\"kafka是由apache开发的一种发布订阅消息系统\",{\"1\":{\"64\":1}}],[\"kafka\",{\"0\":{\"160\":1},\"1\":{\"64\":5}}],[\"key3\",{\"1\":{\"171\":1}}],[\"key2\",{\"1\":{\"171\":1}}],[\"key1\",{\"1\":{\"171\":1}}],[\"keyset\",{\"1\":{\"87\":1}}],[\"keys\",{\"1\":{\"87\":2,\"216\":1}}],[\"key\",{\"1\":{\"64\":1,\"69\":3,\"73\":1,\"74\":1,\"77\":6,\"87\":3,\"216\":3,\"223\":11,\"225\":1,\"231\":4,\"242\":1}}],[\"key=value\",{\"1\":{\"242\":1,\"243\":1}}],[\"key=javauser293847\",{\"1\":{\"169\":1}}],[\"key=\",{\"1\":{\"64\":2}}],[\"key最多有一个null\",{\"1\":{\"64\":1}}],[\"keepalive\",{\"1\":{\"64\":1}}],[\"keepalivetime\",{\"1\":{\"64\":1}}],[\"keep\",{\"1\":{\"30\":2,\"33\":1,\"51\":1}}],[\"异步非阻塞io\",{\"1\":{\"216\":1}}],[\"异步确保\",{\"1\":{\"64\":1}}],[\"异步任务有了运行结果就会在任务队列中放置一个事件\",{\"1\":{\"57\":1}}],[\"异步任务是放在任务队列中的任务\",{\"1\":{\"57\":1}}],[\"预估的需要读取的记录条数\",{\"1\":{\"216\":1}}],[\"预留资源释放\",{\"1\":{\"64\":1}}],[\"预提交阶段\",{\"1\":{\"64\":1}}],[\"阶段主要是在业务执行错误\",{\"1\":{\"64\":1}}],[\"阶段主要是对业务系统做确认提交\",{\"1\":{\"64\":1}}],[\"阶段主要是对业务系统做检测及资源预留\",{\"1\":{\"64\":1}}],[\"阶段是不会出错的\",{\"1\":{\"64\":1}}],[\"阶段时\",{\"1\":{\"64\":1}}],[\"阶段执行成功并开始执行\",{\"1\":{\"64\":1}}],[\"操作少量的数据\",{\"1\":{\"94\":1}}],[\"操作中如果除数是2的幂次则等价于与其除数减一的与\",{\"1\":{\"79\":1}}],[\"操作系统会使用顺序写入\",{\"1\":{\"64\":1}}],[\"操作系统对文件访问做了优化\",{\"1\":{\"64\":1}}],[\"操作系统\",{\"1\":{\"64\":1}}],[\"操作\",{\"1\":{\"64\":1,\"79\":1}}],[\"撤销\",{\"1\":{\"64\":1}}],[\"决策后阶段\",{\"1\":{\"64\":1}}],[\"之所以叫轻量级锁\",{\"1\":{\"216\":1}}],[\"之所以这么设置\",{\"1\":{\"216\":1}}],[\"之前的\",{\"1\":{\"81\":1}}],[\"之前\",{\"1\":{\"77\":1}}],[\"之后怎么处理\",{\"0\":{\"163\":1}}],[\"之后\",{\"1\":{\"94\":1}}],[\"之后每次扩充\",{\"1\":{\"73\":2}}],[\"之后follower副本会从leader上拉取写入的消息\",{\"1\":{\"64\":1}}],[\"之后就可以标识这个用户并且跟踪这个用户了\",{\"1\":{\"31\":1,\"32\":1}}],[\"之间的接口\",{\"1\":{\"64\":1}}],[\"局部\",{\"1\":{\"64\":1}}],[\"定义多个\",{\"1\":{\"243\":1}}],[\"定义如下\",{\"1\":{\"231\":1}}],[\"定义了一些字符串的基本操作\",{\"1\":{\"94\":1}}],[\"定义了\",{\"1\":{\"64\":1}}],[\"定时任务task等\",{\"1\":{\"216\":1}}],[\"定时线程的使用\",{\"1\":{\"64\":1}}],[\"定位到具体的代码\",{\"1\":{\"216\":1}}],[\"定位到具体的方法\",{\"1\":{\"216\":1}}],[\"定制排序后\",{\"1\":{\"86\":2}}],[\"定制排序的用法\",{\"1\":{\"86\":1}}],[\"定期更新某个值\",{\"1\":{\"64\":1}}],[\"外层事务不回滚\",{\"1\":{\"64\":1}}],[\"外层事务继续提交\",{\"1\":{\"64\":1}}],[\"外层事务trab\",{\"1\":{\"64\":1}}],[\"😉\",{\"1\":{\"64\":2}}],[\"注册中心\",{\"1\":{\"216\":3}}],[\"注册中心层\",{\"1\":{\"216\":1}}],[\"注册中心存储的数据如果越多\",{\"1\":{\"216\":1}}],[\"注册中心的压力更大\",{\"1\":{\"216\":1}}],[\"注册中心的存储的冗余信息较多\",{\"1\":{\"216\":1}}],[\"注册中心保存的数据格式为\",{\"1\":{\"216\":2}}],[\"注重独一无二的性质\",{\"1\":{\"67\":1}}],[\"注意运行\",{\"1\":{\"233\":1}}],[\"注意不是threadlocal对象\",{\"1\":{\"216\":1}}],[\"注意双向链表和双向循环链表的区别\",{\"1\":{\"68\":1}}],[\"注意\",{\"1\":{\"64\":5,\"216\":1,\"217\":1,\"218\":3,\"219\":2}}],[\"注解进行查找\",{\"1\":{\"216\":1}}],[\"注解配置\",{\"1\":{\"64\":1}}],[\"注解\",{\"1\":{\"64\":2}}],[\"需等待其释放\",{\"1\":{\"64\":1}}],[\"需要重新创建容器\",{\"1\":{\"219\":1}}],[\"需要重新发送\",{\"1\":{\"23\":1}}],[\"需要将镜像前面加个分组名\",{\"1\":{\"218\":1}}],[\"需要注意的是\",{\"1\":{\"217\":1}}],[\"需要通过四次挥手来断开\",{\"1\":{\"216\":1}}],[\"需要通过三次握手来建立\",{\"1\":{\"216\":1}}],[\"需要一个分布式锁生成器\",{\"1\":{\"216\":1}}],[\"需要分析\",{\"1\":{\"216\":1}}],[\"需要找到\",{\"1\":{\"216\":1}}],[\"需要知道想要使用的接口在哪个应用\",{\"1\":{\"216\":1}}],[\"需要线程时\",{\"1\":{\"216\":1}}],[\"需要保证元素唯一时选择实现set接口的集合比如treeset或hashset\",{\"1\":{\"91\":1}}],[\"需要保证线程安全就选用concurrenthashmap\",{\"1\":{\"91\":1}}],[\"需要排序时选择treemap\",{\"1\":{\"91\":1}}],[\"需要复制父进程地址空间\",{\"1\":{\"64\":1}}],[\"需要复杂的载量平衡算法\",{\"1\":{\"64\":1}}],[\"需要适当调大这个值\",{\"1\":{\"64\":1}}],[\"需要空间比较少\",{\"1\":{\"64\":2}}],[\"需要进行地址段的划分\",{\"1\":{\"64\":1}}],[\"需要回滚的状态下执行的业务取消\",{\"1\":{\"64\":1}}],[\"需要依赖于aspectj包的标准注解\",{\"1\":{\"64\":1}}],[\"需要获得被目标类的接口信息\",{\"1\":{\"64\":1}}],[\"需要用时获得的是该线程之前存入的值\",{\"1\":{\"64\":1}}],[\"需要根据具体情况在安全和性能方面做出权衡\",{\"1\":{\"48\":1}}],[\"加快镜像构建\",{\"1\":{\"231\":1}}],[\"加快镜像构建的速度和分发速度\",{\"1\":{\"231\":1}}],[\"加\",{\"1\":{\"218\":1,\"219\":1}}],[\"加上jvm参数\",{\"1\":{\"218\":1}}],[\"加上\",{\"1\":{\"216\":1,\"219\":1}}],[\"加上共享锁后在事务结束之前其他事务只能再加共享锁\",{\"1\":{\"64\":1}}],[\"加式类\",{\"1\":{\"216\":1}}],[\"加0次戴功\",{\"1\":{\"216\":1}}],[\"加载操作系统内核这些比较费时费资源的过程\",{\"1\":{\"218\":1}}],[\"加载机制说开去\",{\"1\":{\"64\":1}}],[\"加载方式\",{\"1\":{\"64\":1}}],[\"加锁处理分析\",{\"1\":{\"64\":1}}],[\"加锁\",{\"1\":{\"64\":1}}],[\"加入了主从模式\",{\"1\":{\"64\":1}}],[\"加入同步锁collections\",{\"1\":{\"64\":1}}],[\"加入详细日志记录的\",{\"1\":{\"64\":1}}],[\"加密解密使用不同密钥\",{\"1\":{\"35\":1}}],[\"加密解密为同一个密码\",{\"1\":{\"35\":1}}],[\"加密采用对称加密\",{\"1\":{\"35\":1}}],[\"何谓数据版本\",{\"1\":{\"64\":1}}],[\"③\",{\"1\":{\"64\":1}}],[\"③登录一次网站后访问网站其他页面不需要重新登录\",{\"1\":{\"32\":1}}],[\"函数\",{\"1\":{\"64\":1}}],[\"提高可读性\",{\"1\":{\"231\":1}}],[\"提高系统安全性\",{\"1\":{\"216\":1}}],[\"提高并发访问率\",{\"1\":{\"81\":1}}],[\"提高查询效率\",{\"1\":{\"64\":1}}],[\"提高性能\",{\"1\":{\"64\":2}}],[\"提升高并发量服务器性能解决思路\",{\"1\":{\"64\":1}}],[\"提交结束事务\",{\"1\":{\"64\":1}}],[\"提供注释信息\",{\"1\":{\"231\":1}}],[\"提供yum\",{\"1\":{\"217\":1}}],[\"提供了微服务领域中的很多功能组件\",{\"1\":{\"216\":1}}],[\"提供了一些现有的功能\",{\"1\":{\"64\":1}}],[\"提供对象关系映射标签\",{\"1\":{\"216\":1}}],[\"提供的pom可以简化maven的配置\",{\"1\":{\"64\":1}}],[\"提供缓存支持的数据容器\",{\"1\":{\"64\":1}}],[\"提供所需的内容\",{\"1\":{\"45\":1}}],[\"提供无连接的\",{\"1\":{\"9\":1}}],[\"提供面向连接的服务\",{\"1\":{\"20\":1}}],[\"提供面向连接的\",{\"1\":{\"9\":1}}],[\"①创建时如果不指定容量初始值\",{\"1\":{\"73\":1}}],[\"①jdbc中的事务\",{\"1\":{\"64\":1}}],[\"①\",{\"1\":{\"64\":1,\"68\":1,\"81\":1}}],[\"①失败\",{\"1\":{\"64\":2}}],[\"混合模式复制\",{\"1\":{\"64\":1}}],[\"混合型\",{\"1\":{\"64\":3}}],[\"显示链接到其他服务中的容器\",{\"1\":{\"219\":1}}],[\"显示主页的过程\",{\"0\":{\"27\":1}}],[\"显而易见\",{\"1\":{\"216\":1}}],[\"显得更为合适\",{\"1\":{\"64\":1}}],[\"严格来说\",{\"1\":{\"64\":1}}],[\"刷盘方式\",{\"1\":{\"64\":1}}],[\"刷新主内存共享变量的值从而使得各个线程可以获得最新的值\",{\"1\":{\"64\":1}}],[\"向服务端发送ack\",{\"1\":{\"216\":1}}],[\"向服务器提交数据\",{\"1\":{\"64\":1}}],[\"向客户端发送fin\",{\"1\":{\"216\":1}}],[\"向客户端发送ack\",{\"1\":{\"216\":1}}],[\"向所有从节点发送rdb文件\",{\"1\":{\"216\":1}}],[\"向broker发送commit或rollback\",{\"1\":{\"216\":2}}],[\"向spring容器中导入了一个selector\",{\"1\":{\"216\":1}}],[\"向t1表里插入8条数据\",{\"1\":{\"216\":1}}],[\"向map中添加元素\",{\"1\":{\"74\":1}}],[\"向前移一位的操作\",{\"1\":{\"68\":1}}],[\"向被动方应用投递消息\",{\"1\":{\"64\":1}}],[\"向a发送确认消息\",{\"1\":{\"23\":1}}],[\"紧接着执行消息投递\",{\"1\":{\"64\":1}}],[\"待发送\",{\"1\":{\"64\":1}}],[\"待对方确认后进入半关闭状态\",{\"1\":{\"19\":1}}],[\"更适合用来存储对象\",{\"1\":{\"216\":1}}],[\"更方便操作\",{\"1\":{\"170\":1}}],[\"更加安全数据不会暴漏在url上\",{\"1\":{\"64\":1}}],[\"更新了开源组件等\",{\"1\":{\"64\":1}}],[\"更新频率较低\",{\"1\":{\"64\":1}}],[\"更新消息存储中的消息状态为\",{\"1\":{\"64\":1}}],[\"更多参考\",{\"1\":{\"64\":2}}],[\"更多对比\",{\"1\":{\"64\":1}}],[\"更好的java泛型操作api\",{\"1\":{\"64\":2}}],[\"删除所有镜像\",{\"1\":{\"217\":1}}],[\"删除本地镜像\",{\"1\":{\"217\":1}}],[\"删除容器\",{\"1\":{\"217\":2}}],[\"删除的时间复杂度不同\",{\"1\":{\"216\":1}}],[\"删除元素时间复杂度不受元素位置的影响\",{\"1\":{\"68\":1}}],[\"删除\",{\"1\":{\"64\":1}}],[\"删除消息存储中的消息\",{\"1\":{\"64\":1}}],[\"删除操作\",{\"1\":{\"64\":3}}],[\"失败\",{\"1\":{\"64\":1}}],[\"②创建时如果给定了容量初始值\",{\"1\":{\"73\":1}}],[\"②\",{\"1\":{\"64\":1,\"68\":1,\"81\":1}}],[\"②成功\",{\"1\":{\"64\":2}}],[\"②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了\",{\"1\":{\"32\":1}}],[\"样例\",{\"1\":{\"64\":4}}],[\"份虚拟节点\",{\"1\":{\"64\":1}}],[\"平衡查找树之b树\",{\"1\":{\"64\":1}}],[\"平均\",{\"1\":{\"64\":1}}],[\"平摊到其它提供者\",{\"1\":{\"64\":1}}],[\"平时遇到比较常见的状态码有\",{\"1\":{\"54\":1}}],[\"基础镜像文件\",{\"1\":{\"218\":1}}],[\"基数排序\",{\"1\":{\"64\":1}}],[\"基本不会占用额外空间\",{\"1\":{\"243\":1}}],[\"基本上tomcat内部只会运行servlet程序\",{\"1\":{\"216\":1}}],[\"基本上是会pass掉的\",{\"1\":{\"64\":1}}],[\"基本保持一个应用对应的一个服务的架构\",{\"1\":{\"216\":1}}],[\"基本数据类型==比较的是值\",{\"1\":{\"96\":1}}],[\"基本被淘汰\",{\"1\":{\"73\":1}}],[\"基本类型则为树的叶子节点\",{\"1\":{\"64\":1}}],[\"基本类型和引用的处理是一样的\",{\"1\":{\"64\":1}}],[\"基本类型和对象的引用都是存放在栈中\",{\"1\":{\"64\":2}}],[\"基于相同\",{\"1\":{\"231\":1}}],[\"基于已有的服务进行扩展\",{\"1\":{\"219\":1}}],[\"基于哪个镜像\",{\"1\":{\"218\":1,\"219\":1}}],[\"基于\",{\"1\":{\"89\":1,\"170\":1,\"231\":1}}],[\"基于redis的zset实现排行榜功能\",{\"1\":{\"64\":1}}],[\"基于引用对象遍历的垃圾回收器可以处理循环引用\",{\"1\":{\"64\":1}}],[\"基于zookeeper的分布式session实现\",{\"1\":{\"64\":1}}],[\"基于链表的fifo双端阻塞队列\",{\"1\":{\"64\":1}}],[\"基于链表的fifo阻塞队列\",{\"1\":{\"64\":1}}],[\"基于链表的并发队列\",{\"1\":{\"64\":1}}],[\"基于数组的并发阻塞队列\",{\"1\":{\"64\":1}}],[\"基于xa协议的两阶段提交\",{\"1\":{\"64\":1}}],[\"基于注解的声明式事务管理\",{\"1\":{\"64\":1}}],[\"基于aspectj的xml声明式事务管理\",{\"1\":{\"64\":1}}],[\"基于transactionproxyfactorybean的声明式事务管理\",{\"1\":{\"64\":1}}],[\"基于编程式事务管理实现\",{\"1\":{\"64\":1}}],[\"基于行的复制\",{\"1\":{\"64\":1}}],[\"基于sql语句的复制\",{\"1\":{\"64\":1}}],[\"基于虚拟节点\",{\"1\":{\"64\":1}}],[\"活跃数指调用前后计数差\",{\"1\":{\"64\":1}}],[\"久而久之\",{\"1\":{\"64\":1}}],[\"轮询\",{\"1\":{\"64\":1}}],[\"按键切换为输入模式\",{\"1\":{\"223\":1}}],[\"按\",{\"1\":{\"223\":1}}],[\"按锁粒度分类\",{\"1\":{\"216\":1}}],[\"按不同的业务功能\",{\"1\":{\"216\":1}}],[\"按我去银行取钱的经验来说\",{\"1\":{\"216\":1}}],[\"按从小到大的顺序进行排序\",{\"1\":{\"216\":1}}],[\"按自然排序的升序排序\",{\"1\":{\"86\":1}}],[\"按位异或\",{\"1\":{\"77\":1}}],[\"按照上面原则编写的\",{\"1\":{\"231\":1}}],[\"按照http协议的格式进行解析\",{\"1\":{\"216\":1}}],[\"按照自己的情况进行修改\",{\"1\":{\"216\":1}}],[\"按照b\",{\"1\":{\"216\":2}}],[\"按照之前分析方式进行重传\",{\"1\":{\"64\":1}}],[\"按照redis\",{\"1\":{\"64\":1}}],[\"按公约后的权重设置轮询比率\",{\"1\":{\"64\":1}}],[\"按权重设置随机概率\",{\"1\":{\"64\":1}}],[\"按情况而定\",{\"1\":{\"64\":1}}],[\"随时查看\",{\"1\":{\"219\":1}}],[\"随着页码的增大\",{\"1\":{\"64\":1}}],[\"随着线程池中的核心线程们不断执行任务\",{\"1\":{\"64\":1}}],[\"随机端口映射\",{\"1\":{\"217\":1}}],[\"随机\",{\"1\":{\"64\":1}}],[\"创建一键生成证书脚本\",{\"0\":{\"223\":1}}],[\"创建一个存放证书目录\",{\"0\":{\"222\":1}}],[\"创建一个空目录docker\",{\"1\":{\"219\":1}}],[\"创建一个默认的网络app\",{\"1\":{\"219\":1}}],[\"创建一个引用\",{\"1\":{\"64\":1}}],[\"创建一个user对象\",{\"1\":{\"64\":1}}],[\"创建一个新的事务\",{\"1\":{\"64\":1}}],[\"创建docker\",{\"1\":{\"219\":1}}],[\"创建订单时\",{\"1\":{\"216\":1}}],[\"创建成功后\",{\"1\":{\"216\":1}}],[\"创建的都是升序索引\",{\"1\":{\"216\":1}}],[\"创建线程池的几种方式\",{\"1\":{\"64\":1}}],[\"创建线程池的方式\",{\"1\":{\"64\":2}}],[\"创建线程池有哪几个核心参数\",{\"1\":{\"64\":2}}],[\"抛出异常\",{\"1\":{\"64\":2}}],[\"避免选择恐惧症\",{\"1\":{\"217\":1}}],[\"避免使用锁带来的性能开销\",{\"1\":{\"216\":1}}],[\"避免这些对象进入到老年代\",{\"1\":{\"216\":1}}],[\"避免了寻址\",{\"1\":{\"218\":1}}],[\"避免了fork可能产生的失败\",{\"1\":{\"64\":1}}],[\"避免了不必要的上下文切换和竞争条件\",{\"1\":{\"64\":1}}],[\"避免需要时进行统计的功能\",{\"1\":{\"64\":1}}],[\"避免以上所有读问题\",{\"1\":{\"64\":1}}],[\"避免脏读和不可重复读\",{\"1\":{\"64\":1}}],[\"避免脏读\",{\"1\":{\"64\":1}}],[\"避免类的重复加载\",{\"1\":{\"64\":1}}],[\"已经可以确定a=3\",{\"1\":{\"216\":1}}],[\"已经cookie\",{\"0\":{\"133\":1}}],[\"已提交读\",{\"1\":{\"64\":1}}],[\"已存满\",{\"1\":{\"64\":1}}],[\"虚拟机软件需要加载guest\",{\"1\":{\"218\":1}}],[\"虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象\",{\"1\":{\"96\":1}}],[\"虚拟内存\",{\"1\":{\"64\":1}}],[\"虚读都有可能发生\",{\"1\":{\"64\":1}}],[\"虚幻读\",{\"1\":{\"64\":1}}],[\"脏读\",{\"1\":{\"64\":2}}],[\"资源管理器\",{\"1\":{\"64\":1}}],[\"资源集中管理\",{\"1\":{\"64\":1}}],[\"资源不由使用资源的双方管理\",{\"1\":{\"64\":1}}],[\"准备工作\",{\"1\":{\"64\":1}}],[\"测试证书是否配置成功\",{\"0\":{\"228\":1}}],[\"测试以及部署应用程序\",{\"1\":{\"217\":1}}],[\"测试中配置这个以后\",{\"1\":{\"64\":1}}],[\"测试方面的改进\",{\"1\":{\"64\":1}}],[\"测试等等\",{\"1\":{\"59\":1}}],[\"脚本\",{\"1\":{\"64\":2}}],[\"脚本运行时先依次运行执行栈\",{\"1\":{\"57\":1}}],[\"到底是什么\",{\"1\":{\"217\":1}}],[\"到底是开一个窗口让人心里舒服些\",{\"1\":{\"216\":1}}],[\"到时候springboot是能够读取出来并进行解析的\",{\"1\":{\"216\":1}}],[\"到此为止\",{\"1\":{\"216\":1,\"231\":1}}],[\"到了\",{\"1\":{\"81\":1}}],[\"到堆中的对象\",{\"1\":{\"64\":1}}],[\"到数据库上\",{\"1\":{\"64\":2}}],[\"到springmvc\",{\"1\":{\"64\":2}}],[\"到整个页面显示在用户面前时这个过程中到底发生了什么\",{\"1\":{\"39\":1}}],[\"泛型限定式依赖注入\",{\"1\":{\"64\":2}}],[\"官网说明\",{\"1\":{\"64\":1}}],[\"生产中如果公司镜像统一\",{\"1\":{\"245\":1}}],[\"生产实践中一定优先使用\",{\"1\":{\"231\":1}}],[\"生产者发送的消息\",{\"1\":{\"216\":1}}],[\"生产者宕机\",{\"0\":{\"161\":1}}],[\"生产者不做其他特殊处理\",{\"1\":{\"64\":1}}],[\"生产者就要查询此分区的最后一个消息\",{\"1\":{\"64\":1}}],[\"生产者就无法判断该消息是否成功提交给了kafka\",{\"1\":{\"64\":1}}],[\"生产者的\",{\"1\":{\"64\":1}}],[\"生成服务的客户端\",{\"1\":{\"216\":1}}],[\"生成处理器及处理器拦截器\",{\"1\":{\"216\":1}}],[\"生成beandefiniton\",{\"1\":{\"216\":1}}],[\"生成当时的dump文件\",{\"1\":{\"216\":1}}],[\"生成代理类时间\",{\"1\":{\"64\":1}}],[\"生成一个http格式的请求\",{\"1\":{\"216\":1}}],[\"生成一个实现了代理接口的动态代理类\",{\"1\":{\"64\":1}}],[\"生成一个新的代理类\",{\"1\":{\"64\":1}}],[\"生存一次\",{\"1\":{\"64\":1}}],[\"生命周期\",{\"1\":{\"64\":1}}],[\"修饰\",{\"1\":{\"73\":1}}],[\"修饰符和输出目标等\",{\"1\":{\"64\":1}}],[\"修改docker配置\",{\"0\":{\"225\":1}}],[\"修改之后的docker\",{\"1\":{\"219\":1}}],[\"修改电商项目上面这几个微服务配置文件里的中间件配置为上面docker\",{\"1\":{\"219\":1}}],[\"修改buffer\",{\"1\":{\"216\":1}}],[\"修改配置即可\",{\"1\":{\"64\":1}}],[\"修改的是堆中的数据\",{\"1\":{\"64\":1}}],[\"修改的是引用对应的对象\",{\"1\":{\"64\":1}}],[\"修改成什么样了\",{\"1\":{\"64\":1}}],[\"修改其字节码生成子类\",{\"1\":{\"64\":1}}],[\"把\",{\"1\":{\"233\":1}}],[\"把业务软件的配置\",{\"1\":{\"231\":1}}],[\"把业务操作结果\",{\"1\":{\"64\":1}}],[\"把老数据读到了redis中\",{\"1\":{\"216\":1}}],[\"把advison适配成methodlnterceptor\",{\"1\":{\"216\":1}}],[\"把消息持久化到消息存储中\",{\"1\":{\"64\":1}}],[\"把某些业务对象的的控制权交给一个平台或者框架来同一管理\",{\"1\":{\"64\":1}}],[\"把被代理对象类的class文件加载进来\",{\"1\":{\"64\":1}}],[\"把有序数据传送给应用层\",{\"1\":{\"21\":1}}],[\"再使用yum\",{\"1\":{\"231\":1}}],[\"再给服务端发送一个ack\",{\"1\":{\"216\":1}}],[\"再次查询的时候在将数据添加到缓存中\",{\"1\":{\"216\":1}}],[\"再更新mysql\",{\"1\":{\"216\":2}}],[\"再更新redis\",{\"1\":{\"216\":1}}],[\"再转移到目标内核区域去了\",{\"1\":{\"216\":1}}],[\"再来加载不带profile\",{\"1\":{\"216\":1}}],[\"再来回看这个问题\",{\"1\":{\"64\":1}}],[\"再分析\",{\"1\":{\"216\":1}}],[\"再去调用接口\",{\"1\":{\"216\":1}}],[\"再往深处\",{\"0\":{\"149\":1}}],[\"再往深处扩展\",{\"0\":{\"100\":1}}],[\"再通过反射机制获得动态代理类的构造函数\",{\"1\":{\"64\":1}}],[\"再加上有些东西记忆的没有那么清晰了\",{\"1\":{\"59\":1}}],[\"再加上大学时的计算机网络的基础基本上忘完\",{\"1\":{\"46\":1}}],[\"字段关系映射\",{\"1\":{\"216\":1}}],[\"字段来实现\",{\"1\":{\"64\":1}}],[\"字符流\",{\"1\":{\"64\":1}}],[\"字节流\",{\"1\":{\"64\":1}}],[\"字节码\",{\"1\":{\"64\":1}}],[\"字体\",{\"1\":{\"57\":1}}],[\"广泛应用于处理一些具有横切性质的系统级服务\",{\"1\":{\"64\":1}}],[\"广泛用于c++的stl中\",{\"1\":{\"64\":1}}],[\"由存储驱动进行管理\",{\"1\":{\"218\":1}}],[\"由消费者自己控制消费速度\",{\"1\":{\"216\":1}}],[\"由消费者对消息进行去重\",{\"1\":{\"64\":1}}],[\"由偏向锁升级而来\",{\"1\":{\"216\":1}}],[\"由本文档衍生的专为面试而生的\",{\"1\":{\"91\":1}}],[\"由操作系统来决定何时统一写入磁盘\",{\"1\":{\"64\":1}}],[\"由系统类加载器加载的类\",{\"1\":{\"64\":1}}],[\"由此可见线程池的队列如果是无界队列\",{\"1\":{\"64\":1}}],[\"由字面意思理解\",{\"1\":{\"64\":1}}],[\"由数组和链表的特性知\",{\"1\":{\"64\":1}}],[\"由于我们常用的官方操作系统镜像基本都是国外的\",{\"1\":{\"231\":1}}],[\"由于容器的本质是进程\",{\"1\":{\"231\":1}}],[\"由于innodb中一页为16kb\",{\"1\":{\"216\":1}}],[\"由于不能同时满足cap\",{\"1\":{\"216\":1}}],[\"由于使用了内存屏障\",{\"1\":{\"216\":1}}],[\"由于很多情况下\",{\"1\":{\"64\":1}}],[\"由于并发收集器不对内存空间进行压缩\",{\"1\":{\"64\":1}}],[\"由于栈只能向上增长\",{\"1\":{\"64\":1}}],[\"由于对象的指针从\",{\"1\":{\"64\":1}}],[\"由于linkedblockingquene的特性\",{\"1\":{\"64\":1}}],[\"由于反射允许代码执行一些在正常情况下不被允许的操作\",{\"1\":{\"64\":1}}],[\"由于cms回收过程中主要分为四步\",{\"1\":{\"64\":1}}],[\"由于\",{\"1\":{\"20\":1}}],[\"由于网络层使用\",{\"1\":{\"10\":1}}],[\"由于一台主机可同时运行多个线程\",{\"1\":{\"9\":1}}],[\"进而最大限度地满足用户的定制化需求\",{\"1\":{\"216\":1}}],[\"进的键值只要有一个\",{\"1\":{\"73\":1}}],[\"进入docker容器存储目录\",{\"1\":{\"218\":1}}],[\"进入容器\",{\"1\":{\"217\":1}}],[\"进入内核态\",{\"1\":{\"64\":1}}],[\"进入这个状态后\",{\"1\":{\"64\":1}}],[\"进行渲染视图\",{\"1\":{\"216\":1}}],[\"进行aop\",{\"1\":{\"216\":1}}],[\"进行判断\",{\"1\":{\"64\":1}}],[\"进行排序\",{\"1\":{\"64\":1}}],[\"进程中执行\",{\"1\":{\"231\":1}}],[\"进程的虚拟地址空间占用远大小其实际占用的物理内存\",{\"1\":{\"64\":1}}],[\"进程的虚拟内存区域都存储在一颗红黑树上\",{\"1\":{\"64\":1}}],[\"进程间的通信\",{\"1\":{\"64\":1}}],[\"进程和线程的区别\",{\"1\":{\"64\":1}}],[\"进程通讯的方式\",{\"1\":{\"64\":1}}],[\"进程\",{\"1\":{\"8\":1,\"64\":1,\"247\":1}}],[\"元素\",{\"1\":{\"64\":1}}],[\"或加上访问模式\",{\"1\":{\"219\":1}}],[\"或限流某个服务来减轻系统压力\",{\"1\":{\"216\":1}}],[\"或将接口实现转成\",{\"1\":{\"216\":1}}],[\"或直接在内存中维护一个自增数字来作为id都是可以的\",{\"1\":{\"216\":1}}],[\"或直接基于tcp协议来实现rpc\",{\"1\":{\"216\":1}}],[\"或网络出现了故障\",{\"1\":{\"216\":1}}],[\"或32个线程\",{\"1\":{\"216\":1}}],[\"或是有一个全局id生成器\",{\"1\":{\"64\":1}}],[\"或程序\",{\"1\":{\"64\":1}}],[\"或按每天一统计或定时统计相关报表\",{\"1\":{\"64\":1}}],[\"或join\",{\"1\":{\"64\":1}}],[\"或notifyall\",{\"1\":{\"64\":1}}],[\"或trigger的调用和触发无法被正确复制的问题\",{\"1\":{\"64\":1}}],[\"或function\",{\"1\":{\"64\":1}}],[\"或\",{\"1\":{\"64\":2}}],[\"或占用连接的请求数\",{\"1\":{\"64\":2}}],[\"或占用线程池线程数\",{\"1\":{\"64\":2}}],[\"或comparable\",{\"1\":{\"64\":1}}],[\"或者仅仅指定容器的端口\",{\"1\":{\"219\":1}}],[\"或者只指定服务名称\",{\"1\":{\"219\":1}}],[\"或者消费者不能重复消费消息\",{\"1\":{\"216\":1}}],[\"或者消费者宕机你怎么处理\",{\"0\":{\"161\":1}}],[\"或者一个节点能存储主键\",{\"1\":{\"216\":1}}],[\"或者一个类的static构造方法加上synchronized之后的锁的影响\",{\"1\":{\"64\":1}}],[\"或者去掉\",{\"1\":{\"216\":1}}],[\"或者由于系统故障导致部分非核心功能不可用\",{\"1\":{\"216\":1}}],[\"或者jvisualvm等工具来进行分析\",{\"1\":{\"216\":1}}],[\"或者如果是b+树的话就是大的在左\",{\"1\":{\"216\":1}}],[\"或者如果是b+树的话就是小的在左\",{\"1\":{\"216\":1}}],[\"或者所可以利用一些数据结构\",{\"1\":{\"216\":1}}],[\"或者查找\",{\"1\":{\"64\":1}}],[\"或者说是可以动态变化的\",{\"1\":{\"64\":1}}],[\"或者说如何处理数据\",{\"1\":{\"64\":1}}],[\"或者说\",{\"1\":{\"64\":1}}],[\"或者i\",{\"1\":{\"64\":1}}],[\"或者发出了i\",{\"1\":{\"64\":1}}],[\"或者叫多个本地事务\",{\"1\":{\"64\":1}}],[\"或者失效\",{\"1\":{\"64\":1}}],[\"或者\",{\"1\":{\"64\":3}}],[\"键\",{\"1\":{\"64\":1}}],[\"键不能重复\",{\"1\":{\"64\":1}}],[\"里包含一个\",{\"1\":{\"83\":1}}],[\"里的\",{\"1\":{\"64\":1}}],[\"里你可以拥有随意个\",{\"1\":{\"64\":1}}],[\"里面提供了对http访问很好的支持\",{\"1\":{\"64\":1}}],[\"输出的顺序就是插入的顺序\",{\"1\":{\"64\":1}}],[\"输入一个网址到显示页面的过程\",{\"0\":{\"39\":1}}],[\"保存证书客户端文件到本地\",{\"0\":{\"227\":1}}],[\"保存脚本后执行\",{\"0\":{\"224\":1}}],[\"保存退出\",{\"1\":{\"217\":1}}],[\"保持容器最小化\",{\"1\":{\"231\":1}}],[\"保持服务一直都在\",{\"1\":{\"219\":1}}],[\"保持统一概念\",{\"1\":{\"216\":1}}],[\"保持了每个元素的插入顺序\",{\"1\":{\"64\":1}}],[\"保证就算重复消费\",{\"1\":{\"216\":1}}],[\"保证消息不丢失\",{\"0\":{\"161\":1}}],[\"保证更高的系统消耗和执行效率\",{\"1\":{\"64\":1}}],[\"保证没有在同一个事务中\",{\"1\":{\"64\":1}}],[\"保证同一个事务中\",{\"1\":{\"64\":1}}],[\"保证接收方来得及接收\",{\"1\":{\"25\":1}}],[\"值的范围值\",{\"1\":{\"79\":1}}],[\"值以及\",{\"1\":{\"77\":1}}],[\"值\",{\"1\":{\"77\":1}}],[\"值>有空值\",{\"1\":{\"64\":2}}],[\"值但最多只能有一个\",{\"1\":{\"64\":1}}],[\"值是可以有重复的\",{\"1\":{\"64\":1}}],[\"值允许有多个null\",{\"1\":{\"64\":1}}],[\"值来查找用户即可\",{\"1\":{\"32\":1}}],[\"概述\",{\"1\":{\"64\":1}}],[\"截获方法返回值并进行加密\",{\"1\":{\"64\":1}}],[\"截获方法入参并进行解密\",{\"1\":{\"64\":1}}],[\"利用redis的setnx\",{\"1\":{\"216\":1}}],[\"利用reentrantlock\",{\"1\":{\"216\":1}}],[\"利用的是zookeeper的临时节点\",{\"1\":{\"216\":1}}],[\"利用雪花算法也可以生成分布式id\",{\"1\":{\"216\":1}}],[\"利用构造函数生成动态代理类的实例对象\",{\"1\":{\"64\":1}}],[\"利用自定义注解\",{\"1\":{\"64\":1}}],[\"利用滑动窗口实现流量控制\",{\"1\":{\"21\":1,\"25\":1}}],[\"法\",{\"1\":{\"64\":1}}],[\"内容如下\",{\"1\":{\"219\":3}}],[\"内部实现是用一颗二叉查找树管理内存分配情况\",{\"1\":{\"216\":1}}],[\"内部再划为\",{\"1\":{\"216\":1}}],[\"内部的方法基本都经过synchronized\",{\"1\":{\"73\":1}}],[\"内部使用二进制协议优化传输速度和带宽\",{\"1\":{\"64\":1}}],[\"内部使用synchronousqueue作为阻塞队列\",{\"1\":{\"64\":1}}],[\"内部暴露\",{\"1\":{\"64\":1}}],[\"内层事务回滚\",{\"1\":{\"64\":2}}],[\"内层事务traa\",{\"1\":{\"64\":1}}],[\"内层的异常抛出到外层捕获也会回滚\",{\"1\":{\"64\":1}}],[\"内外层事务全部不回滚\",{\"1\":{\"64\":2}}],[\"内外层事务全部回滚\",{\"1\":{\"64\":2}}],[\"内嵌了如tomcat\",{\"1\":{\"64\":1}}],[\"内存和线程\",{\"1\":{\"216\":1}}],[\"内存是放不下的\",{\"1\":{\"79\":1}}],[\"内存空间占用\",{\"1\":{\"68\":1}}],[\"内存空间的映射\",{\"1\":{\"64\":1}}],[\"内存负载情况\",{\"1\":{\"64\":2}}],[\"内存淘汰机制\",{\"1\":{\"64\":1}}],[\"内存分配在栈上\",{\"1\":{\"64\":1}}],[\"内存分配在堆上\",{\"1\":{\"64\":1}}],[\"内存泄漏检查\",{\"1\":{\"64\":1}}],[\"内存热点\",{\"1\":{\"64\":1}}],[\"内存模型\",{\"1\":{\"64\":1}}],[\"内存屏障指令保证了所有cpu操作结果都会直接刷到主存中\",{\"1\":{\"64\":1}}],[\"序中使用反射\",{\"1\":{\"64\":1}}],[\"率要比那些非反射操作低得多\",{\"1\":{\"64\":1}}],[\"影响性能\",{\"1\":{\"64\":1}}],[\"深入理解socket网络异常\",{\"1\":{\"64\":1}}],[\"深入理解mybatis原理\",{\"1\":{\"64\":3}}],[\"深入理解垃圾收集器和收集器的选择策略\",{\"1\":{\"64\":1}}],[\"深入理解jvm\",{\"1\":{\"64\":1}}],[\"深入jdk\",{\"1\":{\"64\":1}}],[\"深入分析object\",{\"1\":{\"64\":1}}],[\"深入分析concurrenthashmap1\",{\"1\":{\"64\":2}}],[\"深入浅出concurrenthashmap1\",{\"1\":{\"64\":2}}],[\"引用数据类型==比较的是内存地址\",{\"1\":{\"96\":1}}],[\"引用占小狼的简书\",{\"1\":{\"64\":1}}],[\"引发的bug\",{\"1\":{\"64\":1}}],[\"引起cpu的100\",{\"1\":{\"64\":1}}],[\"引入了jshell这个交互性工具\",{\"1\":{\"64\":1}}],[\"引入了一个新的package\",{\"1\":{\"64\":1}}],[\"引入了模块系统\",{\"1\":{\"64\":1}}],[\"新生代和老年代标记算法优缺点\",{\"0\":{\"178\":1}}],[\"新生代晋升的平均大小大于老年代的剩余空间\",{\"1\":{\"64\":1}}],[\"新手可能出现上传图片只能在服务器本地的情况下\",{\"1\":{\"64\":1}}],[\"新创建了一个线程对象\",{\"1\":{\"64\":1}}],[\"新建一个空文件夹docker\",{\"1\":{\"218\":1}}],[\"新建一个线程执行任务\",{\"1\":{\"64\":1}}],[\"新建并启动容器\",{\"1\":{\"217\":1}}],[\"新建状态\",{\"1\":{\"64\":1}}],[\"新功能\",{\"1\":{\"64\":1}}],[\"新的springwebflux模块\",{\"1\":{\"64\":1}}],[\"新特性\",{\"1\":{\"64\":1}}],[\"被认为可能会改变软件行业\",{\"1\":{\"217\":1}}],[\"被分成了两个集群\",{\"1\":{\"216\":1}}],[\"被拆分了两个或多个\",{\"1\":{\"216\":1}}],[\"被传递的值本身都是不能进行修改的\",{\"1\":{\"64\":1}}],[\"被传递的这个引用的值\",{\"1\":{\"64\":1}}],[\"被程序解释\",{\"1\":{\"64\":1}}],[\"被jvm持有的对象\",{\"1\":{\"64\":1}}],[\"被废弃的垃圾回收器配置组合\",{\"1\":{\"64\":1}}],[\"被禁用怎么办\",{\"1\":{\"31\":1}}],[\"级别\",{\"1\":{\"64\":1}}],[\"日志文件挂载\",{\"1\":{\"219\":2}}],[\"日志记录\",{\"1\":{\"64\":1}}],[\"日志\",{\"1\":{\"64\":1}}],[\"版本等经常变动的步骤放最后\",{\"1\":{\"231\":1}}],[\"版本公众号后台回复\",{\"1\":{\"91\":1}}],[\"版本\",{\"1\":{\"64\":1}}],[\"功能\",{\"1\":{\"64\":1}}],[\"采用发送快照和发送diff日志的方式\",{\"1\":{\"216\":1}}],[\"采用cas和synchronized来保证并发安全\",{\"1\":{\"84\":1}}],[\"采用的数据结构跟hashmap1\",{\"1\":{\"81\":1}}],[\"采用的是基于http的rest方式\",{\"1\":{\"64\":1}}],[\"采用二进制位操作\",{\"1\":{\"79\":1}}],[\"采用链表存储\",{\"1\":{\"68\":1}}],[\"采用数组存储\",{\"1\":{\"68\":1}}],[\"采用多版本开发\",{\"1\":{\"64\":1}}],[\"采用多路\",{\"1\":{\"64\":1}}],[\"采用单线程\",{\"1\":{\"64\":1}}],[\"采用模块化系统的应用程序只需要这些应用程序所需的那部分jdk模块\",{\"1\":{\"64\":1}}],[\"采用一种只有五层协议的体系结构\",{\"1\":{\"7\":1}}],[\"右指针指向相邻的高地址虚拟地址空间\",{\"1\":{\"64\":1}}],[\"著名的linux进程调度completely\",{\"1\":{\"64\":1}}],[\"zoneinfo\",{\"1\":{\"231\":2}}],[\"zookeeper中的领导者选举的流程是怎样的\",{\"1\":{\"216\":1}}],[\"zookeeper只是尽量的在达到强一致性\",{\"1\":{\"216\":1}}],[\"zookeeper分布式锁的特点是高一致性\",{\"1\":{\"216\":1}}],[\"zookeeper的顺序节点\",{\"1\":{\"216\":1}}],[\"zookeeper的特性来生成id\",{\"1\":{\"216\":1}}],[\"zookeeper的选主过程\",{\"1\":{\"64\":1}}],[\"zookeeper集群中节点之间数据是如何同步的\",{\"1\":{\"216\":1}}],[\"zookeeper集群中的脑裂场景\",{\"1\":{\"216\":1}}],[\"zookeeper集群中有leader节点\",{\"1\":{\"216\":1}}],[\"zookeeper集群\",{\"1\":{\"216\":1}}],[\"zookeeper集群之间如何通讯\",{\"1\":{\"64\":1}}],[\"zookeeper主要用于在集群中不同节点之间进行通信\",{\"1\":{\"64\":1}}],[\"zookeeper是一个开放源码的\",{\"1\":{\"64\":1}}],[\"zookeeper是什么\",{\"1\":{\"64\":1}}],[\"zookeeper系列之通信模型\",{\"1\":{\"64\":1}}],[\"zookeeper哪里用到\",{\"1\":{\"64\":1}}],[\"zookeeper\",{\"1\":{\"64\":1,\"219\":7}}],[\"zookeeper等都是基于nio方式实现\",{\"1\":{\"64\":1}}],[\"zk地址\",{\"1\":{\"219\":1}}],[\"zk\",{\"1\":{\"219\":1}}],[\"zk配置\",{\"1\":{\"219\":1}}],[\"zk了解吗\",{\"0\":{\"150\":1}}],[\"zxid如果相等则比较myid\",{\"1\":{\"216\":1}}],[\"zxid大者获胜\",{\"1\":{\"216\":1}}],[\"zab协议是zookeeper用来实现一致性的原子广播协议\",{\"1\":{\"216\":1}}],[\"zadd\",{\"1\":{\"172\":1}}],[\"zero\",{\"1\":{\"216\":1}}],[\"zcard等\",{\"1\":{\"172\":1}}],[\"zrem\",{\"1\":{\"172\":1}}],[\"zrange\",{\"1\":{\"172\":1}}],[\"zset\",{\"1\":{\"64\":1}}],[\"zhong\",{\"0\":{\"233\":1}}],[\"zhouyu\",{\"1\":{\"216\":3}}],[\"zhangsan\",{\"1\":{\"87\":1}}],[\"zhihu\",{\"1\":{\"78\":1}}],[\"zhuge666\",{\"1\":{\"218\":2}}],[\"zhuanlan\",{\"1\":{\"78\":1}}],[\"zhuxinquan61\",{\"1\":{\"64\":1}}],[\"zh\",{\"1\":{\"64\":7}}],[\"z垃圾收集器\",{\"1\":{\"64\":1}}],[\"zixiaomuwu\",{\"1\":{\"37\":1}}],[\"整个\",{\"1\":{\"216\":1}}],[\"整个集群需要从集群节点中选出一个节点作为leader\",{\"1\":{\"216\":1}}],[\"整个集群将没有leader\",{\"1\":{\"216\":1}}],[\"整个过程还有什么\",{\"0\":{\"135\":1}}],[\"整个过程会使用哪些协议\",{\"1\":{\"27\":1}}],[\"整个看起来就像是优化过且线程安全的\",{\"1\":{\"81\":1}}],[\"整理\",{\"1\":{\"64\":2}}],[\"整理算法\",{\"1\":{\"64\":1}}],[\"整体架构\",{\"1\":{\"64\":1}}],[\"整合常用依赖\",{\"1\":{\"64\":1}}],[\"清除算法\",{\"1\":{\"64\":1}}],[\"清理整个yougen的过程\",{\"1\":{\"64\":1}}],[\"标签\",{\"1\":{\"218\":1}}],[\"标识扫描路径\",{\"1\":{\"216\":1}}],[\"标识实现这个接口的类具有随机访问功能\",{\"1\":{\"69\":1}}],[\"标识什么\",{\"1\":{\"69\":1}}],[\"标记垃圾的具体步骤你怎么做\",{\"0\":{\"190\":1}}],[\"标记清理的垃圾回收器\",{\"0\":{\"177\":1}}],[\"标记\",{\"1\":{\"64\":2}}],[\"标志的数据包\",{\"1\":{\"15\":3}}],[\"检查所有的构建指令是否与当前完全一致\",{\"1\":{\"231\":1}}],[\"检查该分区中的最后一条消息\",{\"1\":{\"64\":1}}],[\"检查出这种特殊的情况\",{\"1\":{\"64\":1}}],[\"检查哪些对象在系统中数量最大\",{\"1\":{\"64\":1}}],[\"检查系统哪些方法占用的大量cpu时间\",{\"1\":{\"64\":1}}],[\"数组存储字符串\",{\"1\":{\"94\":1}}],[\"数组的数据进行修改时\",{\"1\":{\"83\":1}}],[\"数组结构组成\",{\"1\":{\"83\":1}}],[\"数组结构和\",{\"1\":{\"83\":1}}],[\"数组是hashmap的主体\",{\"1\":{\"90\":1}}],[\"数组是\",{\"1\":{\"81\":1,\"90\":1}}],[\"数组中每一格就是一个链表\",{\"1\":{\"77\":1}}],[\"数组和链表\",{\"1\":{\"77\":1}}],[\"数组天然支持随机访问\",{\"1\":{\"69\":1}}],[\"数组\",{\"1\":{\"68\":1,\"83\":2,\"231\":1}}],[\"数组多大放在\",{\"1\":{\"64\":1}}],[\"数组双端队列\",{\"1\":{\"64\":1}}],[\"数组+链表组成的\",{\"1\":{\"90\":1}}],[\"数组+链表+红黑树的数据结构来实现\",{\"1\":{\"81\":1}}],[\"数组+链表\",{\"1\":{\"64\":2,\"81\":2,\"84\":1}}],[\"数字签名\",{\"1\":{\"64\":1}}],[\"数量\",{\"1\":{\"64\":1}}],[\"数据文件挂载\",{\"1\":{\"219\":5}}],[\"数据\",{\"1\":{\"218\":2}}],[\"数据序列化层\",{\"1\":{\"216\":1}}],[\"数据冲突怎么解决等等问题\",{\"1\":{\"216\":1}}],[\"数据该怎么合并\",{\"1\":{\"216\":1}}],[\"数据大者在上\",{\"1\":{\"216\":1}}],[\"数据相等的话则开始比较c字段\",{\"1\":{\"216\":1}}],[\"数据小者在下\",{\"1\":{\"216\":1}}],[\"数据的和槽位的分配\",{\"1\":{\"64\":1}}],[\"数据进行定时更新或者实时更新\",{\"1\":{\"64\":1}}],[\"数据每更新一次\",{\"1\":{\"64\":1}}],[\"数据就持久到数据库\",{\"1\":{\"64\":1}}],[\"数据校验\",{\"1\":{\"64\":1}}],[\"数据结构来存储用户信息\",{\"1\":{\"169\":1}}],[\"数据结构跟hashmap1\",{\"1\":{\"84\":1}}],[\"数据结构\",{\"0\":{\"208\":1},\"1\":{\"64\":1,\"68\":1}}],[\"数据加解密等功能\",{\"1\":{\"64\":1}}],[\"数据库应用\",{\"1\":{\"217\":1}}],[\"数据库查询leftjoin以及其他join\",{\"0\":{\"159\":1}}],[\"数据库表设计\",{\"0\":{\"157\":1}}],[\"数据库优化方式\",{\"0\":{\"152\":1}}],[\"数据库事务的几种粒度\",{\"1\":{\"64\":1}}],[\"数据库事务隔离级别\",{\"1\":{\"64\":2}}],[\"数据库的锁\",{\"1\":{\"64\":1}}],[\"数据库的瓶颈很快就能显现出来\",{\"1\":{\"64\":1}}],[\"数据库\",{\"0\":{\"151\":1},\"1\":{\"64\":1}}],[\"数据库mysql\",{\"1\":{\"64\":1}}],[\"数据库sql优化大总结之\",{\"1\":{\"64\":1}}],[\"数据库集群和库表散列\",{\"1\":{\"64\":1}}],[\"数据库连接\",{\"1\":{\"64\":1}}],[\"数据库篇\",{\"1\":{\"64\":2}}],[\"数据保存在服务器端\",{\"1\":{\"32\":1}}],[\"数据保存在客户端\",{\"1\":{\"32\":1}}],[\"数据传送结束后要释放连接\",{\"1\":{\"20\":1}}],[\"数据才可以在客户机和服务器之间传递\",{\"1\":{\"17\":1}}],[\"数据链路层不仅要检错\",{\"1\":{\"11\":1}}],[\"数据链路层就简单地丢弃这个出了差错的帧\",{\"1\":{\"11\":1}}],[\"数据链路层在收到一个帧后\",{\"1\":{\"11\":1}}],[\"数据链路层将网络层交下来的\",{\"1\":{\"11\":1}}],[\"数据链路层\",{\"0\":{\"11\":1},\"1\":{\"11\":1}}],[\"数据报组装成帧\",{\"1\":{\"11\":1}}],[\"数据报\",{\"1\":{\"10\":3}}],[\"调整maxthreads参数来设置tomcat处理连接的最大线程数\",{\"1\":{\"216\":1}}],[\"调用次数和调用时间监控\",{\"1\":{\"216\":1}}],[\"调用量越大则分布越均匀\",{\"1\":{\"216\":1}}],[\"调用await\",{\"1\":{\"216\":1}}],[\"调用方法时传入的参数等\",{\"1\":{\"216\":1}}],[\"调用的是workqueue\",{\"1\":{\"216\":1}}],[\"调用\",{\"1\":{\"74\":2,\"216\":5}}],[\"调用indexedbinarysearch\",{\"1\":{\"69\":1}}],[\"调用了system\",{\"1\":{\"64\":1}}],[\"调优不是一蹴而就的\",{\"1\":{\"216\":1}}],[\"调优及\",{\"1\":{\"64\":1}}],[\"调优工具\",{\"1\":{\"64\":1}}],[\"调成什么值\",{\"1\":{\"64\":2}}],[\"沙箱安全机制\",{\"1\":{\"64\":1}}],[\"动态扩容微服务\",{\"1\":{\"219\":1}}],[\"动态代理有哪些\",{\"0\":{\"102\":1}}],[\"动态代理\",{\"0\":{\"134\":1},\"1\":{\"64\":2}}],[\"动作过程\",{\"1\":{\"64\":1}}],[\"儿子自己想办法去完成\",{\"1\":{\"64\":1}}],[\"倘若父类加载器无法完成此加载任务\",{\"1\":{\"64\":1}}],[\"负责数据的可靠传输\",{\"1\":{\"216\":1}}],[\"负责造一条advisorchain\",{\"1\":{\"216\":1}}],[\"负责维护node<\",{\"1\":{\"64\":1}}],[\"负责加载用户自定义路径下的类包\",{\"1\":{\"64\":1}}],[\"负责加载classpath路径下的类包\",{\"1\":{\"64\":1}}],[\"负责加载jre扩展目录ext中jar类包\",{\"1\":{\"64\":1}}],[\"负责加载jre的核心类库\",{\"1\":{\"64\":1}}],[\"负载均衡的原理\",{\"1\":{\"64\":2}}],[\"负载均衡技术发展了多年\",{\"1\":{\"64\":1}}],[\"负载均衡将是大型网站解决高负荷访问和大量并发请求采用的终极解决办法\",{\"1\":{\"64\":1}}],[\"负载均衡\",{\"0\":{\"45\":1},\"1\":{\"45\":1,\"64\":1,\"216\":1}}],[\"切换为serialold单线程做mark\",{\"1\":{\"64\":1}}],[\"又不希望出现重复数据时\",{\"1\":{\"171\":1}}],[\"又一次内存分配失败\",{\"1\":{\"64\":1}}],[\"又能提高性能\",{\"1\":{\"64\":1}}],[\"又尝试直接晋升到old区又放不下\",{\"1\":{\"64\":1}}],[\"又叫做\",{\"1\":{\"45\":1}}],[\"去永久代\",{\"1\":{\"64\":1}}],[\"粒度\",{\"1\":{\"64\":1}}],[\"具备过期时间的key\",{\"1\":{\"64\":1}}],[\"具有原子性\",{\"1\":{\"64\":1}}],[\"具体使用方式如下\",{\"1\":{\"231\":1}}],[\"具体命令如下\",{\"1\":{\"171\":1}}],[\"具体怎么做\",{\"1\":{\"64\":2}}],[\"具体过程请参考经典的阮一峰先生的博客\",{\"1\":{\"48\":1}}],[\"具体过程\",{\"0\":{\"40\":1}}],[\"具体可以参考下面这篇文章\",{\"1\":{\"27\":1}}],[\"xvf\",{\"1\":{\"231\":2}}],[\"x509\",{\"1\":{\"223\":3}}],[\"x86\",{\"1\":{\"217\":1}}],[\"xiaohong\",{\"1\":{\"87\":1}}],[\"xiaoming100001\",{\"1\":{\"64\":1}}],[\"xss512k\",{\"1\":{\"218\":1}}],[\"xss128k\",{\"1\":{\"64\":6}}],[\"xss来设置\",{\"1\":{\"64\":1}}],[\"xmx1g\",{\"1\":{\"219\":10}}],[\"xmx1028m\",{\"1\":{\"218\":1}}],[\"xmx512m\",{\"1\":{\"219\":1}}],[\"xmx3550m\",{\"1\":{\"64\":5}}],[\"xmx3800m\",{\"1\":{\"64\":1}}],[\"xms1g\",{\"1\":{\"219\":10}}],[\"xms1028m\",{\"1\":{\"218\":1}}],[\"xms512m\",{\"1\":{\"219\":1}}],[\"xms3550m\",{\"1\":{\"64\":5}}],[\"xms3800m\",{\"1\":{\"64\":1}}],[\"xmn512m\",{\"1\":{\"218\":1}}],[\"xmn设置\",{\"1\":{\"64\":1}}],[\"xmn2g\",{\"1\":{\"64\":6}}],[\"xml\",{\"1\":{\"64\":1,\"216\":1,\"219\":2}}],[\"xml配置\",{\"1\":{\"64\":1}}],[\"xa\",{\"1\":{\"64\":1}}],[\"x新特性\",{\"1\":{\"64\":2}}],[\"xxx\",{\"1\":{\"64\":1}}],[\"xx\",{\"1\":{\"64\":30,\"216\":2,\"218\":2,\"219\":10}}],[\"xlog\",{\"1\":{\"64\":1}}],[\"xlgen157387\",{\"1\":{\"64\":2}}],[\"场景题\",{\"0\":{\"199\":1}}],[\"场景6\",{\"1\":{\"64\":1}}],[\"场景5\",{\"1\":{\"64\":1}}],[\"场景4\",{\"1\":{\"64\":1}}],[\"场景3\",{\"1\":{\"64\":1}}],[\"场景2\",{\"1\":{\"64\":1}}],[\"场景1\",{\"1\":{\"64\":1}}],[\"场景\",{\"1\":{\"64\":5}}],[\"策略模式国\",{\"1\":{\"216\":1}}],[\"策略\",{\"1\":{\"64\":1}}],[\"写得太好了\",{\"1\":{\"250\":1}}],[\"写时复制\",{\"1\":{\"218\":2}}],[\"写在该指令后的\",{\"1\":{\"218\":1}}],[\"写操作会加锁\",{\"1\":{\"216\":1}}],[\"写操作在新数组上进行\",{\"1\":{\"216\":1}}],[\"写操作建议使用failfast快速失败\",{\"1\":{\"64\":1}}],[\"写2种\",{\"0\":{\"213\":1}}],[\"写入时先写入pagecache\",{\"1\":{\"64\":1}}],[\"写请求首先由leader副本处理\",{\"1\":{\"64\":1}}],[\"写代码分别使得jvm的堆\",{\"1\":{\"64\":1}}],[\"写锁\",{\"1\":{\"64\":3}}],[\"写这篇文章真的非常纠结\",{\"1\":{\"59\":1}}],[\"读操作在原数组上进行\",{\"1\":{\"216\":1}}],[\"读操作建议使用failover失败自动切换\",{\"1\":{\"64\":1}}],[\"读写锁\",{\"0\":{\"117\":1}}],[\"读写分离\",{\"1\":{\"64\":1}}],[\"读写等\",{\"1\":{\"57\":1}}],[\"读锁\",{\"1\":{\"64\":2}}],[\"读已提交\",{\"1\":{\"64\":1}}],[\"读取\",{\"1\":{\"64\":2}}],[\"读\",{\"1\":{\"64\":1}}],[\"模板方法模式4\",{\"1\":{\"216\":1}}],[\"模拟oom和stack\",{\"0\":{\"183\":1}}],[\"模拟死锁场景\",{\"1\":{\"64\":2}}],[\"模块化的思想在软件设计的方方面面都有体现\",{\"1\":{\"64\":1}}],[\"模式启动的进程在容器中实际上并不是\",{\"1\":{\"231\":1}}],[\"模式启动容器时相当于我们把启动命令放在了\",{\"1\":{\"231\":1}}],[\"模式启动容器时\",{\"1\":{\"231\":1}}],[\"模式\",{\"1\":{\"64\":1}}],[\"独立观察\",{\"1\":{\"64\":1}}],[\"状态超时\",{\"1\":{\"64\":1}}],[\"状态会发生变化\",{\"1\":{\"64\":1}}],[\"状态标志\",{\"1\":{\"64\":1}}],[\"状态码是由\",{\"1\":{\"54\":1}}],[\"状态码\",{\"0\":{\"28\":1,\"54\":1},\"1\":{\"53\":1}}],[\"放在后面命中缓存的概率是一样的\",{\"1\":{\"238\":1}}],[\"放在常量池中\",{\"1\":{\"96\":1}}],[\"放在栈中\",{\"1\":{\"64\":1}}],[\"放在哪儿\",{\"1\":{\"64\":1}}],[\"放在这个部分是否合适\",{\"1\":{\"47\":1}}],[\"放弃业务操作处理\",{\"1\":{\"64\":1}}],[\"放不下新任务时则新建非核心线程入池\",{\"1\":{\"64\":1}}],[\"只考虑基础运行环境的配置\",{\"1\":{\"233\":1}}],[\"只提供编译好的二进制\",{\"1\":{\"233\":1}}],[\"只将端口暴露给连接的服务\",{\"1\":{\"219\":1}}],[\"只下载不存在的镜像层\",{\"1\":{\"218\":1}}],[\"只需要比较构建指令即可判断是否需要使用缓存\",{\"1\":{\"231\":1}}],[\"只需要编写一个docker\",{\"1\":{\"219\":1}}],[\"只需要数秒就能完成\",{\"1\":{\"217\":1}}],[\"只需要少量线程按需处理维护的大量长期连接\",{\"1\":{\"64\":1}}],[\"只有一个key的环境变量可以在运行compose的机器上找到对\",{\"1\":{\"219\":1}}],[\"只有在要新写入一个文件时才分配空间\",{\"1\":{\"218\":1}}],[\"只有当要对文件进行写操作时\",{\"1\":{\"218\":1}}],[\"只有当前线程可以访问该变量\",{\"1\":{\"64\":1}}],[\"只有到了暴露给用户使用时\",{\"1\":{\"216\":1}}],[\"只不过是springboot默认给我们提供的\",{\"1\":{\"216\":1}}],[\"只不过\",{\"1\":{\"216\":1}}],[\"只不过我们上面举的几个例子都是升序排序\",{\"1\":{\"216\":1}}],[\"只说应用层面的\",{\"0\":{\"199\":1}}],[\"只取a表中与b表不共用的那部分\",{\"0\":{\"159\":1}}],[\"只是为了全局概览\",{\"1\":{\"216\":1}}],[\"只是为了兼容旧版本\",{\"1\":{\"81\":1}}],[\"只是不那么透明\",{\"1\":{\"216\":1}}],[\"只是想让看图者更直观的了解哪些类分属于客户端与服务器端\",{\"1\":{\"216\":1}}],[\"只是排序的形式各不相同而已\",{\"1\":{\"216\":1}}],[\"只是给读者一个浅显的认知\",{\"1\":{\"59\":1}}],[\"只能排队等着\",{\"1\":{\"216\":1}}],[\"只能代理接口\",{\"1\":{\"64\":1}}],[\"只能这个事务对其进行读写\",{\"1\":{\"64\":1}}],[\"只存在传递基本类型和对象引用的问题\",{\"1\":{\"64\":1}}],[\"只等待获取cpu的使用权\",{\"1\":{\"64\":1}}],[\"只要哈希函数映射得比较均匀松散\",{\"1\":{\"79\":1}}],[\"只要未超出阈值都是可以容忍的\",{\"1\":{\"64\":1}}],[\"只要是涉及到的对象不能从gc\",{\"1\":{\"64\":1}}],[\"只要\",{\"1\":{\"64\":1}}],[\"只要线程池中有空闲的核心线程\",{\"1\":{\"64\":1}}],[\"只允许一个\",{\"1\":{\"64\":1}}],[\"时将链表\",{\"1\":{\"84\":1}}],[\"时间\",{\"1\":{\"231\":1}}],[\"时间复杂度为\",{\"1\":{\"69\":2}}],[\"时间复杂度近似为o\",{\"1\":{\"68\":1}}],[\"时间复杂度就为\",{\"1\":{\"68\":1}}],[\"时间复杂度\",{\"1\":{\"64\":3}}],[\"时间支持在配置文件中配置\",{\"1\":{\"64\":2}}],[\"时间单位为ns\",{\"1\":{\"64\":1}}],[\"时按entry的插入顺序来排序\",{\"1\":{\"64\":1}}],[\"时\",{\"1\":{\"64\":3,\"73\":1,\"78\":1,\"90\":1,\"216\":2,\"231\":1}}],[\"核心是解决服务调用间的问题\",{\"1\":{\"216\":1}}],[\"核心代码就是下面两行\",{\"1\":{\"216\":1}}],[\"核心配置有\",{\"1\":{\"64\":1}}],[\"核心容器的其他改进\",{\"1\":{\"64\":1}}],[\"核心容器的改进\",{\"1\":{\"64\":2}}],[\"核心说明\",{\"1\":{\"64\":1}}],[\"核心线程数量大小\",{\"1\":{\"64\":1}}],[\"核心参数\",{\"1\":{\"64\":1}}],[\"做了什么事情\",{\"1\":{\"64\":2}}],[\"做了什么操作\",{\"1\":{\"64\":1}}],[\"做到每个线程有自己的copy\",{\"1\":{\"64\":1}}],[\"做一次加密就可以解决这个问题了\",{\"1\":{\"47\":1}}],[\"临界区\",{\"1\":{\"64\":1}}],[\"互不影响\",{\"1\":{\"218\":1}}],[\"互相隔离\",{\"1\":{\"218\":1}}],[\"互斥量\",{\"1\":{\"64\":1}}],[\"互斥同步\",{\"1\":{\"64\":1}}],[\"互联网上每一台计算机的唯一标识是它的\",{\"1\":{\"41\":1}}],[\"互联网使用的网络层协议是无连接的网际协议\",{\"1\":{\"10\":1}}],[\"互联网是由大量的异构\",{\"1\":{\"10\":1}}],[\"父进程并未对其发出的sigchld信号进行适当处理\",{\"1\":{\"64\":1}}],[\"僵死进程是指子进程退出时\",{\"1\":{\"64\":1}}],[\"​\",{\"1\":{\"64\":61,\"216\":2,\"217\":9,\"218\":3,\"219\":1}}],[\"看是否超过一半的节点都和自己所投的节点是一样的\",{\"1\":{\"216\":1}}],[\"看是否能避免某些对象的创建\",{\"1\":{\"216\":1}}],[\"看以下代码回答问题\",{\"1\":{\"216\":3}}],[\"看到这里你也许会问\",{\"1\":{\"231\":1}}],[\"看到这里\",{\"1\":{\"216\":1}}],[\"看你用没用过\",{\"0\":{\"130\":1}}],[\"看过哪些源代码\",{\"1\":{\"64\":1}}],[\"看了网上许多相关的文章\",{\"1\":{\"39\":1}}],[\"九\",{\"1\":{\"64\":2}}],[\"八\",{\"1\":{\"64\":2}}],[\"嵌套事务实现\",{\"1\":{\"64\":2}}],[\"行转列\",{\"1\":{\"64\":1}}],[\"行级锁都是基于索引的\",{\"1\":{\"64\":1}}],[\"行级锁\",{\"1\":{\"64\":3}}],[\"行锁又分共享锁和排他锁\",{\"1\":{\"64\":1}}],[\"行锁\",{\"1\":{\"64\":4}}],[\"乐观锁\",{\"1\":{\"64\":5}}],[\"乐观锁的业务场景及实现方式\",{\"1\":{\"64\":2}}],[\"悲观锁\",{\"1\":{\"64\":5}}],[\"排好序之后\",{\"1\":{\"216\":1}}],[\"排查思路是什么\",{\"0\":{\"204\":1}}],[\"排序其实就是对数据比较大小\",{\"1\":{\"216\":1}}],[\"排序有很多中方式\",{\"1\":{\"216\":1}}],[\"排序方法\",{\"1\":{\"64\":1}}],[\"排序算法时间复杂度\",{\"1\":{\"64\":1}}],[\"排序算法与时空复杂度\",{\"1\":{\"64\":1}}],[\"排序算法以及各自的时间复杂度\",{\"1\":{\"64\":1}}],[\"排序算法\",{\"0\":{\"0\":1}}],[\"排队\",{\"1\":{\"64\":1}}],[\"排它锁\",{\"1\":{\"64\":3}}],[\"排他锁\",{\"1\":{\"64\":2}}],[\"七大查找算法\",{\"1\":{\"64\":1}}],[\"七\",{\"1\":{\"64\":3}}],[\"各层说明\",{\"1\":{\"216\":1}}],[\"各种消息队列\",{\"1\":{\"216\":1}}],[\"各种消息队列对比\",{\"1\":{\"64\":1}}],[\"各种礼物排行榜\",{\"1\":{\"172\":1}}],[\"各种语言基本都有自己的缓存模块和方法\",{\"1\":{\"64\":1}}],[\"各种协议与http协议之间的关系\",{\"0\":{\"29\":1}}],[\"各个线程都处在什么样的状态下\",{\"1\":{\"64\":1}}],[\"各自负责各自的区块\",{\"1\":{\"64\":1}}],[\"各产品的优缺点介绍\",{\"1\":{\"64\":2}}],[\"六大web负载均衡原理与实现\",{\"1\":{\"64\":1}}],[\"六\",{\"1\":{\"64\":2}}],[\"事件监听机制\",{\"1\":{\"216\":1}}],[\"事件发布等功能\",{\"1\":{\"216\":1}}],[\"事物四种实现方式\",{\"1\":{\"64\":1}}],[\"事务处理机制\",{\"1\":{\"64\":1}}],[\"事务执行成功则认为此消息被消费\",{\"1\":{\"64\":1}}],[\"事务模型\",{\"1\":{\"64\":1}}],[\"事务消息\",{\"1\":{\"64\":1}}],[\"事务嵌套\",{\"1\":{\"64\":1}}],[\"事务的隔离级别\",{\"0\":{\"137\":1}}],[\"事务的传播机制7种\",{\"0\":{\"137\":1}}],[\"事务的传播行为\",{\"1\":{\"64\":2}}],[\"事务的四个特性\",{\"1\":{\"64\":1}}],[\"事务的提交分为两个阶段\",{\"1\":{\"64\":1}}],[\"事务的执行的前后数据的完整性保持一致\",{\"1\":{\"64\":1}}],[\"事务一旦结束\",{\"1\":{\"64\":1}}],[\"事务特性\",{\"1\":{\"64\":1}}],[\"事务逻辑上的一组操作\",{\"1\":{\"64\":1}}],[\"事务管理器\",{\"1\":{\"64\":1}}],[\"事务管理\",{\"1\":{\"64\":2}}],[\"事务介绍\",{\"1\":{\"64\":2}}],[\"事务隔离级别\",{\"1\":{\"64\":1}}],[\"事实上\",{\"1\":{\"42\":1,\"216\":1}}],[\"五步定位性能瓶颈\",{\"1\":{\"64\":1}}],[\"五万人并发抢票怎么实现\",{\"1\":{\"64\":1}}],[\"五大核心接口\",{\"1\":{\"64\":1}}],[\"五大特性\",{\"1\":{\"64\":1}}],[\"五\",{\"1\":{\"64\":2}}],[\"区别是什么\",{\"1\":{\"216\":1}}],[\"区别式poll\",{\"1\":{\"216\":1}}],[\"区别呢\",{\"0\":{\"71\":1}}],[\"区别\",{\"0\":{\"68\":1,\"102\":1,\"105\":1,\"119\":1},\"1\":{\"64\":8}}],[\"四\",{\"1\":{\"64\":6}}],[\"四次挥手\",{\"1\":{\"18\":1}}],[\"类和对象的关系\",{\"1\":{\"217\":1}}],[\"类中的属性在多一些\",{\"1\":{\"216\":1}}],[\"类中使用\",{\"1\":{\"94\":1}}],[\"类覆盖了\",{\"1\":{\"96\":1}}],[\"类没有覆盖\",{\"1\":{\"96\":1}}],[\"类型存放了我本人的一些信息\",{\"1\":{\"169\":1}}],[\"类型的\",{\"1\":{\"169\":1}}],[\"类型的对象时\",{\"1\":{\"96\":1}}],[\"类型进行改变的时候\",{\"1\":{\"94\":1}}],[\"类型等\",{\"1\":{\"64\":1}}],[\"类的实现改用\",{\"1\":{\"94\":1}}],[\"类加载过程\",{\"0\":{\"188\":1}}],[\"类加载\",{\"1\":{\"64\":1}}],[\"类加载器\",{\"1\":{\"64\":3}}],[\"类\",{\"1\":{\"64\":1,\"94\":1}}],[\"类锁\",{\"1\":{\"64\":1}}],[\"类来包装共享变量\",{\"1\":{\"64\":1}}],[\"类似于docker\",{\"1\":{\"219\":1}}],[\"类似于dockerfile总的cmd指令\",{\"1\":{\"219\":1}}],[\"类似于\",{\"1\":{\"217\":1}}],[\"类似于xml中的<bean>标签\",{\"1\":{\"216\":1}}],[\"类似与http协议\",{\"1\":{\"216\":1}}],[\"类似\",{\"1\":{\"51\":1}}],[\"类似的还有\",{\"1\":{\"8\":1}}],[\"双亲委派指得是\",{\"1\":{\"216\":1}}],[\"双亲委派模型的好处\",{\"1\":{\"64\":2}}],[\"双向循环链表\",{\"1\":{\"70\":1}}],[\"双向链表和双向循环链表\",{\"0\":{\"70\":1}}],[\"双向链表\",{\"1\":{\"68\":1,\"70\":1,\"89\":1}}],[\"双重检查\",{\"1\":{\"64\":1}}],[\"双方通信无误必须是两者互相发送信息都无误\",{\"1\":{\"18\":1}}],[\"三大范式\",{\"0\":{\"158\":1}}],[\"三大注解有什么作用\",{\"0\":{\"128\":1}}],[\"三个方面解决性能问题的基本思路和方法\",{\"1\":{\"64\":1}}],[\"三个channel使用\",{\"1\":{\"64\":1}}],[\"三阶段提交\",{\"1\":{\"64\":2}}],[\"三\",{\"1\":{\"64\":6,\"216\":1}}],[\"三次握手的目的是建立可靠的通信信道\",{\"1\":{\"16\":1}}],[\"三次握手\",{\"1\":{\"15\":1}}],[\"三次握手漫画图解\",{\"0\":{\"15\":1}}],[\"三次握手和四次挥手\",{\"0\":{\"14\":1}}],[\"原型模式\",{\"1\":{\"216\":1}}],[\"原型bean\",{\"1\":{\"216\":1}}],[\"原本应该是统一的一个集群对外提供服务的\",{\"1\":{\"216\":1}}],[\"原本发往该提供者的请求\",{\"1\":{\"64\":1}}],[\"原始数组\",{\"1\":{\"86\":2}}],[\"原因\",{\"0\":{\"163\":1}}],[\"原因不明\",{\"1\":{\"64\":1}}],[\"原因是因为\",{\"1\":{\"57\":1}}],[\"原子\",{\"1\":{\"64\":1}}],[\"原子类的实现\",{\"1\":{\"64\":1}}],[\"原子性\",{\"1\":{\"64\":1,\"216\":1}}],[\"原子性与可见性\",{\"1\":{\"64\":1}}],[\"原码分析\",{\"1\":{\"64\":1}}],[\"原理\",{\"1\":{\"64\":2,\"218\":1}}],[\"什么情况下触发垃圾回收\",{\"1\":{\"64\":1}}],[\"什么情况下我们需要破坏双亲委派模型\",{\"1\":{\"64\":2}}],[\"什么叫线程安全\",{\"1\":{\"64\":2}}],[\"什么时候使用cmd呢\",{\"1\":{\"231\":1}}],[\"什么时候使用字符流\",{\"1\":{\"64\":2}}],[\"什么时候使用字节流\",{\"1\":{\"64\":2}}],[\"什么时候触发fullgc\",{\"0\":{\"182\":1}}],[\"什么时候gc\",{\"1\":{\"64\":1}}],[\"什么时候会触发full\",{\"1\":{\"64\":2}}],[\"什么时候会出现僵死进程\",{\"1\":{\"64\":2}}],[\"什么是服务降级\",{\"1\":{\"216\":1}}],[\"什么是服务熔断\",{\"1\":{\"216\":1}}],[\"什么是服务限流\",{\"1\":{\"216\":1}}],[\"什么是服务雪崩\",{\"1\":{\"216\":1}}],[\"什么是zab协议\",{\"1\":{\"216\":1}}],[\"什么是分布式事务\",{\"1\":{\"216\":1}}],[\"什么是rpc\",{\"1\":{\"216\":1}}],[\"什么是base理论\",{\"1\":{\"216\":1}}],[\"什么是cap理论\",{\"1\":{\"216\":1}}],[\"什么是控制\",{\"1\":{\"216\":1}}],[\"什么是gc\",{\"1\":{\"216\":1}}],[\"什么是接口级注册\",{\"1\":{\"216\":1}}],[\"什么是脑裂\",{\"1\":{\"216\":1}}],[\"什么是集群脑裂\",{\"1\":{\"216\":1}}],[\"什么是mysql中的降序索引\",{\"0\":{\"216\":1}}],[\"什么是面向无连接\",{\"0\":{\"122\":1}}],[\"什么是面向连接\",{\"0\":{\"122\":1}}],[\"什么是根搜索算法\",{\"1\":{\"64\":1}}],[\"什么是两阶段提交\",{\"1\":{\"64\":1}}],[\"什么是事务\",{\"1\":{\"64\":1}}],[\"什么是线程安全\",{\"1\":{\"64\":1}}],[\"什么是双亲委派机制\",{\"1\":{\"64\":2}}],[\"什么事两阶段提交\",{\"1\":{\"64\":1}}],[\"什么场景下该使用spring\",{\"1\":{\"64\":2}}],[\"什么实现线程安全\",{\"1\":{\"64\":1}}],[\"什么都不能确认\",{\"1\":{\"16\":1}}],[\"你应该避免使用以下格式\",{\"1\":{\"231\":1}}],[\"你可能在想\",{\"1\":{\"231\":1}}],[\"你可以在一个配置文件\",{\"1\":{\"219\":1}}],[\"你可以直接仅仅修改这个对象中的某个字段的值\",{\"1\":{\"169\":1}}],[\"你可以从kafka\",{\"1\":{\"64\":1}}],[\"你可以根据你的后续需要从\",{\"1\":{\"64\":1}}],[\"你可以看到\",{\"1\":{\"44\":1}}],[\"你们项目如何排查jvm问题\",{\"1\":{\"216\":1}}],[\"你们的zookeeper的节点加密是用的什么方式\",{\"1\":{\"64\":1}}],[\"你首先会做什么\",{\"1\":{\"216\":1}}],[\"你是怎么实现幂等的\",{\"0\":{\"202\":1}}],[\"你怎么理解幂等\",{\"0\":{\"201\":1}}],[\"你负责了哪些\",{\"0\":{\"193\":1}}],[\"你项目中用到没有\",{\"0\":{\"167\":1}}],[\"你为啥用\",{\"0\":{\"144\":1}}],[\"你使用事务哪种级别\",{\"0\":{\"137\":1}}],[\"你还了解别的分布式框架吗\",{\"1\":{\"64\":1}}],[\"你知道的还有哪些\",{\"1\":{\"64\":1}}],[\"你会拥有包括偏移量和消息发送的messageandoffset对象\",{\"1\":{\"64\":1}}],[\"你会注意到它会获取包括偏移量作为列表的multifetchresponse对象\",{\"1\":{\"64\":1}}],[\"你会发现4>3\",{\"1\":{\"216\":1}}],[\"你会发现\",{\"1\":{\"64\":1}}],[\"你必须遵循两件事\",{\"1\":{\"64\":1}}],[\"你如何能从kafka得到准确的信息\",{\"1\":{\"64\":1}}],[\"你的项目中使用过缓存机制吗\",{\"1\":{\"64\":2}}],[\"你的信息一清二白的写在简历上\",{\"1\":{\"64\":1}}],[\"你觉得可能会是哪些方面\",{\"1\":{\"64\":2}}],[\"你了解多少\",{\"1\":{\"64\":1}}],[\"你无法保证每个元素的存储顺序\",{\"1\":{\"64\":1}}],[\"yes\",{\"1\":{\"219\":1}}],[\"y\",{\"1\":{\"217\":5,\"231\":5}}],[\"yum\",{\"1\":{\"217\":12,\"219\":2,\"231\":6}}],[\"yuque\",{\"1\":{\"216\":1}}],[\"ygxrv\",{\"1\":{\"216\":1}}],[\"yml中\",{\"1\":{\"240\":1}}],[\"yml内容如下\",{\"1\":{\"219\":1}}],[\"yml里的服务的端口映射和容器名称都注释掉\",{\"1\":{\"219\":1}}],[\"yml文件配置\",{\"1\":{\"219\":4}}],[\"yml文件官方文档\",{\"1\":{\"219\":1}}],[\"yml配置有变化的容器并启动\",{\"1\":{\"219\":1}}],[\"yml配置文件中\",{\"1\":{\"64\":1}}],[\"yml外部的容器\",{\"1\":{\"219\":1}}],[\"yml常用指令\",{\"1\":{\"219\":1}}],[\"yml所在目录的目录名称\",{\"1\":{\"219\":1}}],[\"yml描述了容器的配置\",{\"1\":{\"219\":1}}],[\"yml\",{\"1\":{\"216\":4,\"219\":26}}],[\"yaml格式\",{\"1\":{\"219\":1}}],[\"yahoo中国当初接近2000台服务器使用了三四台alteon就搞定了\",{\"1\":{\"64\":1}}],[\"yangchangyong0\",{\"1\":{\"64\":1}}],[\"yaopeng\",{\"1\":{\"13\":1}}],[\"yzj5208\",{\"1\":{\"64\":1}}],[\"you\",{\"1\":{\"231\":4}}],[\"younggen区内存不足\",{\"1\":{\"64\":1}}],[\"youdao\",{\"1\":{\"64\":1}}],[\"突然变慢你是怎么排查的\",{\"0\":{\"63\":1}}],[\"执行如下扩容命令\",{\"1\":{\"219\":1}}],[\"执行如下命令修改镜像名字\",{\"1\":{\"218\":1}}],[\"执行\",{\"1\":{\"219\":1}}],[\"执行以下命令\",{\"1\":{\"218\":1}}],[\"执行命令了\",{\"1\":{\"217\":1}}],[\"执行该命令后\",{\"1\":{\"217\":2,\"218\":1}}],[\"执行系统task\",{\"1\":{\"216\":1}}],[\"执行结果都会打包进入\",{\"1\":{\"218\":1}}],[\"执行结果\",{\"1\":{\"216\":1}}],[\"执行回调\",{\"1\":{\"216\":1}}],[\"执行完上述步骤后\",{\"1\":{\"231\":1}}],[\"执行完成返回\",{\"1\":{\"216\":1}}],[\"执行完成前\",{\"1\":{\"57\":1}}],[\"执行完后就会进入terminated状态\",{\"1\":{\"216\":1}}],[\"执行add\",{\"1\":{\"68\":1}}],[\"执行程序代码\",{\"1\":{\"64\":1}}],[\"执行任务时\",{\"1\":{\"64\":1}}],[\"执行业务操作处理\",{\"1\":{\"64\":1}}],[\"执行过程原理\",{\"1\":{\"64\":2}}],[\"执行过程\",{\"0\":{\"62\":1}}],[\"解除\",{\"1\":{\"216\":1}}],[\"解释如何减少isr中的扰动\",{\"1\":{\"64\":1}}],[\"解释如何提高远程用户的吞吐量\",{\"1\":{\"64\":1}}],[\"解释一下\",{\"1\":{\"64\":1}}],[\"解释kafka的用户如何消费信息\",{\"1\":{\"64\":1}}],[\"解释kafka的zookeeper是什么\",{\"1\":{\"64\":1}}],[\"解释dhcp的原理\",{\"0\":{\"62\":1}}],[\"解决方案是使用布隆过滤器\",{\"1\":{\"216\":1}}],[\"解决方案就是考虑这个热点key不设过期时间\",{\"1\":{\"216\":1}}],[\"解决方式就是服务降级和服务熔断\",{\"1\":{\"216\":1}}],[\"解决办法就是在过期时间上增加一点随机值\",{\"1\":{\"216\":1}}],[\"解决办法是\",{\"1\":{\"216\":1}}],[\"解决冲突\",{\"1\":{\"90\":1}}],[\"解决产生冲突的问题\",{\"1\":{\"64\":1}}],[\"解决以上问题后\",{\"1\":{\"64\":1}}],[\"解决读问题\",{\"1\":{\"64\":1}}],[\"解悉过程\",{\"1\":{\"64\":1}}],[\"解答参照\",{\"1\":{\"64\":1}}],[\"解析配置生成配置类\",{\"1\":{\"216\":1}}],[\"解析后返回具体\",{\"1\":{\"216\":1}}],[\"解析并梅造\",{\"1\":{\"216\":1}}],[\"解析得到所要访问的servlet\",{\"1\":{\"216\":1}}],[\"解析引擎完成的\",{\"1\":{\"57\":1}}],[\"解析是一个递归查询的过程\",{\"1\":{\"42\":1}}],[\"解析过程\",{\"0\":{\"42\":1}}],[\"解析的过程就是寻找哪台机器上有你需要资源的过程\",{\"1\":{\"41\":1}}],[\"解析\",{\"0\":{\"41\":1},\"1\":{\"39\":1,\"41\":1}}],[\"囊括了很多的功能\",{\"1\":{\"59\":1}}],[\"知道如何去查询\",{\"1\":{\"59\":1}}],[\"知道了\",{\"1\":{\"19\":1}}],[\"另一个线程不能使用\",{\"1\":{\"81\":1}}],[\"另一个是在集群结点中用作内部数据结构\",{\"1\":{\"64\":1}}],[\"另一方面也表明后续这个库可能相对来说不会有大动作的优化维护\",{\"1\":{\"64\":1}}],[\"另一方面\",{\"1\":{\"58\":1,\"64\":1}}],[\"另外我看教程中env\",{\"1\":{\"242\":1}}],[\"另外一种格式为cmd\",{\"1\":{\"231\":1}}],[\"另外一个目录在上层\",{\"1\":{\"218\":1}}],[\"另外两个是devicemapper驱动依赖的\",{\"1\":{\"217\":1}}],[\"另外如果搭建一个高可用的redis集群也是防止缓存雪崩的有效手段\",{\"1\":{\"216\":1}}],[\"另外zookeeper中的数据都是存在内存中的\",{\"1\":{\"216\":1}}],[\"另外tomcat中设计了一些缓存区\",{\"1\":{\"216\":1}}],[\"另外tomcat还利用自定义加载器实现了热加载功能\",{\"1\":{\"216\":1}}],[\"另外springboot中的自动配置功能的实现\",{\"1\":{\"216\":1}}],[\"另外由于这些自动配置类\",{\"1\":{\"216\":1}}],[\"另外可以通过\",{\"1\":{\"170\":1}}],[\"另外其他\",{\"1\":{\"87\":1}}],[\"另外推荐一篇把双向链表讲清楚的文章\",{\"1\":{\"70\":1}}],[\"另外还有一种字符\",{\"1\":{\"64\":1}}],[\"另外在这里为公司的产品打个广告\",{\"1\":{\"59\":1}}],[\"另外在停止等待协议中若收到重复分组\",{\"1\":{\"23\":1}}],[\"另外\",{\"1\":{\"10\":1,\"64\":2,\"73\":1,\"90\":1,\"216\":2,\"218\":1}}],[\"则n层以后的缓存都会失效\",{\"1\":{\"239\":1}}],[\"则不使用缓存\",{\"1\":{\"231\":1}}],[\"则不会去检查是否有线程在排队\",{\"1\":{\"216\":1}}],[\"则访问服务名docker会自动帮我们负载均衡去访问服务对应的每台容器\",{\"1\":{\"219\":1}}],[\"则需要将docker\",{\"1\":{\"219\":1}}],[\"则以envirment\",{\"1\":{\"219\":1}}],[\"则默认是可读写\",{\"1\":{\"219\":1}}],[\"则\",{\"1\":{\"219\":2}}],[\"则省略了这个过程\",{\"1\":{\"218\":1}}],[\"则修改\",{\"1\":{\"217\":1}}],[\"则利用undolog日志进行回滚\",{\"1\":{\"216\":1}}],[\"则获取不到锁\",{\"1\":{\"216\":1}}],[\"则忽略所接收到的选票\",{\"1\":{\"216\":1}}],[\"则改票\",{\"1\":{\"216\":1}}],[\"则根据重试策略进行重试\",{\"1\":{\"216\":2}}],[\"则消息销毁\",{\"1\":{\"216\":2}}],[\"则由后台定时任务从本地消息表中取出未成功的消息\",{\"1\":{\"216\":1}}],[\"则证明修改有效\",{\"1\":{\"216\":1}}],[\"则继续循环获取\",{\"1\":{\"216\":1}}],[\"则会主动调此接口来查询订单是否创建成功\",{\"1\":{\"216\":2}}],[\"则会升级为重量级锁\",{\"1\":{\"216\":1}}],[\"则会将aqs中排队的线程依次唤醒\",{\"1\":{\"216\":1}}],[\"则会销毁线程\",{\"1\":{\"64\":1}}],[\"则当前线程也进行排队\",{\"1\":{\"216\":1}}],[\"则生成一个新的红黑树\",{\"1\":{\"216\":1}}],[\"则生成一个新的integer对象\",{\"1\":{\"216\":1}}],[\"则先遍历红黑树\",{\"1\":{\"216\":1}}],[\"则直接将链表中的每个元素重新计算下标\",{\"1\":{\"216\":1}}],[\"则把\",{\"1\":{\"216\":1}}],[\"则把请求放入\",{\"1\":{\"64\":1}}],[\"则此zkserver就可以成为leader了\",{\"1\":{\"216\":1}}],[\"则返回\",{\"1\":{\"96\":1}}],[\"则通过\",{\"1\":{\"96\":1}}],[\"则将key\",{\"1\":{\"216\":1}}],[\"则将冲突的值加到链表中即可\",{\"1\":{\"77\":1}}],[\"则将任务放入任务队列\",{\"1\":{\"64\":1}}],[\"则该class的两个对象无论如何都不会相等\",{\"1\":{\"75\":1}}],[\"则hashcode方法也必须被覆盖\",{\"1\":{\"75\":1}}],[\"则hashcode一定也是相同的\",{\"1\":{\"75\":1}}],[\"则影响不大\",{\"1\":{\"64\":1}}],[\"则很容易创建失败\",{\"1\":{\"64\":1}}],[\"则是根据系统内存状态确定了虚拟地址空间的上限\",{\"1\":{\"64\":1}}],[\"则虚拟地址空间分配失败\",{\"1\":{\"64\":1}}],[\"则可以用docker\",{\"1\":{\"219\":1}}],[\"则可以修改这个节点下面的所有内容\",{\"1\":{\"64\":1}}],[\"则可能需要调优套接口缓冲区大小\",{\"1\":{\"64\":1}}],[\"则cglib\",{\"1\":{\"64\":1}}],[\"则还是一颗树\",{\"1\":{\"64\":1}}],[\"则jvm会把该线程放入\",{\"1\":{\"64\":1}}],[\"则创建新线程执行任务\",{\"1\":{\"64\":1}}],[\"则创建新的线程\",{\"1\":{\"64\":1}}],[\"则创建线程\",{\"1\":{\"64\":1}}],[\"则所有读写访问都算\",{\"1\":{\"64\":1}}],[\"则予以更新\",{\"1\":{\"64\":1}}],[\"则嵌套事务执行\",{\"1\":{\"64\":1}}],[\"则对于经常需要从\",{\"1\":{\"64\":1}}],[\"则进一步向上委托\",{\"1\":{\"64\":1}}],[\"则使用\",{\"1\":{\"64\":1}}],[\"则线程不安全\",{\"1\":{\"64\":1}}],[\"则线程安全\",{\"1\":{\"64\":1}}],[\"则要考虑缩短连接时间\",{\"1\":{\"58\":1}}],[\"则发送方不能发送数据\",{\"1\":{\"25\":1}}],[\"则发出连接释放通知\",{\"1\":{\"19\":1}}],[\"军规实际上就是围绕请求过程进行的一些优化方式\",{\"1\":{\"58\":1}}],[\"试想一下当你在淘宝购买东西的时候\",{\"1\":{\"58\":1}}],[\"前提是这些服务都在同一个网络下才能正常访问\",{\"1\":{\"219\":2}}],[\"前面步骤命中缓存的概率会增加\",{\"1\":{\"231\":1}}],[\"前面\",{\"1\":{\"231\":1}}],[\"前面一个例子的string类已经默认实现了comparable接口\",{\"1\":{\"87\":1}}],[\"前面的正向流程都成功后\",{\"1\":{\"64\":1}}],[\"前后加起来大概40亿的映射空间\",{\"1\":{\"79\":1}}],[\"前缀指令实际上相当于一个内存屏障\",{\"1\":{\"64\":1}}],[\"前缀的指令\",{\"1\":{\"64\":1}}],[\"前前后后断断续续写了两个星期\",{\"1\":{\"59\":1}}],[\"前端的本质是什么\",{\"1\":{\"58\":1}}],[\"前一个任务结束\",{\"1\":{\"57\":1}}],[\"了解完\",{\"1\":{\"231\":1}}],[\"了解可重入锁的含义\",{\"1\":{\"64\":1}}],[\"了解几种消息中间件产品\",{\"1\":{\"64\":2}}],[\"了解该过程的目的无非就是为了\",{\"1\":{\"58\":1}}],[\"了解了\",{\"1\":{\"43\":1}}],[\"结语\",{\"1\":{\"231\":1}}],[\"结尾并且换行\",{\"1\":{\"231\":1}}],[\"结尾的文件\",{\"1\":{\"231\":1}}],[\"结果也保存在upper层\",{\"1\":{\"218\":1}}],[\"结果\",{\"1\":{\"64\":6}}],[\"结束\",{\"1\":{\"64\":2}}],[\"结合在一起使用也就是\",{\"1\":{\"77\":1}}],[\"结合springaop可以完成权限控制\",{\"1\":{\"64\":1}}],[\"结合互联网的情况\",{\"1\":{\"7\":1}}],[\"结构进行存储\",{\"1\":{\"172\":1}}],[\"结构来实现\",{\"1\":{\"170\":1}}],[\"结构\",{\"1\":{\"57\":1}}],[\"文档会挂起渲染过程\",{\"1\":{\"57\":1}}],[\"文档进行加载\",{\"1\":{\"57\":1}}],[\"文件时\",{\"1\":{\"231\":1}}],[\"文件内容如下\",{\"1\":{\"231\":1}}],[\"文件内容参考下面文档\",{\"1\":{\"219\":1}}],[\"文件外所有以\",{\"1\":{\"231\":1}}],[\"文件有变动\",{\"1\":{\"219\":1}}],[\"文件会在内核空间分页做缓存\",{\"1\":{\"64\":1}}],[\"文件读入有误\",{\"1\":{\"64\":1}}],[\"文件名或目录名\",{\"1\":{\"64\":1}}],[\"文件已经下载并加载完毕\",{\"1\":{\"57\":1}}],[\"文件的构建阶段执行\",{\"1\":{\"218\":1}}],[\"文件的执行\",{\"1\":{\"57\":1}}],[\"文件的加载\",{\"1\":{\"57\":1}}],[\"文件的加载不影响\",{\"1\":{\"57\":1}}],[\"文件加载完毕还要等待解析执行完毕\",{\"1\":{\"57\":1}}],[\"文件\",{\"1\":{\"57\":1,\"218\":1,\"219\":1,\"231\":1}}],[\"文件构建渲染树\",{\"1\":{\"57\":1}}],[\"文件构建\",{\"1\":{\"57\":1}}],[\"文件后\",{\"1\":{\"57\":1}}],[\"文件都必须遵守这个标准\",{\"1\":{\"8\":1}}],[\"形成一个执行栈\",{\"1\":{\"57\":1}}],[\"同理\",{\"1\":{\"217\":1,\"231\":1}}],[\"同样extclassloader的loadclass方法中会先使用bootstrapclassloader来加载类\",{\"1\":{\"216\":1}}],[\"同样机房2也不能选出一个leader\",{\"1\":{\"216\":1}}],[\"同样可以利用b\",{\"1\":{\"216\":1}}],[\"同newfixedthreadpool线程池一样\",{\"1\":{\"64\":1}}],[\"同一个compose文件管理的服务可以直接用服务名访问\",{\"1\":{\"219\":1}}],[\"同一个docker\",{\"1\":{\"219\":1}}],[\"同一个服务多个注册的情况下可以直连某一个服务吗\",{\"1\":{\"64\":1}}],[\"同一把锁\",{\"1\":{\"81\":1}}],[\"同一时刻只能有一个线程执行读写操作\",{\"1\":{\"64\":1}}],[\"同一事务中所有的操作\",{\"1\":{\"64\":1}}],[\"同步宿主机与容器时间\",{\"1\":{\"219\":10}}],[\"同步非阻塞io\",{\"1\":{\"216\":1}}],[\"同步转异步\",{\"1\":{\"216\":1}}],[\"同步和异步\",{\"1\":{\"64\":1}}],[\"同步屏障cyclicbarrier\",{\"1\":{\"64\":1}}],[\"同步的接口或方法\",{\"1\":{\"64\":1}}],[\"同步的数据结构\",{\"1\":{\"64\":1}}],[\"同步阻塞io\",{\"1\":{\"216\":1}}],[\"同步阻塞\",{\"1\":{\"64\":1}}],[\"同步异步阻塞非阻塞\",{\"1\":{\"64\":2}}],[\"同步任务就是放在主线程上执行的任务\",{\"1\":{\"57\":1}}],[\"同步任务\",{\"1\":{\"57\":1}}],[\"同时如果某个方法是private的\",{\"1\":{\"216\":1}}],[\"同时可能读到的数据不是实时最新的数据\",{\"1\":{\"216\":1}}],[\"同时通过对链表进行相应的操作\",{\"1\":{\"90\":1}}],[\"同时也会与其他加入的对象的hashcode值作比较\",{\"1\":{\"75\":1}}],[\"同时也使得先获得这个锁的线程的所有操作\",{\"1\":{\"64\":1}}],[\"同时又保有在未来\",{\"1\":{\"64\":1}}],[\"同时多少个线程一起进行垃圾回收\",{\"1\":{\"64\":1}}],[\"同时执行扩容操作\",{\"1\":{\"64\":1}}],[\"同时\",{\"1\":{\"64\":2}}],[\"同时把g1设为默认的垃圾回收器实现\",{\"1\":{\"64\":1}}],[\"同时存在\",{\"1\":{\"43\":1}}],[\"同时http1\",{\"1\":{\"33\":1}}],[\"后台运行\",{\"1\":{\"217\":1}}],[\"后台应用\",{\"1\":{\"217\":1}}],[\"后台会有定时任务扫描和分析此类日志\",{\"1\":{\"64\":1}}],[\"后续还有其他机制将buffer\",{\"1\":{\"216\":1}}],[\"后续操作的时候\",{\"1\":{\"169\":1}}],[\"后续所有资源的下载是没有必要的\",{\"1\":{\"57\":1}}],[\"后解决了这个问题\",{\"1\":{\"80\":1}}],[\"后面所有内容将会被忽略\",{\"1\":{\"231\":1}}],[\"后面加\",{\"1\":{\"219\":1}}],[\"后面会介绍到为什么是2的幂次方\",{\"1\":{\"73\":1}}],[\"后面说明\",{\"1\":{\"64\":2}}],[\"后者牺牲了服务调用的性能\",{\"1\":{\"64\":1}}],[\"后一个任务才能开始\",{\"1\":{\"57\":1}}],[\"后端从在固定的端口接收到\",{\"1\":{\"53\":1}}],[\"涉及到两个概念\",{\"1\":{\"57\":1}}],[\"涉及到所有的主机\",{\"1\":{\"26\":1}}],[\"树\",{\"1\":{\"57\":1}}],[\"首先在容器构建目录创建文件\",{\"1\":{\"231\":1}}],[\"首先在本地域名服务器中查询\",{\"1\":{\"42\":1}}],[\"首先启动tomcat\",{\"1\":{\"216\":1}}],[\"首先不管是公平锁和非公平锁\",{\"1\":{\"216\":1}}],[\"首先会检查字符串常量池中是否存在\",{\"1\":{\"216\":1}}],[\"首先你可以对这些数据进行排序\",{\"1\":{\"216\":1}}],[\"首先将数据分为一段一段的存储\",{\"1\":{\"83\":1}}],[\"首先\",{\"1\":{\"64\":1,\"216\":4,\"218\":1}}],[\"首先浏览器解析\",{\"1\":{\"57\":1}}],[\"渲染的过程\",{\"1\":{\"57\":1}}],[\"绘制而成的\",{\"1\":{\"54\":1}}],[\"该工程包含了1个服务\",{\"1\":{\"219\":1}}],[\"该目录可被容器本身使用\",{\"1\":{\"218\":1}}],[\"该指令使容器中的一个目录具有持久化存储的功能\",{\"1\":{\"218\":1}}],[\"该指令用于设置启动镜像时的用户或者\",{\"1\":{\"218\":1}}],[\"该dockerfile非常简单\",{\"1\":{\"218\":1}}],[\"该命令只能删除已停止的容器\",{\"1\":{\"217\":1}}],[\"该命令是最常用的命令\",{\"1\":{\"217\":1}}],[\"该名称默认由\",{\"1\":{\"217\":1}}],[\"该列表包含了7列\",{\"1\":{\"217\":1}}],[\"该列标记为\",{\"1\":{\"217\":1}}],[\"该选项有以下可选参数\",{\"1\":{\"217\":1}}],[\"该协议描述了zookeeper是如何实现一致性的\",{\"1\":{\"216\":1}}],[\"该方法是空方法\",{\"1\":{\"216\":1}}],[\"该方法不会阻塞线程\",{\"1\":{\"216\":1}}],[\"该连接对象可以在不同的方法之间进行传递\",{\"1\":{\"216\":1}}],[\"该类中存在一个integer\",{\"1\":{\"216\":1}}],[\"该线程下次如果又来获取该锁就可以直接获取到了\",{\"1\":{\"216\":1}}],[\"该线程可以在任意时刻\",{\"1\":{\"216\":1}}],[\"该线程结束生命周期\",{\"1\":{\"64\":1}}],[\"该线程会释放占用的所有资源\",{\"1\":{\"64\":1}}],[\"该状态的线程位于\",{\"1\":{\"64\":1}}],[\"该模型其核心思想就是拆分分布式系统中的长事务为多个短事务\",{\"1\":{\"64\":1}}],[\"该代理类增强了业务类\",{\"1\":{\"64\":1}}],[\"该日志记录系统可以设置输出的日志消息的标签\",{\"1\":{\"64\":1}}],[\"该图是本公司对状态码的一个总结\",{\"1\":{\"54\":1}}],[\"该机器离用户地理位置的距离等等\",{\"1\":{\"45\":1}}],[\"要尽量减小\",{\"1\":{\"244\":1}}],[\"要做多物理机扩容一般都会用docker\",{\"1\":{\"219\":1}}],[\"要做多机扩容还需自己在多个机器上做很多定制化配置\",{\"1\":{\"219\":1}}],[\"要把镜像推送到镜像仓库\",{\"1\":{\"218\":1}}],[\"要拷贝到容器里面对应的路径\",{\"1\":{\"217\":1}}],[\"要拷贝的宿主机文件路径\",{\"1\":{\"217\":1}}],[\"要拷贝的文件在容器里面的路径\",{\"1\":{\"217\":1}}],[\"要解决什么问题\",{\"1\":{\"217\":1}}],[\"要确认broker确实收到并持久化了这条消息\",{\"1\":{\"216\":1}}],[\"要调用的方法名\",{\"1\":{\"216\":1}}],[\"要发送哪些数据\",{\"1\":{\"216\":1}}],[\"要没只有1个leader\",{\"1\":{\"216\":1}}],[\"要比\",{\"1\":{\"73\":1}}],[\"要求\",{\"1\":{\"217\":1}}],[\"要求把1\",{\"1\":{\"64\":1}}],[\"要求有大量\",{\"1\":{\"64\":1}}],[\"要说明这个问题\",{\"1\":{\"64\":1}}],[\"要多了解\",{\"1\":{\"64\":1}}],[\"要么保证ap\",{\"1\":{\"216\":1}}],[\"要么没有leader\",{\"1\":{\"216\":1}}],[\"要么一起失败\",{\"1\":{\"64\":1}}],[\"要么一起成功\",{\"1\":{\"64\":1}}],[\"要么是黑的\",{\"1\":{\"64\":1}}],[\"要完成请求必须进行更进一步的操作\",{\"1\":{\"54\":1}}],[\"要提供可靠的\",{\"1\":{\"20\":1}}],[\"理解事务\",{\"1\":{\"64\":1}}],[\"理解分布式id生成算法snowflake\",{\"1\":{\"64\":1}}],[\"理解\",{\"1\":{\"54\":1}}],[\"成功\",{\"1\":{\"54\":1,\"64\":3,\"217\":1}}],[\"供读者参考\",{\"1\":{\"64\":1}}],[\"供上层使用\",{\"1\":{\"53\":1}}],[\"供下次查询使用\",{\"1\":{\"42\":1}}],[\"架构方面的缓存\",{\"1\":{\"64\":1}}],[\"架构\",{\"1\":{\"52\":1,\"233\":1}}],[\"现在程序要运行\",{\"1\":{\"216\":1}}],[\"现在有三个类\",{\"1\":{\"216\":1}}],[\"现在变成了两个集群同时对外提供服务\",{\"1\":{\"216\":1}}],[\"现在如果想提高这个数列的查询速度\",{\"1\":{\"216\":1}}],[\"现在的\",{\"1\":{\"52\":1}}],[\"现在人们经常提到的tcp\",{\"1\":{\"12\":1}}],[\"节约io\",{\"1\":{\"64\":1}}],[\"节点实时状态等等\",{\"1\":{\"64\":1}}],[\"节点的fail是通过集群中超过半数的master节点检测失效时才生效\",{\"1\":{\"64\":1}}],[\"节点的服务器负责响应用户的请求\",{\"1\":{\"45\":1}}],[\"节点中的各个元素都是以盒模型的形式存在\",{\"1\":{\"57\":1}}],[\"节省开支\",{\"1\":{\"217\":1}}],[\"节省了空间\",{\"1\":{\"64\":1}}],[\"节省\",{\"1\":{\"51\":1}}],[\"设置访问elasticsearch的地址\",{\"1\":{\"219\":1}}],[\"设置使用jvm内存大小\",{\"1\":{\"219\":1}}],[\"设置集群名称为elasticsearch\",{\"1\":{\"219\":1}}],[\"设置root帐号密码\",{\"1\":{\"219\":1}}],[\"设置网络模式\",{\"1\":{\"219\":1}}],[\"设置环境变量指令放前面\",{\"1\":{\"231\":1}}],[\"设置环境变量\",{\"1\":{\"219\":1}}],[\"设置yum源\",{\"1\":{\"217\":1}}],[\"设置会被拒绝服务\",{\"1\":{\"216\":1}}],[\"设置有效时间和自动刷新缓存\",{\"1\":{\"64\":1}}],[\"设置年轻代为并行收集\",{\"1\":{\"64\":1}}],[\"设置年老代为并发收集\",{\"1\":{\"64\":1}}],[\"设置此选项后\",{\"1\":{\"64\":1}}],[\"设置每次年轻代垃圾回收的最长时间\",{\"1\":{\"64\":1}}],[\"设置是否为自动提交事务\",{\"1\":{\"64\":1}}],[\"设置事务隔离级别\",{\"1\":{\"64\":1}}],[\"设置的方式也不一样\",{\"1\":{\"64\":1}}],[\"设置为\",{\"1\":{\"51\":1}}],[\"设计与思想\",{\"1\":{\"64\":1}}],[\"设计模式用过哪些\",{\"0\":{\"142\":1}}],[\"设计模式\",{\"1\":{\"64\":1}}],[\"设计\",{\"1\":{\"8\":1,\"64\":1}}],[\"开头并且以任意字符结尾的文件\",{\"1\":{\"231\":1}}],[\"开头的文件或者文件夹\",{\"1\":{\"231\":1}}],[\"开头的表示注释\",{\"1\":{\"231\":1}}],[\"开启springboot\",{\"1\":{\"219\":1}}],[\"开启事务\",{\"1\":{\"64\":1}}],[\"开放容器端口到宿主机端口\",{\"1\":{\"217\":1}}],[\"开放封闭原则\",{\"1\":{\"64\":1}}],[\"开始接收客户端命令\",{\"1\":{\"216\":1}}],[\"开始向从节点发送缓冲区replication\",{\"1\":{\"216\":1}}],[\"开始执行bgsave命令生成rdb文件\",{\"1\":{\"216\":1}}],[\"开始去找\",{\"1\":{\"216\":1}}],[\"开始入队\",{\"1\":{\"216\":1}}],[\"开姓入队\",{\"1\":{\"216\":1}}],[\"开源框架\",{\"1\":{\"64\":1}}],[\"开销较低的\",{\"1\":{\"64\":1}}],[\"开销会比较大\",{\"1\":{\"33\":1}}],[\"开场白\",{\"1\":{\"64\":1}}],[\"开发者可以直接使用netty来开发高效率的各种网络服务器\",{\"1\":{\"216\":1}}],[\"开发者工具截取的对百度的\",{\"1\":{\"51\":1}}],[\"开发库\",{\"1\":{\"64\":1}}],[\"开发的科普类文章去阅读\",{\"1\":{\"59\":1}}],[\"常规计数\",{\"1\":{\"168\":1}}],[\"常规key\",{\"1\":{\"168\":1}}],[\"常用解决方案有\",{\"1\":{\"216\":1}}],[\"常用命令\",{\"1\":{\"168\":1,\"169\":1,\"170\":1,\"171\":1,\"172\":1}}],[\"常用的一些docker\",{\"1\":{\"219\":1}}],[\"常用的分布式事务解决方案介绍有多少种\",{\"1\":{\"64\":1}}],[\"常用的线程池模式以及不同线程池的使用场景\",{\"1\":{\"64\":1}}],[\"常用的实现类有\",{\"1\":{\"64\":1}}],[\"常用的方法有\",{\"1\":{\"50\":1}}],[\"常见hash算法的原理\",{\"1\":{\"64\":1}}],[\"常见的有aufs\",{\"1\":{\"218\":1}}],[\"常见的出现这个异常的是无法返回的递归\",{\"1\":{\"64\":1}}],[\"常见的解决方案有哪些\",{\"1\":{\"64\":2}}],[\"常见的jvm调优方法有哪些\",{\"1\":{\"64\":2}}],[\"常见的网络攻击手段\",{\"0\":{\"61\":1}}],[\"常见的响应报头字段有\",{\"1\":{\"55\":1}}],[\"常见的请求报头有\",{\"1\":{\"51\":1}}],[\"常量池解析\",{\"1\":{\"64\":1}}],[\"常量池在元空间\",{\"1\":{\"64\":1}}],[\"常量池在堆\",{\"1\":{\"64\":1}}],[\"常量池在方法区\",{\"1\":{\"64\":1}}],[\"v\",{\"1\":{\"218\":2}}],[\"vi\",{\"1\":{\"223\":1}}],[\"vim\",{\"1\":{\"217\":2,\"225\":1,\"231\":2}}],[\"viewreslover\",{\"1\":{\"216\":1}}],[\"view\",{\"1\":{\"216\":3,\"219\":1}}],[\"visualvm\",{\"1\":{\"64\":1}}],[\"var\",{\"1\":{\"217\":2,\"218\":2,\"219\":7,\"225\":1}}],[\"varchar\",{\"1\":{\"216\":1}}],[\"value对\",{\"1\":{\"216\":1}}],[\"value添加到concurrenthashmap中\",{\"1\":{\"216\":1}}],[\"valueof方法会判断所定义的数字是否在\",{\"1\":{\"216\":1}}],[\"value缓存应用\",{\"1\":{\"168\":1}}],[\"value其实不仅可以是string\",{\"1\":{\"168\":1}}],[\"value类型\",{\"1\":{\"168\":1}}],[\"value的支持\",{\"1\":{\"73\":1}}],[\"value\",{\"1\":{\"64\":3,\"94\":6,\"169\":1,\"216\":1,\"242\":1}}],[\"value=\",{\"1\":{\"64\":2,\"169\":1}}],[\"validation\",{\"1\":{\"64\":3}}],[\"v>\",{\"1\":{\"83\":1}}],[\"vector类的所有方法都是同步的\",{\"1\":{\"71\":1}}],[\"vector线程同步\",{\"1\":{\"64\":1}}],[\"vector线程安全\",{\"1\":{\"64\":1}}],[\"vector适合查找\",{\"1\":{\"64\":2}}],[\"vector\",{\"0\":{\"71\":1},\"1\":{\"64\":6,\"89\":1}}],[\"versions\",{\"1\":{\"231\":2}}],[\"version\",{\"1\":{\"50\":1,\"64\":2,\"217\":1,\"219\":5,\"228\":1}}],[\"volumn\",{\"1\":{\"241\":1}}],[\"volumns\",{\"1\":{\"241\":1}}],[\"volumes\",{\"1\":{\"219\":24}}],[\"volume\",{\"1\":{\"218\":2,\"219\":2}}],[\"volatile的大量\",{\"1\":{\"216\":1}}],[\"volatile的理解\",{\"1\":{\"64\":1}}],[\"volatile的适用场景\",{\"1\":{\"64\":1}}],[\"volatile关键字用来修饰对象的属性\",{\"1\":{\"216\":1}}],[\"volatile关键字解惑\",{\"1\":{\"64\":1}}],[\"volatile关键字解析\",{\"1\":{\"64\":1}}],[\"volatile关键字的用法\",{\"1\":{\"64\":1}}],[\"volatile标记的变量不会被编译器优化\",{\"1\":{\"64\":1}}],[\"volatile仅能实现变量的修改可见性\",{\"1\":{\"64\":1}}],[\"volatile仅能使用在变量级别\",{\"1\":{\"64\":1}}],[\"volatile不会造成线程的阻塞\",{\"1\":{\"64\":1}}],[\"volatile主要应用在多个线程对实例变量更改的场合\",{\"1\":{\"64\":1}}],[\"volatile变量进行写操作时\",{\"1\":{\"64\":1}}],[\"volatile原理\",{\"1\":{\"64\":1}}],[\"volatile区别\",{\"1\":{\"64\":2}}],[\"volatile\",{\"0\":{\"113\":1},\"1\":{\"64\":6}}],[\"void\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":3,\"64\":1,\"86\":2,\"87\":3,\"96\":1}}],[\"握手过程\",{\"1\":{\"48\":1}}],[\"握手\",{\"1\":{\"48\":1}}],[\"过去需要用数天乃至数周的\",{\"1\":{\"217\":1}}],[\"过半机制中为什么是大于\",{\"1\":{\"216\":1}}],[\"过半机制的源码实现其实非常简单\",{\"1\":{\"216\":1}}],[\"过半机制\",{\"1\":{\"216\":1}}],[\"过滤器和拦截器区别\",{\"0\":{\"141\":1}}],[\"过程可追溯\",{\"1\":{\"231\":1}}],[\"过程是\",{\"1\":{\"216\":2}}],[\"过程是非常消耗性能的\",{\"1\":{\"57\":1}}],[\"过程下载该资源\",{\"1\":{\"57\":1}}],[\"过程\",{\"0\":{\"48\":1}}],[\"过了时间限制\",{\"1\":{\"31\":1}}],[\"过了一会\",{\"1\":{\"23\":1}}],[\"作用是什么\",{\"1\":{\"216\":1}}],[\"作用域\",{\"1\":{\"64\":1}}],[\"作为分布式id的生成器\",{\"1\":{\"216\":1}}],[\"作为成为一个成熟的rpc框架\",{\"1\":{\"216\":1}}],[\"作为一个rpc框架\",{\"1\":{\"216\":1}}],[\"作为消息的用户\",{\"1\":{\"64\":1}}],[\"作为生产者的类无法做到这一点\",{\"1\":{\"64\":1}}],[\"作为面向对象编程的一种补充\",{\"1\":{\"64\":1}}],[\"作为其传输层协议的\",{\"1\":{\"46\":1}}],[\"作为我个人博客的图床使用\",{\"1\":{\"45\":1}}],[\"作者\",{\"1\":{\"6\":2,\"66\":2,\"75\":2,\"216\":7}}],[\"储存图片\",{\"1\":{\"45\":1}}],[\"免费\",{\"1\":{\"45\":1}}],[\"给客户端发送一个syn\",{\"1\":{\"216\":1}}],[\"给的这么大呢\",{\"1\":{\"216\":1}}],[\"给定你一个数列\",{\"1\":{\"216\":1}}],[\"给用户\",{\"1\":{\"45\":1}}],[\"给发送的每一个包进行编号\",{\"1\":{\"21\":1}}],[\"系统中安装make和net\",{\"1\":{\"231\":1}}],[\"系统则向\",{\"1\":{\"231\":1}}],[\"系统可以向\",{\"1\":{\"231\":1}}],[\"系统a给消息队列发送完消息之后\",{\"1\":{\"216\":1}}],[\"系统的内核版本高于\",{\"1\":{\"217\":1}}],[\"系统的所有服务都注册在总线上\",{\"1\":{\"216\":1}}],[\"系统的用户量有多少\",{\"1\":{\"64\":1}}],[\"系统也是可用的\",{\"1\":{\"216\":1}}],[\"系统在为应用进程分配虚拟地址空间时\",{\"1\":{\"64\":2}}],[\"系统线程数量\",{\"1\":{\"64\":1}}],[\"系统类加载器\",{\"1\":{\"64\":1}}],[\"系统\",{\"1\":{\"44\":1,\"231\":1}}],[\"系统缓存主要存在\",{\"1\":{\"44\":1}}],[\"系统缓存\",{\"1\":{\"44\":1}}],[\"系统不知道是哪个用户操作的\",{\"1\":{\"31\":1,\"32\":1}}],[\"请教一个linux的问题\",{\"1\":{\"246\":1}}],[\"请尽量考虑使用其他方式替代\",{\"1\":{\"231\":1}}],[\"请根据使用的操作系统修改相应的时区信息\",{\"1\":{\"231\":1}}],[\"请说明如果首选的副本不在isr中会发生什么\",{\"1\":{\"64\":1}}],[\"请说明kafka相对传统技术有什么优势\",{\"1\":{\"64\":1}}],[\"请说明什么是传统的消息传递方法\",{\"1\":{\"64\":1}}],[\"请说明什么是apache\",{\"1\":{\"64\":1}}],[\"请列举你所知道的方案\",{\"1\":{\"64\":1}}],[\"请配置\",{\"1\":{\"64\":2}}],[\"请大家参考\",{\"1\":{\"54\":1}}],[\"请自行查找\",{\"1\":{\"43\":1}}],[\"请求时间变长\",{\"1\":{\"216\":1}}],[\"请求体放什么数据呢\",{\"1\":{\"216\":1}}],[\"请求头放什么数据\",{\"1\":{\"216\":1}}],[\"请求方式的区别\",{\"1\":{\"64\":1}}],[\"请求再多\",{\"1\":{\"64\":2}}],[\"请求最终将到达顶层的启动类加载器\",{\"1\":{\"64\":1}}],[\"请求过程是异步的\",{\"1\":{\"57\":1}}],[\"请求有语法错误或请求无法实现\",{\"1\":{\"54\":1}}],[\"请求的数据会附加在url之后\",{\"1\":{\"64\":1}}],[\"请求的数据格式一般为\",{\"1\":{\"52\":1}}],[\"请求的过程就是构建\",{\"1\":{\"49\":1}}],[\"请求正文\",{\"0\":{\"52\":1}}],[\"请求使用相同的\",{\"1\":{\"51\":1}}],[\"请求结束之后并不需要关闭\",{\"1\":{\"51\":1}}],[\"请求以及响应报文\",{\"1\":{\"51\":1}}],[\"请求报头中使用了\",{\"1\":{\"51\":1}}],[\"请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息\",{\"1\":{\"51\":1}}],[\"请求报头\",{\"0\":{\"51\":1}}],[\"请求报头和请求正文\",{\"1\":{\"49\":1}}],[\"请求报文是由三部分组成\",{\"1\":{\"49\":1}}],[\"请求报文并通过\",{\"1\":{\"49\":1}}],[\"请求行\",{\"0\":{\"50\":1},\"1\":{\"49\":1}}],[\"请求\",{\"0\":{\"49\":1},\"1\":{\"39\":1,\"43\":1}}],[\"经过pk后\",{\"1\":{\"216\":1}}],[\"经过适配调用具体的处理器\",{\"1\":{\"216\":1}}],[\"经过扰动函数处理过后得到\",{\"1\":{\"77\":1}}],[\"经典的上台阶问题\",{\"0\":{\"210\":1}}],[\"经历了怎样的过程\",{\"1\":{\"64\":1}}],[\"经历了\",{\"1\":{\"43\":1}}],[\"经验表明\",{\"1\":{\"26\":1}}],[\"优缺点是什么\",{\"1\":{\"216\":1}}],[\"优先级从高到低\",{\"1\":{\"216\":1}}],[\"优先级队列\",{\"1\":{\"64\":1}}],[\"优先选择iterator遍历\",{\"1\":{\"69\":1}}],[\"优先选择普通\",{\"1\":{\"69\":1}}],[\"优雅的学院派雅虎给出了常用的一些手段\",{\"1\":{\"58\":1}}],[\"优化这个方法的执行\",{\"1\":{\"216\":1}}],[\"优化这一块我平常接触的并不是很多\",{\"1\":{\"46\":1}}],[\"优化索引\",{\"0\":{\"154\":1}}],[\"优化数据库结构\",{\"1\":{\"64\":1}}],[\"优化数据库查询语句\",{\"1\":{\"64\":1}}],[\"优化部分\",{\"1\":{\"58\":1}}],[\"优化之前\",{\"1\":{\"58\":1}}],[\"优化\",{\"0\":{\"43\":1,\"58\":1},\"1\":{\"58\":1}}],[\"优点是并不需要记录每一条sql语句和每一行的数据变化\",{\"1\":{\"64\":1}}],[\"优点是什么\",{\"1\":{\"64\":2}}],[\"优点\",{\"1\":{\"23\":1,\"24\":1,\"216\":1}}],[\"根\",{\"1\":{\"216\":3}}],[\"根搜索算法\",{\"1\":{\"64\":1}}],[\"根据文件内容计算出的一个数值\",{\"1\":{\"231\":1}}],[\"根据构建的镜像创建一个名称叫\",{\"1\":{\"219\":1}}],[\"根据自己的消息处理能力来进行控制\",{\"1\":{\"216\":1}}],[\"根据这个例子\",{\"1\":{\"216\":1}}],[\"根据这些\",{\"1\":{\"216\":1}}],[\"根据创建订单成功与否\",{\"1\":{\"216\":2}}],[\"根据\",{\"1\":{\"216\":1,\"231\":1}}],[\"根据请求所指定的端口\",{\"1\":{\"216\":1}}],[\"根据生产者的机制\",{\"1\":{\"64\":1}}],[\"根据最近过期时间来删除\",{\"1\":{\"64\":1}}],[\"根据过期设置来随机删除key\",{\"1\":{\"64\":1}}],[\"根据lru算法删除任何key\",{\"1\":{\"64\":1}}],[\"根据lru算法删除带有过期时间的key\",{\"1\":{\"64\":1}}],[\"根据应用区间识别业务流\",{\"1\":{\"64\":1}}],[\"根据结果进行处理\",{\"1\":{\"64\":1}}],[\"根据私钥也无法推知公钥\",{\"1\":{\"35\":1}}],[\"根结点是黑的\",{\"1\":{\"64\":1}}],[\"根域名服务器缓存\",{\"1\":{\"44\":1}}],[\"根域名服务器的解析过程呢\",{\"1\":{\"42\":1}}],[\"从当前构建层开始\",{\"1\":{\"231\":1}}],[\"从文件中获取环境变量\",{\"1\":{\"219\":1}}],[\"从另一个服务或者容器挂载卷\",{\"1\":{\"219\":1}}],[\"从src目录复制文件到容器的dest\",{\"1\":{\"218\":1}}],[\"从宿主机拷文件到容器里面\",{\"1\":{\"217\":1}}],[\"从容器里面拷文件到宿主机\",{\"1\":{\"217\":1}}],[\"从总线上查找服务信息\",{\"1\":{\"216\":1}}],[\"从多个服务提供者随机选择一个来处理本次请求\",{\"1\":{\"216\":1}}],[\"从节点接收并执行收到的写命令\",{\"1\":{\"216\":1}}],[\"从节点只能处理读请求\",{\"1\":{\"216\":1}}],[\"从节点则是从主节点拉取数据备份\",{\"1\":{\"64\":1}}],[\"从zookeeper集群中选出一个节点作为leader\",{\"1\":{\"216\":1}}],[\"从列中花\",{\"1\":{\"216\":1}}],[\"从常量池中查找\",{\"1\":{\"96\":1}}],[\"从库读主库的binlog\",{\"1\":{\"64\":1}}],[\"从服务器上获取数据\",{\"1\":{\"64\":1}}],[\"从此offset处开始继续消费\",{\"1\":{\"64\":1}}],[\"从对象的生命周期梳理jvm内存结构\",{\"1\":{\"64\":1}}],[\"从某种意义上说\",{\"1\":{\"64\":1}}],[\"从软件设计的角度看\",{\"1\":{\"64\":1}}],[\"从程序运行时数据区\",{\"1\":{\"64\":1}}],[\"从中间开始\",{\"1\":{\"64\":1}}],[\"从结尾开始\",{\"1\":{\"64\":1}}],[\"从开头开始\",{\"1\":{\"64\":1}}],[\"从\",{\"1\":{\"64\":1}}],[\"从该结点到其子孙结点的所有路径上包含相同数目的黑结点\",{\"1\":{\"64\":1}}],[\"从而提升构建效率\",{\"1\":{\"231\":1}}],[\"从而提高了消息发送的吞吐量\",{\"1\":{\"216\":1}}],[\"从而知道b+数的高度是多少\",{\"1\":{\"216\":1}}],[\"从而可以使得b+树的高度不会太高\",{\"1\":{\"216\":1}}],[\"从而可以实现类似\",{\"1\":{\"216\":1}}],[\"从而把数据保持一致\",{\"1\":{\"216\":1}}],[\"从而不再调用服务b\",{\"1\":{\"216\":1}}],[\"从而防止系统不被大量请求压垮\",{\"1\":{\"216\":1}}],[\"从而服务a不可用\",{\"1\":{\"216\":1}}],[\"从而服务b请求堆积\",{\"1\":{\"216\":1}}],[\"从而applicationcontext还有获取系统环境变量\",{\"1\":{\"216\":1}}],[\"从而达到多个进程中的线程使用同一把锁\",{\"1\":{\"216\":1}}],[\"从而达到tomcat优化的目的\",{\"1\":{\"216\":1}}],[\"从而达到应用之间的类隔离\",{\"1\":{\"216\":1}}],[\"从而节省内存\",{\"1\":{\"216\":1}}],[\"从而出现内存泄漏\",{\"1\":{\"216\":1}}],[\"从而被leader副本踢出isr集合\",{\"1\":{\"64\":1}}],[\"从而直接影响到应用的性能\",{\"1\":{\"64\":1}}],[\"从而保证了可见性\",{\"1\":{\"216\":1}}],[\"从而保证了操作的内存可见性\",{\"1\":{\"64\":1}}],[\"从而保证集群不会挂掉\",{\"1\":{\"64\":1}}],[\"从而保证临界区中的所有语句全部得到执行\",{\"1\":{\"64\":1}}],[\"从而影响发送方的发送速率\",{\"1\":{\"25\":1}}],[\"从图中可以看出\",{\"1\":{\"51\":1}}],[\"从网络的层级结构看它位于\",{\"1\":{\"47\":1}}],[\"从离浏览器的距离排序的话\",{\"1\":{\"44\":1}}],[\"从上述过程中\",{\"1\":{\"42\":1}}],[\"地址给用户\",{\"1\":{\"45\":1}}],[\"地址是否每次都一样\",{\"1\":{\"45\":1}}],[\"地址时\",{\"1\":{\"43\":1}}],[\"地址并把它缓存到本地\",{\"1\":{\"42\":1}}],[\"地址并不方便记忆\",{\"1\":{\"41\":1}}],[\"地址过程\",{\"1\":{\"42\":1}}],[\"地址转换的过程是如何进行的\",{\"1\":{\"41\":1}}],[\"地址的转换\",{\"1\":{\"41\":2}}],[\"地址\",{\"1\":{\"41\":1,\"42\":1}}],[\"地址信息\",{\"1\":{\"11\":1}}],[\"其它的接口也行\",{\"1\":{\"219\":1}}],[\"其它的运行所需资源都已全部获得\",{\"1\":{\"64\":1}}],[\"其它微服务都类似修改\",{\"1\":{\"219\":1}}],[\"其它不作赘述\",{\"1\":{\"219\":1}}],[\"其内部是基于\",{\"1\":{\"89\":1}}],[\"其初始化过程\",{\"1\":{\"64\":1}}],[\"其次\",{\"1\":{\"64\":1,\"69\":1}}],[\"其中\",{\"1\":{\"218\":2}}],[\"其中的\",{\"1\":{\"218\":1}}],[\"其中包含了若干条指令\",{\"1\":{\"218\":1}}],[\"其中f0b1c8ab3633是容器\",{\"1\":{\"217\":1}}],[\"其中aop就是发生在初始化后这一步骤中\",{\"1\":{\"216\":1}}],[\"其中corepoolsize\",{\"1\":{\"64\":1}}],[\"其中就包含threadlocalmap\",{\"1\":{\"64\":1}}],[\"其基本的设计思想是将远程分布式事务拆分成一系列的本地事务\",{\"1\":{\"64\":1}}],[\"其他安装方式如有兴趣\",{\"1\":{\"219\":1}}],[\"其他事务不能读\",{\"1\":{\"216\":1}}],[\"其他事务不能对其进行加任何锁\",{\"1\":{\"64\":1}}],[\"其他事务也可以读\",{\"1\":{\"216\":1}}],[\"其他一些实战\",{\"0\":{\"130\":1}}],[\"其他段的数据也能被其他线程访问\",{\"1\":{\"83\":1}}],[\"其他方法都是直接调用\",{\"1\":{\"74\":1}}],[\"其他的不能再对他进行操作了\",{\"1\":{\"64\":1}}],[\"其他阻塞\",{\"1\":{\"64\":1}}],[\"其他线程可以调用countdownlatch的countdown\",{\"1\":{\"216\":1}}],[\"其他线程也访问同步方法\",{\"1\":{\"81\":1}}],[\"其他线程调用了该对象的start\",{\"1\":{\"64\":1}}],[\"其他线程被阻塞住\",{\"1\":{\"64\":1}}],[\"其他补偿方式\",{\"1\":{\"64\":1}}],[\"其他进程可以读取\",{\"1\":{\"64\":1}}],[\"其他\",{\"1\":{\"64\":1,\"219\":1}}],[\"其实不难\",{\"1\":{\"216\":1}}],[\"其实不是百度网站真正意义上的地址\",{\"1\":{\"41\":1}}],[\"其实和刚刚按a字段排序之后的好处是类似的\",{\"1\":{\"216\":1}}],[\"其实际含义是isr集合中的副本必须满足下面两个条件\",{\"1\":{\"64\":1}}],[\"其实从原理也能理解\",{\"1\":{\"64\":1}}],[\"其实cglib代理的性能是要远远好于jdk代理的\",{\"1\":{\"64\":1}}],[\"其实即编写了数据结构\",{\"1\":{\"64\":1}}],[\"其实\",{\"1\":{\"64\":1}}],[\"其实它包含了简体中文与繁体中文字符\",{\"1\":{\"64\":1}}],[\"其实效率比linkedlist要高\",{\"1\":{\"64\":1}}],[\"其实这部分又可以称为前端工程师眼中的\",{\"1\":{\"49\":1}}],[\"其实真实的互联网世界背后存在成千上百台服务器\",{\"1\":{\"45\":1}}],[\"其重传时间应比数据在分组传输的平均往返时间更长一些\",{\"1\":{\"23\":1}}],[\"仔细思考这个问题\",{\"1\":{\"39\":1}}],[\"越详细越好\",{\"0\":{\"39\":1}}],[\"谢希仁编著\",{\"1\":{\"36\":1}}],[\"大数据应用比如\",{\"1\":{\"217\":1}}],[\"大数据量高并发的数据库优化\",{\"1\":{\"64\":1}}],[\"大体流程如下\",{\"1\":{\"216\":1}}],[\"大体思路是先设计一个最小可用的远程调用框架\",{\"1\":{\"216\":1}}],[\"大量冗余的代码\",{\"1\":{\"216\":1}}],[\"大量请求访问一份数据怎么设计\",{\"0\":{\"199\":1}}],[\"大而化小\",{\"1\":{\"216\":1}}],[\"大大提高了读的性能\",{\"1\":{\"216\":1}}],[\"大脑\",{\"1\":{\"216\":3}}],[\"大脑分裂\",{\"1\":{\"216\":1}}],[\"大的在右\",{\"1\":{\"216\":1}}],[\"大的在下\",{\"1\":{\"216\":1}}],[\"大size的数据\",{\"1\":{\"69\":1}}],[\"大部分的java类都会以接口\",{\"1\":{\"64\":1}}],[\"大部分情况下\",{\"1\":{\"31\":1}}],[\"大型网站都有复杂的应用\",{\"1\":{\"64\":1}}],[\"大型网站是怎样解决多用户高并发访问的\",{\"1\":{\"64\":1}}],[\"大型的网站甚至更多\",{\"1\":{\"45\":1}}],[\"大家按照自己下载项目的配置文件去修改\",{\"1\":{\"219\":1}}],[\"大家仔细看一下上面方法中的注释\",{\"1\":{\"216\":1}}],[\"大家应该对索引重新有了认识\",{\"1\":{\"216\":1}}],[\"大家应该对升序索引和降序索引有了一个大概的了解\",{\"1\":{\"216\":1}}],[\"大家可能对索引比较熟悉\",{\"1\":{\"216\":1}}],[\"大家可以自行查阅源码\",{\"1\":{\"94\":1}}],[\"大家可以当成一篇\",{\"1\":{\"59\":1}}],[\"大家耳熟能详的\",{\"1\":{\"45\":1}}],[\"大小以及其他属性\",{\"1\":{\"57\":1}}],[\"大二学习这门课程的时候\",{\"1\":{\"36\":1}}],[\"建新的线程来处理被添加的任务\",{\"1\":{\"216\":1}}],[\"建立连接\",{\"1\":{\"64\":1}}],[\"建立连接时使用的握手信号\",{\"1\":{\"17\":1}}],[\"建议使用entrypoint\",{\"1\":{\"231\":1}}],[\"建议使用反斜杠\",{\"1\":{\"231\":1}}],[\"建议\",{\"0\":{\"36\":1}}],[\"私钥加密需要公钥解密\",{\"1\":{\"35\":1}}],[\"且多个容器操作同一个文件\",{\"1\":{\"218\":1}}],[\"且结构不固定\",{\"1\":{\"64\":1}}],[\"且消息量与leader相差不多的副本集合\",{\"1\":{\"64\":1}}],[\"且正常得到响应的时候\",{\"1\":{\"64\":1}}],[\"且\",{\"1\":{\"64\":1}}],[\"且有五种可能取值\",{\"1\":{\"54\":1}}],[\"且根据公钥无法推知私钥\",{\"1\":{\"35\":1}}],[\"且加解密速度快\",{\"1\":{\"35\":1}}],[\"非垃圾\",{\"1\":{\"216\":1}}],[\"非公平锁加锁\",{\"1\":{\"216\":1}}],[\"非核心线程就不需要保活\",{\"1\":{\"216\":1}}],[\"非同一对象\",{\"1\":{\"96\":1}}],[\"非关系型数据库\",{\"1\":{\"64\":1}}],[\"非阻塞io\",{\"1\":{\"64\":1}}],[\"非阻塞式i\",{\"1\":{\"64\":1}}],[\"非阻塞同步\",{\"1\":{\"64\":1}}],[\"非常简单吧\",{\"1\":{\"216\":1}}],[\"非常简要的介绍一下各层的作用\",{\"1\":{\"7\":1}}],[\"非常快速\",{\"1\":{\"64\":1}}],[\"非常推荐大家看一下\",{\"1\":{\"36\":1}}],[\"非对称加密\",{\"1\":{\"35\":1}}],[\"比单纯的bean对象功能更加强大\",{\"1\":{\"216\":1}}],[\"比较所有的子镜像\",{\"1\":{\"231\":1}}],[\"比较轻量\",{\"1\":{\"216\":1}}],[\"比较消耗时间\",{\"1\":{\"216\":1}}],[\"比较这两个对象\",{\"1\":{\"96\":1}}],[\"比较该类的两个对象时\",{\"1\":{\"96\":1}}],[\"比较重要的数据结构\",{\"1\":{\"64\":1}}],[\"比http耗费更多服务器资源\",{\"1\":{\"35\":1}}],[\"比如自动提取\",{\"1\":{\"231\":1}}],[\"比如在一个\",{\"1\":{\"231\":1}}],[\"比如镜像构建时间过长\",{\"1\":{\"231\":1}}],[\"比如启动一个容器\",{\"1\":{\"218\":1}}],[\"比如基于一个image启动多个container\",{\"1\":{\"218\":1}}],[\"比如前面的\",{\"1\":{\"218\":1}}],[\"比如rabbitmq的confirm机制\",{\"1\":{\"216\":1}}],[\"比如redis的自增命令\",{\"1\":{\"216\":1}}],[\"比如十分钟内未支付则取消订单\",{\"1\":{\"216\":1}}],[\"比如针对a\",{\"1\":{\"216\":1}}],[\"比如排序等\",{\"1\":{\"216\":1}}],[\"比如线程1删除了redis缓存数据\",{\"1\":{\"216\":1}}],[\"比如黑客故意伪造一些乱七八糟的key\",{\"1\":{\"216\":1}}],[\"比如tomcat\",{\"1\":{\"216\":1}}],[\"比如用户发送一次下单请求\",{\"1\":{\"216\":1}}],[\"比如用java开发的时候就可以调用memorycache对一些数据进行缓存和通讯共享\",{\"1\":{\"64\":1}}],[\"比如数据正在同步\",{\"1\":{\"216\":1}}],[\"比如由于系统故障\",{\"1\":{\"216\":1}}],[\"比如源码中还涉及到一些beanfactorypostprocessor和beanpostprocessor的注册\",{\"1\":{\"216\":1}}],[\"比如源码中会提供一些模板方法\",{\"1\":{\"216\":1}}],[\"比如某个属性上加\",{\"1\":{\"216\":1}}],[\"比如userservice\",{\"1\":{\"216\":1}}],[\"比如8080被tomcat占用了\",{\"1\":{\"216\":1}}],[\"比如使用nio\",{\"1\":{\"216\":1}}],[\"比如使用id进行适当的元数据处理\",{\"1\":{\"64\":1}}],[\"比如调整minsparethreads参数来改变tomcat空闲时的线程数\",{\"1\":{\"216\":1}}],[\"比如默认的appclassloader\",{\"1\":{\"216\":1}}],[\"比如一个订单系统中可能存在com\",{\"1\":{\"216\":1}}],[\"比如一个song对象中的歌名和歌手名分别采用一种排序方法的话\",{\"1\":{\"85\":1}}],[\"比如哪些线程阻塞\",{\"1\":{\"216\":1}}],[\"比如至少得发送类名或接口名\",{\"1\":{\"216\":1}}],[\"比如如果程序员自己定义了一个\",{\"1\":{\"216\":1}}],[\"比如mybatis\",{\"1\":{\"216\":1}}],[\"比如springcloud\",{\"1\":{\"216\":1}}],[\"比如回到上文出现脑裂问题的场景\",{\"1\":{\"216\":1}}],[\"比如现在有一个由6台zkserver所组成的一个集群\",{\"1\":{\"216\":1}}],[\"比如elasticsearch集群中有master节点\",{\"1\":{\"216\":1}}],[\"比如elasticsearch\",{\"1\":{\"216\":1}}],[\"比如eden区的存活对象晋升到s区放不下\",{\"1\":{\"64\":1}}],[\"比如只有核心线程需要保活\",{\"1\":{\"216\":1}}],[\"比如二叉树\",{\"1\":{\"216\":1}}],[\"比如你现在想来查找b=4\",{\"1\":{\"216\":1}}],[\"比如你怎么实现\",{\"0\":{\"142\":1}}],[\"比如16核\",{\"1\":{\"216\":1}}],[\"比如1111a中的b\",{\"1\":{\"216\":1}}],[\"比如10000个连接以上\",{\"1\":{\"64\":1}}],[\"比如查找a=3的这行记录\",{\"1\":{\"216\":1}}],[\"比如得到\",{\"1\":{\"216\":1}}],[\"比如下面三个语句\",{\"1\":{\"216\":1}}],[\"比如下面我就用\",{\"1\":{\"169\":1}}],[\"比如微博的关注列表\",{\"1\":{\"170\":1}}],[\"比如俩个表\",{\"0\":{\"159\":1}}],[\"比如覆盖索引\",{\"0\":{\"154\":1}}],[\"比如负载均衡以及容错机制\",{\"0\":{\"149\":1}}],[\"比如有4个线程执行\",{\"0\":{\"116\":1}}],[\"比如我现在的dockerfile\",{\"1\":{\"248\":1}}],[\"比如我要配置多个env环境变量\",{\"1\":{\"242\":1}}],[\"比如我们想把用户和订单微服务各部署两个微服务\",{\"1\":{\"219\":1}}],[\"比如我们如果现在想对t1进行order\",{\"1\":{\"216\":1}}],[\"比如我们仍然利用上面所创建的t1表\",{\"1\":{\"216\":1}}],[\"比如我们可以\",{\"1\":{\"169\":1}}],[\"比如我们需要根据键值获取到元素值时就选用map接口下的集合\",{\"1\":{\"91\":1}}],[\"比如我也是这样的\",{\"1\":{\"64\":1}}],[\"比如保存系统运行的上下文\",{\"1\":{\"64\":1}}],[\"比如appreadbufsize\",{\"1\":{\"216\":1}}],[\"比如apache在配置contenttype的时候可以尽量少支持\",{\"1\":{\"64\":1}}],[\"比如a方法使用事务\",{\"0\":{\"137\":1}}],[\"比如arraylist底层有什么的\",{\"0\":{\"98\":1}}],[\"比如alteon\",{\"1\":{\"64\":1}}],[\"比如linux上的rsync等工具\",{\"1\":{\"64\":1}}],[\"比如chinanet和edunet之间的差异就促使了很多网站在教育网内搭建镜像站点\",{\"1\":{\"64\":1}}],[\"比如5w\",{\"1\":{\"64\":2}}],[\"比如正在运行的某个java程序\",{\"1\":{\"64\":1}}],[\"比如访问私有的属性和方\",{\"1\":{\"64\":1}}],[\"比如多个线程争抢synchronized锁对象时\",{\"1\":{\"64\":1}}],[\"比如①我们在\",{\"1\":{\"32\":1}}],[\"比如是使用内存数据库redis保存\",{\"1\":{\"31\":1}}],[\"比如\",{\"1\":{\"20\":1,\"24\":1,\"64\":5,\"68\":1,\"171\":1,\"216\":6,\"217\":2}}],[\"运行环境即我们的应用程序想要正常运行所依赖的环境\",{\"1\":{\"249\":1}}],[\"运行环境打补丁升级等等\",{\"1\":{\"233\":1}}],[\"运行环境也单独组合\",{\"1\":{\"233\":1}}],[\"运行环境单独做镜像\",{\"1\":{\"233\":1}}],[\"运行的线程执行sleep\",{\"1\":{\"64\":1}}],[\"运行的线程执行wait\",{\"1\":{\"64\":1}}],[\"运行的线程在获取对象的同步锁时\",{\"1\":{\"64\":1}}],[\"运行状态\",{\"1\":{\"64\":1}}],[\"运行任务队列中的任务\",{\"1\":{\"57\":1}}],[\"运行在tcp之上\",{\"1\":{\"35\":1}}],[\"运输层主要使用以下两种协议\",{\"1\":{\"9\":1}}],[\"运输层\",{\"0\":{\"9\":1},\"1\":{\"9\":1}}],[\"起始且默认使用端口443\",{\"1\":{\"35\":1}}],[\"起始且默认使用端口80\",{\"1\":{\"35\":1}}],[\"端口\",{\"1\":{\"35\":1}}],[\"错误状态响应码\",{\"1\":{\"33\":1}}],[\"流程图\",{\"1\":{\"216\":1}}],[\"流程图见dubbo\",{\"1\":{\"64\":1}}],[\"流新特性\",{\"1\":{\"64\":1}}],[\"流水线方式是客户在收到http的响应报文之前就能接着发送新的请求报文\",{\"1\":{\"33\":1}}],[\"流量控制所要做到的就是抑制发送端发送数据的速率\",{\"1\":{\"26\":1}}],[\"流量控制往往是点对点通信量的控制\",{\"1\":{\"26\":1}}],[\"流量控制是为了控制发送方发送速率\",{\"1\":{\"25\":1}}],[\"流量控制\",{\"1\":{\"20\":1,\"21\":1}}],[\"默认都在相同的网络下\",{\"1\":{\"219\":1}}],[\"默认为\",{\"1\":{\"219\":1}}],[\"默认为8\",{\"1\":{\"73\":1,\"78\":1,\"90\":1}}],[\"默认以compose所在文件目录名加\",{\"1\":{\"219\":1}}],[\"默认选项\",{\"1\":{\"217\":1}}],[\"默认的初始化大小为16\",{\"1\":{\"73\":1}}],[\"默认的初始大小为11\",{\"1\":{\"73\":1}}],[\"默认重试两次其他服务器\",{\"1\":{\"64\":1}}],[\"默认是\",{\"1\":{\"217\":1}}],[\"默认是阻塞的\",{\"1\":{\"64\":1}}],[\"默认是按升序排序\",{\"1\":{\"64\":1}}],[\"默认也推荐使用netty框架\",{\"1\":{\"64\":1}}],[\"默认情况下\",{\"1\":{\"64\":1,\"218\":1}}],[\"默认情况下所有的网址的最后一位都是\",{\"1\":{\"42\":1}}],[\"默认缓存60s\",{\"1\":{\"64\":1}}],[\"默认0\",{\"1\":{\"64\":1}}],[\"默认confirm\",{\"1\":{\"64\":1}}],[\"默认required\",{\"1\":{\"64\":6}}],[\"默认值为true\",{\"1\":{\"64\":1}}],[\"默认\",{\"1\":{\"64\":3}}],[\"默认开启connection\",{\"1\":{\"33\":1}}],[\"默认使用dubbo协议\",{\"1\":{\"64\":1}}],[\"默认使用hessian序列化\",{\"1\":{\"64\":1}}],[\"默认使用什么序列化框架\",{\"1\":{\"64\":1}}],[\"默认使用的是什么通信框架\",{\"1\":{\"64\":1}}],[\"默认使用的是短连接\",{\"1\":{\"33\":1}}],[\"默认使用长连接\",{\"1\":{\"30\":1,\"33\":1}}],[\"主键为bigint\",{\"1\":{\"216\":1}}],[\"主键索引\",{\"1\":{\"64\":1}}],[\"主节点提供数据存取\",{\"1\":{\"64\":1}}],[\"主线程才执行完成\",{\"1\":{\"64\":1}}],[\"主动方应用根据返回结果进行判断如何处理业务操作处理\",{\"1\":{\"64\":1}}],[\"主动方应用先把消息发送给消息中间件\",{\"1\":{\"64\":1}}],[\"主要指直接内存\",{\"1\":{\"216\":1}}],[\"主要根据集合的特点来选用\",{\"1\":{\"91\":1}}],[\"主要原因在于\",{\"1\":{\"80\":1}}],[\"主要动机在于可以指定最大堆大小\",{\"1\":{\"64\":1}}],[\"主要的的实现技术主要有spring\",{\"1\":{\"64\":1}}],[\"主要考察应聘者对自己做过的事情是否有清晰的描述\",{\"1\":{\"64\":1}}],[\"主要负责的内容\",{\"1\":{\"64\":1}}],[\"主要区别主要体现在\",{\"1\":{\"33\":1}}],[\"主域名服务器缓存\",{\"1\":{\"44\":1}}],[\"主机中正在运行的程序\",{\"1\":{\"8\":1}}],[\"那也就是b+树中的一个节点能存储16条数据\",{\"1\":{\"216\":1}}],[\"那\",{\"1\":{\"216\":1}}],[\"那相应的代码会更多\",{\"1\":{\"216\":1}}],[\"那反转有什么用\",{\"1\":{\"216\":1}}],[\"那我们得自己来做这两件事\",{\"1\":{\"216\":1}}],[\"那到底该如何理解ioc呢\",{\"1\":{\"216\":1}}],[\"那这些对象是什么时候创建的\",{\"1\":{\"216\":1}}],[\"那这又是一大堆需要考虑的了\",{\"1\":{\"216\":1}}],[\"那这16个线程一下子就被这16个请求占用完了\",{\"1\":{\"216\":1}}],[\"那是用http1\",{\"1\":{\"216\":1}}],[\"那是不是也可以设置desc呢\",{\"1\":{\"216\":1}}],[\"那通过什么方式发出去呢\",{\"1\":{\"216\":1}}],[\"那使用何种序列化机制也是要考虑的\",{\"1\":{\"216\":1}}],[\"那如果要通过网络发送对象\",{\"1\":{\"216\":1}}],[\"那如果我们要将这份数据按照b\",{\"1\":{\"216\":1}}],[\"那如果我们将这份数据按照b\",{\"1\":{\"216\":1}}],[\"那最核心的就是网络调用了\",{\"1\":{\"216\":1}}],[\"那就将服务按单个协议\",{\"1\":{\"216\":1}}],[\"那就需要自己设计一个数据格式了\",{\"1\":{\"216\":1}}],[\"那就表示同一个时刻只能处理16个请求\",{\"1\":{\"216\":1}}],[\"那就是1170117016=21\",{\"1\":{\"216\":1}}],[\"那就是最合适的\",{\"1\":{\"216\":1}}],[\"那就是\",{\"1\":{\"43\":1}}],[\"那对于客户来说\",{\"1\":{\"216\":1}}],[\"那非核心线程是怎么回收的呢\",{\"1\":{\"216\":1}}],[\"那线程池中的线程\",{\"1\":{\"216\":1}}],[\"那取出的也是共享变量\",{\"1\":{\"64\":1}}],[\"那个时候只是使用一些较为简单的网页上和网络请求上\",{\"1\":{\"33\":1}}],[\"那么效率之低\",{\"1\":{\"219\":1}}],[\"那么将会占用大量的磁盘空间\",{\"1\":{\"218\":1}}],[\"那么消息将在队列中排队\",{\"1\":{\"216\":1}}],[\"那么出现的id会一样\",{\"1\":{\"216\":1}}],[\"那么zookeeper则不太合适\",{\"1\":{\"216\":1}}],[\"那么解决这类问题\",{\"1\":{\"216\":1}}],[\"那么构造方法将会有非常多的入参\",{\"1\":{\"216\":1}}],[\"那么实际上就是先建立一个数据库连接\",{\"1\":{\"216\":1}}],[\"那么bean则不是线程安全的\",{\"1\":{\"216\":1}}],[\"那么bean则是线程安全的\",{\"1\":{\"216\":1}}],[\"那么对象的控制权会转交给spring\",{\"1\":{\"216\":1}}],[\"那么除开定义这三个类之外\",{\"1\":{\"216\":1}}],[\"那么ioc到底是什么\",{\"1\":{\"216\":1}}],[\"那么则把redolog对象进行持久化\",{\"1\":{\"216\":1}}],[\"那么则认为当前自己所投的节点是leader\",{\"1\":{\"216\":1}}],[\"那么则利用事务管理器创建一个数据库连接\",{\"1\":{\"216\":1}}],[\"那么则会找到对应的controller中的方法\",{\"1\":{\"216\":1}}],[\"那么则会由appclassloader来加载这个类\",{\"1\":{\"216\":1}}],[\"那么则生成一个链表\",{\"1\":{\"216\":1}}],[\"那么extclassloader就会自己尝试加载该类\",{\"1\":{\"216\":1}}],[\"那么表示fullgc实际上是回收了很多对象了\",{\"1\":{\"216\":1}}],[\"那么表里的某一行数据包括了很多字段\",{\"1\":{\"216\":1}}],[\"那么通过\",{\"1\":{\"216\":1}}],[\"那么任务被放入缓冲队列\",{\"1\":{\"216\":1}}],[\"那么spring会负责来创建对象\",{\"1\":{\"216\":1}}],[\"那么springboot默认提供的bean那就不生效了\",{\"1\":{\"216\":1}}],[\"那么sagas工作流引擎就会以相反的顺序调用补偿操作\",{\"1\":{\"64\":1}}],[\"那么也会被删除掉\",{\"1\":{\"216\":1}}],[\"那么也会给数据造成压力\",{\"1\":{\"216\":1}}],[\"那么也可以在自己的spring\",{\"1\":{\"216\":1}}],[\"那么也就是说\",{\"1\":{\"216\":1}}],[\"那么数据发生改变的频率也就越高\",{\"1\":{\"216\":1}}],[\"那么数据如果这样排序有什么好处呢\",{\"1\":{\"216\":1}}],[\"那么机房1和机房2都会选出一个leader\",{\"1\":{\"216\":1}}],[\"那么再来想一个问题\",{\"1\":{\"216\":1}}],[\"那么有一个问题我们想一下\",{\"1\":{\"216\":1}}],[\"那么half=5\",{\"1\":{\"216\":1}}],[\"那么此时就会出现问题了\",{\"1\":{\"216\":1}}],[\"那么如果机房之间的网络断了之后\",{\"1\":{\"216\":1}}],[\"那么会导致人体\",{\"1\":{\"216\":1}}],[\"那么tomcat为什么默认给的是200\",{\"1\":{\"216\":1}}],[\"那么要么我们就设置16个线程\",{\"1\":{\"216\":1}}],[\"那么要查找6次\",{\"1\":{\"216\":1}}],[\"那么线程就会运行结束\",{\"1\":{\"216\":1}}],[\"那么线程就不会阻塞了\",{\"1\":{\"216\":1}}],[\"那么当前线程就会调用poll\",{\"1\":{\"216\":1}}],[\"那么排序之后类似\",{\"1\":{\"216\":1}}],[\"那么这个key就肯定不存在\",{\"1\":{\"216\":1}}],[\"那么这个注解才会生效\",{\"1\":{\"216\":1}}],[\"那么这些数据肯定是存储在文件中的\",{\"1\":{\"216\":1}}],[\"那么这台机器需要多高的性能和储存才能满足亿万请求呢\",{\"1\":{\"45\":1}}],[\"那么a调用b会有几种情况\",{\"0\":{\"137\":1}}],[\"那么调用iteratorbinarysearch\",{\"1\":{\"69\":1}}],[\"那么它就表明\",{\"1\":{\"64\":1}}],[\"那么它的俩个儿子都是黑的\",{\"1\":{\"64\":1}}],[\"那么在日常应用中\",{\"1\":{\"231\":1}}],[\"那么在写一个sql时就一定要提供a字段的条件\",{\"1\":{\"216\":1}}],[\"那么在面对大量访问的时候\",{\"1\":{\"64\":1}}],[\"那么在进入\",{\"1\":{\"47\":1}}],[\"那么设置线程池最大数量是无效的\",{\"1\":{\"64\":1}}],[\"那么建议你选择utf\",{\"1\":{\"64\":1}}],[\"那么相当于开启了事务了\",{\"1\":{\"64\":1}}],[\"那么可以选择一个\",{\"1\":{\"64\":1}}],[\"那么可能会引起网络阻塞\",{\"1\":{\"26\":1}}],[\"那么还是\",{\"1\":{\"64\":1}}],[\"那么肯定要选择linkedlist\",{\"1\":{\"64\":1}}],[\"那么\",{\"1\":{\"64\":3,\"73\":1,\"216\":5,\"217\":1}}],[\"那么用户线程依旧可能同时产生垃圾\",{\"1\":{\"64\":1}}],[\"那么promotion\",{\"1\":{\"64\":1}}],[\"那么就表示此sql走完索引后不用回表了\",{\"1\":{\"216\":1}}],[\"那么就可能导致大量请求直接访问mysql了\",{\"1\":{\"216\":1}}],[\"那么就只能加载一个com\",{\"1\":{\"216\":1}}],[\"那么就得进行调优了\",{\"1\":{\"216\":1}}],[\"那么就需要从某些\",{\"1\":{\"216\":1}}],[\"那么就代表对t1表中的数据已经提前按照b\",{\"1\":{\"216\":1}}],[\"那么就会把mysql中老数据又查到redis中\",{\"1\":{\"216\":1}}],[\"那么就会把这个key\",{\"1\":{\"64\":1}}],[\"那么就会出现每个机房内部都将选出一个leader\",{\"1\":{\"216\":1}}],[\"那么就会存在内存泄露\",{\"1\":{\"64\":1}}],[\"那么就算是业务成功完成\",{\"1\":{\"64\":1}}],[\"那么就要采用可靠性传输协议来纠正出现的差错\",{\"1\":{\"11\":1}}],[\"那么我们在使用mybatis\",{\"1\":{\"216\":1}}],[\"那么我们如何实现\",{\"1\":{\"31\":1}}],[\"那么我们保存用户状态呢\",{\"1\":{\"31\":1}}],[\"存取高效\",{\"1\":{\"79\":1}}],[\"存储键值对\",{\"1\":{\"74\":1}}],[\"存储在客户端中\",{\"1\":{\"32\":1}}],[\"存放在堆中\",{\"1\":{\"64\":1}}],[\"存放在服务器端\",{\"1\":{\"31\":1}}],[\"存活的线程\",{\"1\":{\"64\":1}}],[\"存在三大特性\",{\"1\":{\"216\":1}}],[\"存在一个静态内部类integercache\",{\"1\":{\"216\":1}}],[\"存在一些浪费带宽的现象\",{\"1\":{\"33\":1}}],[\"存在竞争的线程不安全\",{\"1\":{\"64\":1}}],[\"存在慢的提供者累积请求的问题\",{\"1\":{\"64\":1}}],[\"存在着多级缓存\",{\"1\":{\"44\":1}}],[\"下一条指令都是基于上一条指令构建的\",{\"1\":{\"231\":1}}],[\"下载镜像\",{\"1\":{\"217\":1}}],[\"下\",{\"1\":{\"64\":1}}],[\"下图对应的就是\",{\"1\":{\"57\":1}}],[\"下的\",{\"1\":{\"51\":1}}],[\"下次请求过来则交给活跃数最小的服务器来处理\",{\"1\":{\"216\":1}}],[\"下次从最后一条的时间开始查询\",{\"1\":{\"64\":1}}],[\"下次登录的时候只需要根据\",{\"1\":{\"32\":1}}],[\"下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了\",{\"1\":{\"32\":1}}],[\"下面是推荐写法\",{\"1\":{\"231\":1}}],[\"下面是我们常用的一些指令\",{\"1\":{\"231\":1}}],[\"下面是输出的主要内容\",{\"1\":{\"218\":1}}],[\"下面我对这些指令的书写建议详细讲解一下\",{\"1\":{\"231\":1}}],[\"下面我介绍几种常用操作系统的修改方式\",{\"1\":{\"231\":1}}],[\"下面我们进入compose的实战吧\",{\"1\":{\"219\":1}}],[\"下面将列举一些常用的选项\",{\"1\":{\"217\":1}}],[\"下面这个方法保证了\",{\"1\":{\"73\":1}}],[\"下面给出了源代码\",{\"1\":{\"73\":1}}],[\"下面再总结一下\",{\"1\":{\"69\":1}}],[\"下面有介绍到\",{\"1\":{\"68\":1}}],[\"下面的介绍都针对社区版\",{\"1\":{\"217\":1}}],[\"下面的一些文章只是参考\",{\"1\":{\"36\":1}}],[\"下面的两个机器人通过3次握手确定了对方能正确接收和发送消息\",{\"1\":{\"15\":1}}],[\"下面附送一张七层体系结构图总结一下\",{\"1\":{\"13\":1}}],[\"重载服务并重启docker\",{\"0\":{\"226\":1}}],[\"重试次数\",{\"1\":{\"219\":1}}],[\"重试调用库存系统\",{\"1\":{\"216\":1}}],[\"重启docker服务\",{\"1\":{\"217\":1}}],[\"重量级锁会导致线程阻塞\",{\"1\":{\"216\":1}}],[\"重量级锁\",{\"0\":{\"117\":1},\"1\":{\"216\":1}}],[\"重要\",{\"1\":{\"81\":1}}],[\"重构过代码没有\",{\"1\":{\"64\":1}}],[\"重点来了\",{\"1\":{\"79\":1}}],[\"重点在系统调度和单独的单位\",{\"1\":{\"64\":1}}],[\"重点介绍下自己负责那部分的技术细节\",{\"1\":{\"64\":1}}],[\"重新创建docker\",{\"1\":{\"219\":1}}],[\"重新构建有变化的镜像并更新到容器再启动\",{\"1\":{\"219\":1}}],[\"重新进行业务回滚\",{\"1\":{\"64\":1}}],[\"重新登录一般要将\",{\"1\":{\"32\":1}}],[\"重复数据怎么处理\",{\"0\":{\"161\":1}}],[\"重复\",{\"1\":{\"64\":2}}],[\"重绘\",{\"1\":{\"57\":1}}],[\"重定向\",{\"1\":{\"45\":1,\"54\":1}}],[\"重写compareto方法实现按年龄来排序\",{\"0\":{\"87\":1}}],[\"重写\",{\"1\":{\"32\":1}}],[\"重写把\",{\"1\":{\"31\":1}}],[\"重传\",{\"1\":{\"20\":1}}],[\"来指定容器的工作路径\",{\"1\":{\"231\":1}}],[\"来编写一个dockerfile修改该nginx镜像的首页\",{\"1\":{\"218\":1}}],[\"来控制共享资源的使用\",{\"1\":{\"216\":1}}],[\"来控制jvm\",{\"1\":{\"64\":1}}],[\"来赋值\",{\"1\":{\"216\":2}}],[\"来连接数据库\",{\"1\":{\"216\":1}}],[\"来获取许可\",{\"1\":{\"216\":1}}],[\"来查找数据\",{\"1\":{\"216\":1}}],[\"来自issue\",{\"1\":{\"94\":1}}],[\"来实现的\",{\"1\":{\"89\":1}}],[\"来保存元素\",{\"1\":{\"89\":1}}],[\"来保证线程安全\",{\"1\":{\"81\":1}}],[\"来操作\",{\"1\":{\"81\":1}}],[\"来组织数据的数据库\",{\"1\":{\"64\":1}}],[\"来源\",{\"1\":{\"64\":1}}],[\"来进行任务拒绝处理\",{\"1\":{\"64\":1}}],[\"来方式来跟踪\",{\"1\":{\"31\":1}}],[\"来表示\",{\"1\":{\"10\":1}}],[\"跟bean的作用域没有关系\",{\"1\":{\"216\":1}}],[\"跟踪器无法像在leader收集数据那样快速地获取数据\",{\"1\":{\"64\":1}}],[\"跟踪呢\",{\"1\":{\"31\":1}}],[\"跟着自己的节奏结束通话\",{\"1\":{\"19\":1}}],[\"实际使用到的索引长度\",{\"1\":{\"216\":1}}],[\"实际上使用的索引\",{\"1\":{\"216\":1}}],[\"实际上不算一层\",{\"1\":{\"216\":1}}],[\"实际上仍然只是最终一致性的\",{\"1\":{\"216\":1}}],[\"实际上这是一个非常大的问题\",{\"1\":{\"216\":1}}],[\"实际上这就是索引的原理\",{\"1\":{\"216\":1}}],[\"实际上就是启动了一个jvm\",{\"1\":{\"216\":1}}],[\"实际上b\",{\"1\":{\"216\":1}}],[\"实际上cglib代理并不如jdk代理\",{\"1\":{\"64\":1}}],[\"实际上\",{\"1\":{\"64\":1}}],[\"实时化化后\",{\"1\":{\"216\":1}}],[\"实时排行信息包含直播间在线用户列表\",{\"1\":{\"172\":1}}],[\"实懈化\",{\"1\":{\"216\":1}}],[\"实的化\",{\"1\":{\"216\":1}}],[\"实耐化前\",{\"1\":{\"216\":1}}],[\"实斛化化\",{\"1\":{\"216\":1}}],[\"实践\",{\"1\":{\"216\":1}}],[\"实例化\",{\"1\":{\"216\":1}}],[\"实例3的ip和port\",{\"1\":{\"216\":3}}],[\"实例2的ip和port\",{\"1\":{\"216\":3}}],[\"实例1的ip和port\",{\"1\":{\"216\":3}}],[\"实战总结\",{\"0\":{\"191\":1}}],[\"实战用到没有\",{\"0\":{\"141\":1}}],[\"实战开发\",{\"1\":{\"64\":1}}],[\"实现是\",{\"1\":{\"216\":1}}],[\"实现简单的高性能分页\",{\"1\":{\"170\":1}}],[\"实现分页查询\",{\"1\":{\"170\":1}}],[\"实现一样\",{\"1\":{\"89\":1}}],[\"实现线程安全的方式\",{\"1\":{\"81\":1}}],[\"实现线程安全的三种方式\",{\"1\":{\"64\":1}}],[\"实现set接口\",{\"1\":{\"74\":1}}],[\"实现了更高效率的传输\",{\"1\":{\"216\":1}}],[\"实现了访问顺序相关逻辑\",{\"1\":{\"90\":1}}],[\"实现了map接口\",{\"1\":{\"74\":1}}],[\"实现了\",{\"1\":{\"69\":3,\"83\":1}}],[\"实现了网址到\",{\"1\":{\"41\":1}}],[\"实现\",{\"1\":{\"64\":1,\"69\":1,\"81\":1}}],[\"实现原理与\",{\"1\":{\"64\":1}}],[\"实现类\",{\"1\":{\"64\":1}}],[\"实现上是在entry上再增加属性before\",{\"1\":{\"64\":1}}],[\"实现资源的可配置和易管理\",{\"1\":{\"64\":1}}],[\"实现技术\",{\"1\":{\"64\":1}}],[\"实现的方式来设计类\",{\"1\":{\"64\":1}}],[\"实现的方式来完成\",{\"1\":{\"64\":1}}],[\"实现的\",{\"1\":{\"64\":1,\"74\":1,\"89\":1,\"94\":1,\"231\":1}}],[\"实现场景\",{\"1\":{\"64\":1}}],[\"实现方式\",{\"1\":{\"64\":1}}],[\"实现长连接需要客户端和服务端都支持长连接\",{\"1\":{\"30\":1}}],[\"实质上是tcp协议的长连接和短连接\",{\"1\":{\"30\":1}}],[\"会以\",{\"1\":{\"231\":1}}],[\"会话超时时间\",{\"1\":{\"219\":1}}],[\"会轮询访问服务对应的每台容器ip\",{\"1\":{\"219\":1}}],[\"会通过两阶段机制来处理\",{\"1\":{\"216\":1}}],[\"会利用两阶段提交来广播该写请求\",{\"1\":{\"216\":1}}],[\"会利用\",{\"1\":{\"216\":1}}],[\"会对加了\",{\"1\":{\"216\":1}}],[\"会出现什么情况\",{\"1\":{\"216\":1}}],[\"会出现阻塞\",{\"1\":{\"64\":1}}],[\"会为部署的每个应用都生成一个类加载器实例\",{\"1\":{\"216\":1}}],[\"会委派给ext和bootstrap进行加载\",{\"1\":{\"216\":1}}],[\"会先检查本地是否存在指定镜像\",{\"1\":{\"217\":1}}],[\"会先检查aqs队列中是否存在线程在排队\",{\"1\":{\"216\":1}}],[\"会先根据条件找到数据所在的页\",{\"1\":{\"216\":1}}],[\"会先进行领导者选举\",{\"1\":{\"216\":1}}],[\"会先判断该方法上是否加了\",{\"1\":{\"216\":1}}],[\"会先使用extclassloader的loadclass方法来加载类\",{\"1\":{\"216\":1}}],[\"会调用appclassloader的loadclass方法来加载这个类\",{\"1\":{\"216\":1}}],[\"会调用integer的valueof方法\",{\"1\":{\"216\":1}}],[\"会从aqs中正在排队的第一个线程开始依次唤醒\",{\"1\":{\"216\":1}}],[\"会直接将cpu高级缓存中的数据写回到主内存\",{\"1\":{\"216\":1}}],[\"会直接使用你给定的大小\",{\"1\":{\"73\":1}}],[\"会复制一个新的数组\",{\"1\":{\"216\":1}}],[\"会新生成一个字符串对象\",{\"1\":{\"216\":1}}],[\"会在每个容器的文件系统里生成一个副本\",{\"1\":{\"218\":1}}],[\"会在加载类的时候执行\",{\"1\":{\"216\":1}}],[\"会在响应头加入这行代码\",{\"1\":{\"30\":1}}],[\"会执行terminated\",{\"1\":{\"216\":1}}],[\"会中断所有工作线程\",{\"1\":{\"216\":2}}],[\"会判断当前线程池中有多少个线程\",{\"1\":{\"216\":1}}],[\"会判断当前申请的虚拟地址空间大小是否超过剩余内存大小\",{\"1\":{\"64\":1}}],[\"会按主键进行排序\",{\"1\":{\"216\":1}}],[\"会问rabbitmq和kakfa区别或者\",{\"0\":{\"164\":1}}],[\"会造成元素之间会形成一个循环链表\",{\"1\":{\"80\":1}}],[\"会将\",{\"1\":{\"216\":2}}],[\"会将其扩充为2的幂次方大小\",{\"1\":{\"73\":1}}],[\"会将list扩容一倍\",{\"1\":{\"64\":1}}],[\"会默认在将指定的元素追加到此列表的末尾\",{\"1\":{\"68\":1}}],[\"会引起系统oom杀进程\",{\"1\":{\"64\":1}}],[\"会继续与leader副本进行同步\",{\"1\":{\"64\":1}}],[\"会继续使用这一条已经建立的连接\",{\"1\":{\"30\":1}}],[\"会进行消息重传\",{\"1\":{\"64\":1}}],[\"会更佳稳定\",{\"1\":{\"64\":1}}],[\"会使用\",{\"1\":{\"64\":1}}],[\"会使用表级锁\",{\"1\":{\"64\":1}}],[\"会导致消息丢失\",{\"1\":{\"216\":1}}],[\"会导致无限创建线程\",{\"1\":{\"64\":1}}],[\"会导致一定的系统开销\",{\"1\":{\"64\":1}}],[\"会导致内存被任务队列占满\",{\"1\":{\"64\":1}}],[\"会自动释放线程资源\",{\"1\":{\"64\":1}}],[\"会空指针异常\",{\"1\":{\"64\":1}}],[\"会尝试通过程序来补偿并邮件通知相关人员\",{\"1\":{\"64\":1}}],[\"会有邮件通知\",{\"1\":{\"64\":1}}],[\"会有三次握手来建立连接\",{\"1\":{\"20\":1}}],[\"会触发死循环\",{\"1\":{\"64\":1}}],[\"会触发fullgc\",{\"1\":{\"64\":1}}],[\"会向处理器发送一条\",{\"1\":{\"64\":1}}],[\"浏览器则负责解析并渲染\",{\"1\":{\"216\":1}}],[\"浏览器发出一个请求到收到响应经历了哪些步骤\",{\"1\":{\"216\":1}}],[\"浏览器中最耗时的部分就是\",{\"1\":{\"58\":1}}],[\"浏览器中输入\",{\"1\":{\"44\":1}}],[\"浏览器开始进行解析渲染\",{\"1\":{\"58\":1}}],[\"浏览器开始布局渲染树并将其绘制到屏幕上\",{\"1\":{\"57\":1}}],[\"浏览器将重复\",{\"1\":{\"57\":1}}],[\"浏览器便开始绘制内容\",{\"1\":{\"57\":1}}],[\"浏览器是一个边解析边渲染的过程\",{\"1\":{\"57\":1}}],[\"浏览器在解析过程中\",{\"1\":{\"57\":1}}],[\"浏览器在收到\",{\"1\":{\"57\":1}}],[\"浏览器在请求\",{\"1\":{\"42\":1}}],[\"浏览器的\",{\"1\":{\"44\":1}}],[\"浏览器缓存\",{\"1\":{\"44\":1}}],[\"浏览器端\",{\"1\":{\"32\":1}}],[\"浏览器就会重新建立一个http会话\",{\"1\":{\"30\":1}}],[\"浏览器解析渲染页面\",{\"0\":{\"57\":1},\"1\":{\"27\":1,\"39\":1}}],[\"任意方法中获取缓存的数据\",{\"1\":{\"216\":1}}],[\"任何一个key\",{\"1\":{\"64\":1}}],[\"任何一方都可以在数据传送结束后发出连接释放的通知\",{\"1\":{\"19\":1}}],[\"任务\",{\"1\":{\"64\":2,\"217\":1}}],[\"任务一般分为\",{\"1\":{\"64\":1}}],[\"任务类型不同\",{\"1\":{\"64\":1}}],[\"任务结束就中断连接\",{\"1\":{\"30\":1}}],[\"短连接究竟是什么\",{\"1\":{\"30\":1}}],[\"短连接\",{\"0\":{\"30\":1}}],[\"9999\",{\"1\":{\"219\":4}}],[\"9876\",{\"1\":{\"219\":4}}],[\"9822731\",{\"1\":{\"64\":1}}],[\"9300\",{\"1\":{\"219\":2}}],[\"9091\",{\"1\":{\"219\":1}}],[\"9090\",{\"1\":{\"219\":1}}],[\"907\",{\"1\":{\"216\":1}}],[\"9200\",{\"1\":{\"219\":3}}],[\"92\",{\"1\":{\"218\":2}}],[\"91\",{\"1\":{\"217\":2}}],[\"9ribbon\",{\"1\":{\"216\":1}}],[\"9同时leader节点还是将当前写请求直接发送给observer节点\",{\"1\":{\"216\":1}}],[\"9viewreslover\",{\"1\":{\"216\":1}}],[\"9spring事务的隔离级别对应的就是数据库的隔离级别\",{\"1\":{\"216\":1}}],[\"9浏览器所在的服务器拿到结果后再传递给浏览器\",{\"1\":{\"216\":1}}],[\"9606\",{\"1\":{\"80\":1}}],[\"960\",{\"1\":{\"64\":1}}],[\"9\",{\"0\":{\"29\":1,\"79\":1,\"102\":1,\"184\":1,\"200\":1},\"1\":{\"64\":3,\"86\":5,\"94\":1,\"216\":2,\"217\":3,\"219\":4,\"231\":1}}],[\"8844\",{\"1\":{\"219\":4}}],[\"8848\",{\"1\":{\"219\":5}}],[\"8877\",{\"1\":{\"219\":4}}],[\"8888\",{\"1\":{\"219\":8}}],[\"8888h\",{\"1\":{\"216\":2}}],[\"8866\",{\"1\":{\"219\":5}}],[\"8761\",{\"1\":{\"218\":8,\"219\":4}}],[\"870915876\",{\"1\":{\"64\":1}}],[\"8b+6b\",{\"1\":{\"216\":1}}],[\"8spring\",{\"1\":{\"216\":1}}],[\"8然后发送commit命令给follower节点\",{\"1\":{\"216\":1}}],[\"8dispatcherservlet\",{\"1\":{\"216\":1}}],[\"8在spring启动过程中还会去处理\",{\"1\":{\"216\":1}}],[\"8在链表长度超过一定阈值\",{\"1\":{\"84\":1}}],[\"8如果出现了异常\",{\"1\":{\"216\":1}}],[\"8tomcat得到响应结果后封装成http响应的格式\",{\"1\":{\"216\":1}}],[\"8版本的concurrenthashmap不再基于segment实现\",{\"1\":{\"216\":1}}],[\"8版本\",{\"1\":{\"216\":2}}],[\"8以后在解决哈希冲突时有了较大的变化\",{\"1\":{\"90\":1}}],[\"8中还能看到\",{\"1\":{\"81\":1}}],[\"8中的改进\",{\"1\":{\"64\":1}}],[\"8系列之重新认识hashmap\",{\"1\":{\"78\":1}}],[\"8编码\",{\"1\":{\"64\":2}}],[\"8之后的hashmap底层都用到了红黑树\",{\"1\":{\"78\":1}}],[\"8之后在解决哈希冲突时有了较大的变化\",{\"1\":{\"78\":1}}],[\"8之后\",{\"0\":{\"78\":1}}],[\"8之后list\",{\"1\":{\"64\":1}}],[\"8之前hashmap由数组+链表组成的\",{\"1\":{\"90\":1}}],[\"8之前\",{\"0\":{\"77\":1}}],[\"8之前list\",{\"1\":{\"64\":1}}],[\"81288633\",{\"1\":{\"64\":1}}],[\"8的结构类似\",{\"1\":{\"84\":1}}],[\"8的结构一样\",{\"1\":{\"81\":1}}],[\"8的concurrenthashmap\",{\"1\":{\"81\":1}}],[\"8的几个特性\",{\"1\":{\"64\":1}}],[\"8的扩容实现\",{\"1\":{\"64\":2}}],[\"8的不同实现\",{\"1\":{\"64\":2}}],[\"8及之后\",{\"1\":{\"64\":1}}],[\"8334952\",{\"1\":{\"64\":1}}],[\"8076\",{\"1\":{\"219\":1}}],[\"8001\",{\"1\":{\"219\":2}}],[\"8000\",{\"1\":{\"219\":3}}],[\"8081\",{\"1\":{\"219\":1}}],[\"8080\",{\"1\":{\"49\":1,\"219\":2}}],[\"80233859\",{\"1\":{\"64\":1}}],[\"80\",{\"1\":{\"49\":1,\"217\":1,\"218\":1}}],[\"8\",{\"0\":{\"28\":1,\"76\":1,\"84\":1,\"101\":1,\"159\":1,\"183\":1,\"199\":1},\"1\":{\"43\":1,\"64\":8,\"73\":2,\"77\":5,\"80\":1,\"81\":3,\"84\":1,\"90\":1,\"216\":3,\"217\":4,\"218\":1,\"219\":15,\"231\":1,\"248\":1}}],[\"打包你的纠结\",{\"1\":{\"217\":1}}],[\"打开对年老代的压缩\",{\"1\":{\"64\":1}}],[\"打开网页的速度比较快\",{\"1\":{\"64\":1}}],[\"打开一个网页\",{\"1\":{\"27\":1}}],[\"打电话\",{\"1\":{\"19\":1}}],[\"有写作env\",{\"1\":{\"242\":1}}],[\"有效减小镜像体积\",{\"1\":{\"231\":1}}],[\"有性能损耗\",{\"1\":{\"218\":1}}],[\"有的容器需要把\",{\"1\":{\"217\":1}}],[\"有以下四种格式\",{\"1\":{\"217\":1}}],[\"有以下几种\",{\"1\":{\"44\":1}}],[\"有client和service两部分表示docker安装启动都成功了\",{\"1\":{\"217\":1}}],[\"有两个版本\",{\"1\":{\"217\":1}}],[\"有其他线程读了mysql\",{\"1\":{\"216\":1}}],[\"有一种说法是rpc协议是http协议之上的一种协议\",{\"1\":{\"216\":1}}],[\"有一个特征\",{\"1\":{\"216\":1}}],[\"有一个前提条件就是没有考虑过半机制\",{\"1\":{\"216\":1}}],[\"有一些知名的产品可以选择\",{\"1\":{\"64\":1}}],[\"有一些第三方的\",{\"1\":{\"64\":1}}],[\"有a\",{\"1\":{\"216\":1}}],[\"有界队列和无界队列\",{\"0\":{\"119\":1}}],[\"有哪几种线程池\",{\"0\":{\"115\":1}}],[\"有哪些实现方案\",{\"1\":{\"216\":2}}],[\"有哪些解决方案\",{\"1\":{\"216\":1}}],[\"有哪些情况会导致内存泄露\",{\"1\":{\"64\":1}}],[\"有哪些方法\",{\"1\":{\"64\":1}}],[\"有点类似于我们之前说的linkedhashmap\",{\"1\":{\"89\":1}}],[\"有序集合可以设置顺序\",{\"1\":{\"216\":1}}],[\"有序性\",{\"1\":{\"216\":1}}],[\"有序性和可见性\",{\"1\":{\"64\":1}}],[\"有序\",{\"1\":{\"89\":1}}],[\"有序的对象\",{\"1\":{\"67\":1}}],[\"有关单链表中环的问题\",{\"1\":{\"64\":1}}],[\"有可能版本不对\",{\"1\":{\"219\":1}}],[\"有可能在生产后发生消息偏移吗\",{\"1\":{\"64\":1}}],[\"有可能修改\",{\"1\":{\"57\":1}}],[\"有什么场景\",{\"0\":{\"102\":1}}],[\"有什么差别呢\",{\"1\":{\"64\":1}}],[\"有什么作用\",{\"1\":{\"64\":1}}],[\"有什么区别\",{\"1\":{\"50\":1,\"54\":1,\"64\":1}}],[\"有没用用户非本地缓存\",{\"1\":{\"64\":2}}],[\"有http\",{\"1\":{\"64\":1}}],[\"有很多专业的服务提供商和产品可以选择\",{\"1\":{\"64\":1}}],[\"有很多专业的现成的解决架构和产品可选\",{\"1\":{\"64\":1}}],[\"有个每秒钟5k个请求\",{\"1\":{\"64\":2}}],[\"有利于动态调整提供者权重\",{\"1\":{\"64\":1}}],[\"有永久代\",{\"1\":{\"64\":2}}],[\"有技术亮点的项目或平台\",{\"1\":{\"64\":1}}],[\"有时我们需要扩容微服务\",{\"1\":{\"219\":1}}],[\"有时会造成页面卡顿\",{\"1\":{\"57\":1}}],[\"有时候也可使用\",{\"1\":{\"51\":1}}],[\"有了过半机制\",{\"1\":{\"216\":1}}],[\"有了这个有序的数列之后\",{\"1\":{\"216\":1}}],[\"有了\",{\"1\":{\"26\":2}}],[\"有确认\",{\"1\":{\"20\":1}}],[\"中使用\",{\"1\":{\"241\":1}}],[\"中使用以下指令\",{\"1\":{\"231\":1}}],[\"中如果使用了entrypoint指令\",{\"1\":{\"231\":1}}],[\"中指定的命令\",{\"1\":{\"231\":1}}],[\"中路径会基于模板文件路径\",{\"1\":{\"219\":1}}],[\"中添加如下指令\",{\"1\":{\"231\":1}}],[\"中添加以下指令\",{\"1\":{\"231\":2}}],[\"中添加内容如下\",{\"1\":{\"219\":1}}],[\"中添加或删除元素的场合更为合适\",{\"1\":{\"64\":1}}],[\"中配置你应用的服务\",{\"1\":{\"219\":1}}],[\"中都存在一个threadlocalmap\",{\"1\":{\"216\":1}}],[\"中也是使用字符数组保存字符串char\",{\"1\":{\"94\":1}}],[\"中带有初始容量的构造函数\",{\"1\":{\"73\":1}}],[\"中生存\",{\"1\":{\"64\":1}}],[\"中进行选择\",{\"1\":{\"64\":1}}],[\"中的服务共享相同的\",{\"1\":{\"241\":1}}],[\"中的entrypoint指令\",{\"1\":{\"231\":1}}],[\"中的\",{\"1\":{\"96\":1,\"172\":1,\"216\":1}}],[\"中的对象是不可变的\",{\"1\":{\"94\":1}}],[\"中的方法\",{\"1\":{\"74\":1}}],[\"中的tablesizefor\",{\"1\":{\"73\":1}}],[\"中的元素可以使用\",{\"1\":{\"64\":1}}],[\"中的全部字节并写入到指定的\",{\"1\":{\"64\":1}}],[\"中的所有剩余字节\",{\"1\":{\"64\":1}}],[\"中读取指定数量的字节到数组中\",{\"1\":{\"64\":1}}],[\"中包含的数据\",{\"1\":{\"64\":1}}],[\"中增加了新的方法来读取和复制\",{\"1\":{\"64\":1}}],[\"中直接输入表达式并查看其执行结果\",{\"1\":{\"64\":1}}],[\"中取任务并处理\",{\"1\":{\"64\":1}}],[\"中间件\",{\"0\":{\"160\":1}}],[\"中间件篇\",{\"1\":{\"64\":2}}],[\"中间第三条丢失\",{\"1\":{\"24\":1}}],[\"中搜索\",{\"1\":{\"59\":1}}],[\"中存储一些敏感信息\",{\"1\":{\"32\":1}}],[\"中保存已经登录过得用户信息\",{\"1\":{\"32\":1}}],[\"中附加一个\",{\"1\":{\"31\":1}}],[\"中设定这个时间\",{\"1\":{\"30\":1}}],[\"中\",{\"1\":{\"26\":1,\"32\":2,\"44\":1,\"64\":6,\"73\":2,\"216\":2,\"218\":1,\"230\":1}}],[\"因而参数传递时\",{\"1\":{\"64\":1}}],[\"因为copy指令更加透明\",{\"1\":{\"231\":1}}],[\"因为使用\",{\"1\":{\"231\":1}}],[\"因为索引是用来加快查询的\",{\"1\":{\"216\":1}}],[\"因为只有一个提供者时\",{\"1\":{\"216\":1}}],[\"因为zookeeper是cp的\",{\"1\":{\"216\":1}}],[\"因为zookeeper保证的是cp\",{\"1\":{\"216\":1}}],[\"因为redis保证的是ap\",{\"1\":{\"216\":1}}],[\"因为默认是没有配置实际扫描路径\",{\"1\":{\"216\":1}}],[\"因为它是java层面提供的\",{\"1\":{\"216\":1}}],[\"因为底层cglib是基于父子类来实现的\",{\"1\":{\"216\":1}}],[\"因为spring事务是基于代理来实现的\",{\"1\":{\"216\":1}}],[\"因为当threadlocal对象使用完之后\",{\"1\":{\"216\":1}}],[\"因为当你查到4311d这行记录时\",{\"1\":{\"216\":1}}],[\"因为这样不需要等待所有zkserver都投了同一个zkserver就可以选举出来一个leader了\",{\"1\":{\"216\":1}}],[\"因为我们使用字段注入是没有限制的\",{\"1\":{\"216\":1}}],[\"因为我们都知道并不是线程越多越好\",{\"1\":{\"216\":1}}],[\"因为我不想排队\",{\"1\":{\"216\":1}}],[\"因为如果出现了多发\",{\"1\":{\"216\":1}}],[\"因为如果是order\",{\"1\":{\"216\":1}}],[\"因为如果一个类被final修饰\",{\"1\":{\"64\":1}}],[\"因为篇幅不想太长\",{\"1\":{\"216\":1}}],[\"因为不可能两个订单服务的容器映射到宿主机的同一个端口\",{\"1\":{\"219\":1}}],[\"因为不想篇幅太长\",{\"1\":{\"216\":1}}],[\"因为不同的线程执行逻辑有所不同\",{\"1\":{\"64\":1}}],[\"因为大家并不知道升序索引与降序索引底层到底是如何实现的\",{\"1\":{\"216\":1}}],[\"因为多线程下使用\",{\"1\":{\"80\":1}}],[\"因为二叉查找树在某些情况下会退化成一个线性结构\",{\"1\":{\"78\":1}}],[\"因为毕竟扰动了\",{\"1\":{\"77\":1}}],[\"因为除了\",{\"1\":{\"74\":1}}],[\"因为要存放直接后继和直接前驱以及数据\",{\"1\":{\"68\":1}}],[\"因为需要先移动到指定位置再插入\",{\"1\":{\"68\":1}}],[\"因为在进行上述操作的时候集合中第\",{\"1\":{\"68\":1}}],[\"因为此时栈中保存的信息都是方法返回的记录点\",{\"1\":{\"64\":1}}],[\"因为没有指针\",{\"1\":{\"64\":1}}],[\"因为一个是栈中的数据一个是堆中的数据\",{\"1\":{\"64\":2}}],[\"因为其占用的空间一般是1~8个字节\",{\"1\":{\"64\":2}}],[\"因为线程安全的问题\",{\"1\":{\"73\":1}}],[\"因为线程池的最大值了integer\",{\"1\":{\"64\":1}}],[\"因为线程获得锁才能进入临界区\",{\"1\":{\"64\":1}}],[\"因为new\",{\"1\":{\"64\":1}}],[\"因为该锁是互斥锁\",{\"1\":{\"64\":1}}],[\"因为越慢的提供者的调用前后计数差会越大\",{\"1\":{\"64\":1}}],[\"因为相对于parallel来说\",{\"1\":{\"64\":1}}],[\"因为红黑树是有序的\",{\"1\":{\"64\":1}}],[\"因为涉及到的东西比较多\",{\"1\":{\"59\":1}}],[\"因为\",{\"1\":{\"31\":1,\"32\":1,\"64\":2,\"96\":1,\"216\":1}}],[\"因为现在还不知道网络的符合情况\",{\"1\":{\"26\":1}}],[\"因此我们的基础镜像只需要安装jre环境即可\",{\"1\":{\"231\":1}}],[\"因此只要基础镜像能够满足应用的运行环境即可\",{\"1\":{\"231\":1}}],[\"因此不同功能的应用应该尽量拆分为不同的容器\",{\"1\":{\"231\":1}}],[\"因此新建一个docker容器只需要几秒钟\",{\"1\":{\"218\":1}}],[\"因此适合读多写少的应用场景\",{\"1\":{\"216\":1}}],[\"因此如果节点在任何情况下都失败了\",{\"1\":{\"64\":1}}],[\"因此在程序运行时\",{\"1\":{\"64\":2}}],[\"因此栈中存储就够了\",{\"1\":{\"64\":2}}],[\"因此栈和堆的拆分\",{\"1\":{\"64\":1}}],[\"因此就会限制住栈存储内容的能力\",{\"1\":{\"64\":1}}],[\"因此里面存储的信息都是跟当前线程\",{\"1\":{\"64\":1}}],[\"因此需要一个独立的线程栈\",{\"1\":{\"64\":1}}],[\"因此堆内存会突然增加\",{\"1\":{\"64\":1}}],[\"因此arraylist更节省空间\",{\"1\":{\"64\":2}}],[\"因此当平台发生改变的时候\",{\"1\":{\"64\":1}}],[\"因此\",{\"1\":{\"64\":5,\"218\":1,\"231\":2}}],[\"因此最好能维持一个长连接\",{\"1\":{\"33\":1}}],[\"因此每发送完一个分组需要设置一个超时计时器\",{\"1\":{\"23\":1}}],[\"因此互联网的网络层也叫做网际层或ip层\",{\"1\":{\"10\":1}}],[\"因此分组也叫\",{\"1\":{\"10\":1}}],[\"因此运输层有复用和分用的功能\",{\"1\":{\"9\":1}}],[\"快\",{\"1\":{\"216\":1}}],[\"快回传\",{\"1\":{\"64\":1}}],[\"快排为什么不稳定\",{\"1\":{\"64\":1}}],[\"快速随机访问就是通过元素的序号快速获取元素对象\",{\"1\":{\"68\":1}}],[\"快速\",{\"1\":{\"64\":1}}],[\"快速的意思就是在尽可能短的时间内完成页面的加载\",{\"1\":{\"58\":1}}],[\"快速重传和恢复\",{\"1\":{\"26\":2}}],[\"快速排序\",{\"0\":{\"4\":1},\"1\":{\"64\":1}}],[\"快恢复\",{\"1\":{\"26\":1}}],[\"快重传与快恢复\",{\"1\":{\"26\":1}}],[\"快重传\",{\"1\":{\"26\":1}}],[\"慢开始算法的思路是当主机开始发送数据时\",{\"1\":{\"26\":1}}],[\"慢开始\",{\"1\":{\"26\":2}}],[\"即都是同一个工程下\",{\"1\":{\"219\":1}}],[\"即消息的处理尽可能再同一个线程内完成\",{\"1\":{\"216\":1}}],[\"即将模型数据填充至视图中\",{\"1\":{\"216\":1}}],[\"即可命中构建缓存\",{\"1\":{\"231\":1}}],[\"即可通过\",{\"1\":{\"230\":1}}],[\"即可创建并启动配置中引用的所有服务\",{\"1\":{\"219\":1}}],[\"即可使用该镜像启动一个\",{\"1\":{\"218\":1}}],[\"即可新建并启动一个容器\",{\"1\":{\"217\":1}}],[\"即可停止容器\",{\"1\":{\"217\":1}}],[\"即可\",{\"1\":{\"216\":1,\"252\":1}}],[\"即可以支持反向查找和遍历\",{\"1\":{\"170\":1}}],[\"即可免费无套路获取\",{\"1\":{\"91\":1}}],[\"即可免费领取\",{\"1\":{\"91\":1}}],[\"即使线程池中的线程都处于空闲状态\",{\"1\":{\"216\":1}}],[\"即使这两个对象指向相同的数据\",{\"1\":{\"75\":1}}],[\"即使确认丢失\",{\"1\":{\"24\":1}}],[\"即malloc总是能成功\",{\"1\":{\"64\":1}}],[\"即最后一条消息的offset的差值小于指定阈值\",{\"1\":{\"64\":1}}],[\"即上述配置下\",{\"1\":{\"64\":1}}],[\"即一个对象引用\",{\"1\":{\"64\":1}}],[\"即非叶子节点\",{\"1\":{\"64\":1}}],[\"即引用的处理跟基本类型是完全一样的\",{\"1\":{\"64\":1}}],[\"即数据怎么放\",{\"1\":{\"64\":1}}],[\"即程序如何执行\",{\"1\":{\"64\":1}}],[\"即不用改变程序\",{\"1\":{\"64\":1}}],[\"即在就绪状态的进程除cpu之外\",{\"1\":{\"64\":1}}],[\"即在执行到内存屏障这句指令时\",{\"1\":{\"64\":1}}],[\"即2147483647\",{\"1\":{\"64\":1}}],[\"即为数据增加一个版本标识\",{\"1\":{\"64\":1}}],[\"即控制反转\",{\"1\":{\"64\":1}}],[\"即用一种aspectj支持的特定语言编写切面\",{\"1\":{\"64\":1}}],[\"即空结点是黑的\",{\"1\":{\"64\":1}}],[\"即每个儿子都不愿意干活\",{\"1\":{\"64\":1}}],[\"即每经过一个往返时间rtt就把发送放的cwnd加1\",{\"1\":{\"26\":1}}],[\"即释放锁前\",{\"1\":{\"64\":1}}],[\"即对内容进行压缩\",{\"1\":{\"58\":1}}],[\"即返回码是206\",{\"1\":{\"33\":1}}],[\"即无状态\",{\"1\":{\"31\":1}}],[\"即由小到大逐渐增大发送窗口\",{\"1\":{\"26\":1}}],[\"即\",{\"1\":{\"26\":1,\"34\":1,\"58\":1,\"64\":3,\"96\":2}}],[\"相当灵活\",{\"1\":{\"216\":1}}],[\"相信你已经对\",{\"1\":{\"231\":1}}],[\"相信\",{\"1\":{\"216\":1}}],[\"相信也肯定有\",{\"1\":{\"64\":1}}],[\"相比\",{\"1\":{\"216\":2}}],[\"相比较接口级注册而言就稍微麻烦了一点\",{\"1\":{\"216\":1}}],[\"相比使用\",{\"1\":{\"94\":1}}],[\"相比于之前的版本\",{\"1\":{\"78\":1}}],[\"相比于\",{\"1\":{\"48\":1,\"77\":2}}],[\"相差不多\",{\"1\":{\"64\":1}}],[\"相应栈中只需记录堆中的一个地址即可\",{\"1\":{\"64\":1}}],[\"相关信息的\",{\"1\":{\"64\":1}}],[\"相同点\",{\"1\":{\"216\":1}}],[\"相同参数的请求总是发到同一个服务提供者\",{\"1\":{\"216\":1}}],[\"相同参数的请求总是发到同一提供者\",{\"1\":{\"64\":1}}],[\"相同情况下使用\",{\"1\":{\"94\":1}}],[\"相同活跃数的随机\",{\"1\":{\"64\":1}}],[\"相对而言没有使用太多的操作系统资源\",{\"1\":{\"216\":1}}],[\"相对于\",{\"1\":{\"79\":1}}],[\"相对于下面说的运行时增强\",{\"1\":{\"64\":1}}],[\"相对对称加密速度较慢\",{\"1\":{\"35\":1}}],[\"相对来说\",{\"1\":{\"32\":1}}],[\"相反\",{\"1\":{\"26\":1}}],[\"相互连接起来的\",{\"1\":{\"10\":1}}],[\"以前台的方式启动\",{\"1\":{\"254\":1}}],[\"以前文下载的nginx镜像为例\",{\"1\":{\"218\":1}}],[\"以tulingmall\",{\"1\":{\"219\":2}}],[\"以threadlocal自身作为key\",{\"1\":{\"64\":1}}],[\"以单一节点模式启动\",{\"1\":{\"219\":1}}],[\"以百分比的形式显示内存使用情况\",{\"1\":{\"218\":1}}],[\"以短格式显示容器的\",{\"1\":{\"218\":1}}],[\"以overlay2举例说明\",{\"1\":{\"218\":1}}],[\"以项目05\",{\"1\":{\"218\":1}}],[\"以一个update语句为例\",{\"1\":{\"216\":1}}],[\"以服务\",{\"1\":{\"216\":1}}],[\"以\",{\"1\":{\"216\":7}}],[\"以上列表含义如下\",{\"1\":{\"217\":1}}],[\"以上列表包含五列\",{\"1\":{\"217\":1}}],[\"以上的代码量\",{\"1\":{\"216\":1}}],[\"以上两种模式的混合使用\",{\"1\":{\"64\":1}}],[\"以为我们只是写了类而已\",{\"1\":{\"216\":1}}],[\"以减少搜索时间\",{\"1\":{\"73\":1,\"78\":1,\"90\":1}}],[\"以减少网络拥塞的发生\",{\"1\":{\"26\":1}}],[\"以后的\",{\"1\":{\"73\":1}}],[\"以键值对存储\",{\"1\":{\"64\":1}}],[\"以查看您的最后一次写入是否成功\",{\"1\":{\"64\":1}}],[\"以对长网络延迟进行摊销\",{\"1\":{\"64\":1}}],[\"以防止数据丢失\",{\"1\":{\"64\":1}}],[\"以支持更大的数据\",{\"1\":{\"64\":1}}],[\"以支持快速的增删改查\",{\"1\":{\"64\":1}}],[\"以继承的方式完成代理\",{\"1\":{\"64\":1}}],[\"以达到目标系统规定的最低相应时间或者收集频率等\",{\"1\":{\"64\":1}}],[\"以满足此值\",{\"1\":{\"64\":1}}],[\"以非事务方式运行\",{\"1\":{\"64\":2}}],[\"以及容器\",{\"1\":{\"219\":1}}],[\"以及将compose作为容器安装等等\",{\"1\":{\"219\":1}}],[\"以及给对象内的属性赋值\",{\"1\":{\"216\":1}}],[\"以及定义哪些属性需要spring来赋值\",{\"1\":{\"216\":1}}],[\"以及spring\",{\"1\":{\"216\":1}}],[\"以及socket\",{\"0\":{\"110\":1}}],[\"以及deferredimportselector\",{\"1\":{\"216\":1}}],[\"以及是如果解决脑裂问题的\",{\"1\":{\"216\":1}}],[\"以及事务会问你事务除了acid外\",{\"0\":{\"137\":1}}],[\"以及内部的一些东西\",{\"0\":{\"109\":1}}],[\"以及相同integer\",{\"0\":{\"96\":1}}],[\"以及各自的特点\",{\"1\":{\"64\":1}}],[\"以及原理\",{\"1\":{\"64\":1}}],[\"以及分表后如果想按条件分页查询怎么办\",{\"1\":{\"64\":1}}],[\"以及nio的实现原理\",{\"1\":{\"64\":1}}],[\"以及长连接\",{\"1\":{\"64\":1}}],[\"以及这些jar包的用途\",{\"1\":{\"64\":1}}],[\"以及一些正在执行类加载的自定义的类加载器\",{\"1\":{\"64\":1}}],[\"以及饿汉中的延迟加载\",{\"1\":{\"64\":1}}],[\"以及reentrantlock\",{\"1\":{\"64\":1}}],[\"以及user\",{\"1\":{\"64\":1}}],[\"以及\",{\"0\":{\"99\":1,\"113\":1},\"1\":{\"64\":1}}],[\"以及与降低网络传输性能有关的所有因素\",{\"1\":{\"26\":1}}],[\"以便使接收端来得及接收\",{\"1\":{\"26\":1}}],[\"以避免继续在网络中传送下去白白浪费网络资源\",{\"1\":{\"11\":1}}],[\"若它们的内容相等\",{\"1\":{\"96\":1}}],[\"若遇到哈希冲突\",{\"1\":{\"77\":1}}],[\"若有多个线程同时执行写操作\",{\"1\":{\"64\":1}}],[\"若每个线程中对全局变量\",{\"1\":{\"64\":1}}],[\"若该同步锁被别的线程占用\",{\"1\":{\"64\":1}}],[\"若消费不过来\",{\"1\":{\"64\":1}}],[\"若某个事物对某一行加上了排他锁\",{\"1\":{\"64\":1}}],[\"若对网络中某一资源的需求超过了该资源所能提供的可用部分\",{\"1\":{\"26\":1}}],[\"若接收方收到重复分组\",{\"1\":{\"23\":1}}],[\"61\",{\"1\":{\"219\":4}}],[\"65\",{\"1\":{\"219\":15}}],[\"6379\",{\"1\":{\"219\":3}}],[\"6broker要等待消费者真正确认消费到了消息时才删除掉消息\",{\"1\":{\"216\":1}}],[\"6644f\",{\"1\":{\"216\":2}}],[\"6如果事务回滚\",{\"1\":{\"216\":1}}],[\"6主节点rdb文件发送完毕后\",{\"1\":{\"216\":1}}],[\"6高效并发编程的体现\",{\"1\":{\"216\":1}}],[\"6kong\",{\"1\":{\"216\":1}}],[\"6follower节点收到日志后会进行持久化\",{\"1\":{\"216\":1}}],[\"6当然一个节点将一张选票放入到自己的投票箱之后\",{\"1\":{\"216\":1}}],[\"6jar包外部的application\",{\"1\":{\"216\":1}}],[\"6controller\",{\"1\":{\"216\":1}}],[\"6spring启动结束\",{\"1\":{\"216\":1}}],[\"6sychronized底层有一个锁升级的过程\",{\"1\":{\"216\":1}}],[\"6然后执行当前方法\",{\"1\":{\"216\":1}}],[\"6初始化\",{\"1\":{\"216\":1}}],[\"6tomcat接收到请求数据后\",{\"1\":{\"216\":1}}],[\"6同时\",{\"1\":{\"216\":1}}],[\"6在转移元素时\",{\"1\":{\"216\":1}}],[\"6确定好数据格式和网络传输方式之后\",{\"1\":{\"216\":1}}],[\"62d399e71e08530a89222b23\",{\"1\":{\"216\":1}}],[\"675\",{\"1\":{\"94\":1}}],[\"6782\",{\"1\":{\"64\":1}}],[\"6842045\",{\"1\":{\"81\":1}}],[\"6以后\",{\"1\":{\"81\":1}}],[\"6之前为循环链表\",{\"1\":{\"68\":1,\"89\":1}}],[\"64\",{\"1\":{\"64\":4,\"217\":1}}],[\"60000\",{\"1\":{\"219\":1}}],[\"60l\",{\"1\":{\"64\":1}}],[\"60965466\",{\"1\":{\"37\":1}}],[\"6及之前\",{\"1\":{\"64\":1}}],[\"69779824\",{\"1\":{\"64\":1}}],[\"6\",{\"0\":{\"26\":1,\"74\":1,\"99\":1,\"157\":1,\"181\":1,\"197\":1,\"214\":1},\"1\":{\"57\":1,\"64\":8,\"216\":5,\"217\":2,\"219\":4,\"231\":1}}],[\"滑动窗口和流量控制\",{\"0\":{\"25\":1}}],[\"5生产者发送消息时\",{\"1\":{\"216\":1}}],[\"5检查数据库实例所在机器的性能配置\",{\"1\":{\"216\":1}}],[\"5从节点收到rdb文件后丢弃所有旧数据\",{\"1\":{\"216\":1}}],[\"5有序集合\",{\"1\":{\"216\":1}}],[\"5高性能序列化协议\",{\"1\":{\"216\":1}}],[\"5feign\",{\"1\":{\"216\":1}}],[\"5serialize数据序列化层\",{\"1\":{\"216\":1}}],[\"5sychronized锁的是对象\",{\"1\":{\"216\":1}}],[\"5还会根据服务协议启动对应的web服务器或网络框架\",{\"1\":{\"216\":1}}],[\"5leader节点会将该写请求对应的日志发送给其他follower节点\",{\"1\":{\"216\":1}}],[\"5如果事务提交\",{\"1\":{\"216\":1}}],[\"5如果pk赢了\",{\"1\":{\"216\":1}}],[\"5如何直接通过socket来发\",{\"1\":{\"216\":1}}],[\"5提供映射标签\",{\"1\":{\"216\":1}}],[\"5jar包内部的application\",{\"1\":{\"216\":1}}],[\"5handleradapter\",{\"1\":{\"216\":1}}],[\"5单例bean创建完了之后\",{\"1\":{\"216\":1}}],[\"5并且修改数据库连接的autocommit属性为false\",{\"1\":{\"216\":1}}],[\"5初始化前\",{\"1\":{\"216\":1}}],[\"5b\",{\"1\":{\"216\":1}}],[\"5b5d1a9af265da0f47352f14\",{\"1\":{\"70\":1}}],[\"5服务器收到请求后\",{\"1\":{\"216\":1}}],[\"5首先\",{\"1\":{\"216\":1}}],[\"5当线程池中的线程数量大于\",{\"1\":{\"216\":1}}],[\"5扩容之前也先生成一个新的数组\",{\"1\":{\"216\":1}}],[\"5扩容的判断也是每个segment内部单独判断的\",{\"1\":{\"216\":1}}],[\"5所有元素转移完了之后\",{\"1\":{\"216\":2}}],[\"5terminated\",{\"1\":{\"216\":2}}],[\"5的这行记录不存在了\",{\"1\":{\"216\":1}}],[\"5了\",{\"1\":{\"216\":1}}],[\"5这行数据不存在\",{\"1\":{\"216\":1}}],[\"5这行数据\",{\"1\":{\"216\":1}}],[\"57\",{\"0\":{\"150\":1}}],[\"573\",{\"1\":{\"64\":1}}],[\"5601\",{\"1\":{\"219\":2}}],[\"5672\",{\"1\":{\"219\":2}}],[\"56\",{\"0\":{\"149\":1}}],[\"55\",{\"0\":{\"148\":1}}],[\"54\",{\"0\":{\"147\":1}}],[\"53\",{\"0\":{\"146\":1}}],[\"5ec0ff4a6fb9a043271c76e9\",{\"1\":{\"92\":1}}],[\"5235e\",{\"1\":{\"216\":2}}],[\"52\",{\"0\":{\"145\":1}}],[\"527\",{\"1\":{\"64\":1}}],[\"52718250\",{\"1\":{\"37\":1}}],[\"52403472\",{\"1\":{\"64\":1}}],[\"51\",{\"0\":{\"144\":1}}],[\"51960143\",{\"1\":{\"64\":1}}],[\"51cto\",{\"1\":{\"64\":1}}],[\"5种\",{\"1\":{\"64\":1}}],[\"5010\",{\"1\":{\"219\":2}}],[\"50\",{\"0\":{\"143\":1},\"1\":{\"216\":1,\"219\":1}}],[\"50208839\",{\"1\":{\"64\":1}}],[\"5000ms\",{\"1\":{\"219\":1}}],[\"5000\",{\"1\":{\"219\":4}}],[\"500m\",{\"1\":{\"218\":1}}],[\"500\",{\"1\":{\"54\":1}}],[\"5比spring4做了哪些改进\",{\"1\":{\"64\":2}}],[\"5xx\",{\"1\":{\"54\":1}}],[\"5\",{\"0\":{\"25\":1,\"63\":1,\"73\":1,\"98\":1,\"156\":1,\"165\":1,\"180\":1,\"196\":1,\"213\":1},\"1\":{\"64\":11,\"68\":1,\"86\":5,\"87\":2,\"216\":5,\"217\":2,\"218\":1,\"219\":6,\"231\":1}}],[\"5条\",{\"1\":{\"24\":1}}],[\"接下来我们用docker\",{\"1\":{\"219\":1}}],[\"接下来来说说我的理解\",{\"1\":{\"216\":1}}],[\"接口级注册的缺点在于\",{\"1\":{\"216\":1}}],[\"接口级注册的好处在于\",{\"1\":{\"216\":1}}],[\"接口2\",{\"1\":{\"216\":1}}],[\"接口1\",{\"1\":{\"216\":1}}],[\"接口的list\",{\"1\":{\"69\":1}}],[\"接口才具有快速随机访问功能的\",{\"1\":{\"69\":1}}],[\"接口只是标识\",{\"1\":{\"69\":1}}],[\"接口不过是一个标识罢了\",{\"1\":{\"69\":1}}],[\"接口中什么都没有定义\",{\"1\":{\"69\":1}}],[\"接口和方法\",{\"1\":{\"64\":1}}],[\"接口\",{\"1\":{\"64\":3,\"69\":2}}],[\"接口最流行的几个实现类是\",{\"1\":{\"64\":2}}],[\"接受\",{\"1\":{\"54\":1}}],[\"接着发送其他数据\",{\"1\":{\"23\":1}}],[\"接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小\",{\"1\":{\"25\":1}}],[\"接收方一般采用累计确认\",{\"1\":{\"24\":1}}],[\"接收方一般采用累积确认\",{\"1\":{\"23\":1}}],[\"接收方在规定时间内收到\",{\"1\":{\"23\":1}}],[\"接收方对数据包进行排序\",{\"1\":{\"21\":1}}],[\"接收站发给发送站的一种传输控制字符\",{\"1\":{\"17\":1}}],[\"接收端传回发送端所发送的\",{\"1\":{\"17\":1}}],[\"接收正常\",{\"1\":{\"16\":6}}],[\"表名\",{\"1\":{\"216\":1}}],[\"表面上看\",{\"1\":{\"216\":1}}],[\"表单数据验证以及一些外部配置这样的一些第三方功能\",{\"1\":{\"64\":1}}],[\"表级锁\",{\"1\":{\"64\":3}}],[\"表锁等都是悲观锁\",{\"1\":{\"216\":1}}],[\"表锁\",{\"1\":{\"64\":4}}],[\"表示两个文件内容一致\",{\"1\":{\"231\":1}}],[\"表示排除忽略\",{\"1\":{\"231\":1}}],[\"表示链接到docker\",{\"1\":{\"219\":1}}],[\"表示只是在需要写时才去复制\",{\"1\":{\"218\":1}}],[\"表示dockerfile文件所在路径\",{\"1\":{\"218\":1}}],[\"表示启动容器时运行的命令\",{\"1\":{\"217\":1}}],[\"表示启动类也是一个配置类\",{\"1\":{\"216\":1}}],[\"表示镜像名称\",{\"1\":{\"217\":1}}],[\"表示镜像唯一标识\",{\"1\":{\"217\":1}}],[\"表示容器名称\",{\"1\":{\"217\":1}}],[\"表示容器对外的端口号\",{\"1\":{\"217\":1}}],[\"表示容器运行的状态\",{\"1\":{\"217\":1}}],[\"表示容器的创建时间\",{\"1\":{\"217\":1}}],[\"表示容器\",{\"1\":{\"217\":1}}],[\"表示连接到默认的网桥\",{\"1\":{\"217\":1}}],[\"表示后台运行\",{\"1\":{\"217\":1}}],[\"表示最新\",{\"1\":{\"217\":1}}],[\"表示最终一致性\",{\"1\":{\"216\":1}}],[\"表示是否是自动构建的镜像仓库\",{\"1\":{\"217\":1}}],[\"表示是否为官方仓库\",{\"1\":{\"217\":1}}],[\"表示该镜像仓库的受欢迎程度\",{\"1\":{\"217\":1}}],[\"表示客户端也会断开连接了\",{\"1\":{\"216\":1}}],[\"表示服务端现在可以断开连接\",{\"1\":{\"216\":1}}],[\"表示服务器上的某个资源被永久性的删除\",{\"1\":{\"33\":1}}],[\"表示我接收到了断开连接的请求\",{\"1\":{\"216\":1}}],[\"表示远程过程调用\",{\"1\":{\"216\":1}}],[\"表示分布式系统可以处于一种中间状态\",{\"1\":{\"216\":1}}],[\"表示分区容错性\",{\"1\":{\"216\":1}}],[\"表示可以允许一定程度的不可用\",{\"1\":{\"216\":1}}],[\"表示可用性\",{\"1\":{\"216\":1}}],[\"表示基本可用\",{\"1\":{\"216\":1}}],[\"表示基于\",{\"0\":{\"177\":1}}],[\"表示强一致性\",{\"1\":{\"216\":1}}],[\"表示如果用spring\",{\"1\":{\"216\":1}}],[\"表示一种对象控制权的转移\",{\"1\":{\"216\":1}}],[\"表示同时允许最多多少个线程使用该信号量\",{\"1\":{\"216\":1}}],[\"表示阻塞加锁\",{\"1\":{\"216\":1}}],[\"表示尝试加锁\",{\"1\":{\"216\":1}}],[\"表示bean工厂\",{\"1\":{\"216\":1}}],[\"表示b\",{\"1\":{\"216\":2}}],[\"表示开启事务\",{\"1\":{\"64\":1}}],[\"表示自动提交\",{\"1\":{\"64\":1}}],[\"表示请求已被成功接收\",{\"1\":{\"54\":1}}],[\"表示请求已接收\",{\"1\":{\"54\":1}}],[\"表示请求的资源与资源的当前状态发生冲突\",{\"1\":{\"33\":1}}],[\"表示需要退回来重传已经发送过的\",{\"1\":{\"24\":1}}],[\"表示经实际电路传送后的比特流没有发生变化\",{\"1\":{\"12\":1}}],[\"表明到这个分组为止的所有分组都已经正确收到了\",{\"1\":{\"24\":1}}],[\"表明到这个分组位置的所有分组都已经正确收到了\",{\"1\":{\"23\":1}}],[\"连续arq协议\",{\"0\":{\"24\":1}}],[\"连续\",{\"1\":{\"23\":1,\"24\":1}}],[\"连接池初始化大小\",{\"1\":{\"219\":1}}],[\"连接超时时间\",{\"1\":{\"219\":1}}],[\"连接这方面的\",{\"0\":{\"124\":1}}],[\"连接异常断开的处理\",{\"1\":{\"64\":1}}],[\"连接集群中任何一个可用节点即可\",{\"1\":{\"64\":1}}],[\"连接进行处理\",{\"1\":{\"53\":1}}],[\"连接建立的时间\",{\"1\":{\"51\":1}}],[\"连接\",{\"0\":{\"46\":1},\"1\":{\"39\":1,\"51\":1}}],[\"连接结束\",{\"1\":{\"27\":1,\"39\":1}}],[\"连接的每一方都有固定大小的缓冲空间\",{\"1\":{\"21\":1}}],[\"连接则需要\",{\"1\":{\"18\":1}}],[\"认为自己比较适合作为leader\",{\"1\":{\"216\":1}}],[\"认为这两个对象相等\",{\"1\":{\"96\":1}}],[\"认为刚才发送过的分组丢失了\",{\"1\":{\"23\":1}}],[\"认为最适合发送的数据块\",{\"1\":{\"21\":1}}],[\"并打好jar包放入上面对应的文件夹\",{\"1\":{\"219\":1}}],[\"并选择特定版本安装\",{\"1\":{\"217\":1}}],[\"并更新\",{\"1\":{\"217\":1}}],[\"并与\",{\"1\":{\"217\":1}}],[\"并可以缩短从编写到部署运行代码的周期\",{\"1\":{\"217\":1}}],[\"并存入logbuffer中\",{\"1\":{\"216\":1}}],[\"并存在消费端的服务目录中\",{\"1\":{\"216\":1}}],[\"并存在一个map中\",{\"1\":{\"216\":1}}],[\"并执行来自主节点缓冲区replication\",{\"1\":{\"216\":1}}],[\"并执行该方法得到结果\",{\"1\":{\"216\":1}}],[\"并使用缓冲区replication\",{\"1\":{\"216\":1}}],[\"并处理http请求\",{\"1\":{\"216\":1}}],[\"并处理请求直到线程数目达到\",{\"1\":{\"64\":1}}],[\"并处理请求\",{\"1\":{\"64\":1}}],[\"并桥接注册中心\",{\"1\":{\"216\":1}}],[\"并放入spring容器中作为bean\",{\"1\":{\"216\":1}}],[\"并支持按权重进行轮询\",{\"1\":{\"216\":1}}],[\"并支持按权重设置随机概率\",{\"1\":{\"216\":1}}],[\"并等待follower节点持久化日志成功\",{\"1\":{\"216\":1}}],[\"并绑定端口等\",{\"1\":{\"216\":1}}],[\"并创建tomcat对象\",{\"1\":{\"216\":1}}],[\"并通过执行方法得到bean对象\",{\"1\":{\"216\":1}}],[\"并通过aqs来排队\",{\"1\":{\"216\":1}}],[\"并再次通过网络发送给浏览器所在的服务器\",{\"1\":{\"216\":1}}],[\"并添加到新数组中去\",{\"1\":{\"216\":1}}],[\"并基于新数组长度\",{\"1\":{\"216\":1}}],[\"并缓存在cache数组中\",{\"1\":{\"216\":1}}],[\"并返回该字符串常量的引用\",{\"1\":{\"216\":1}}],[\"并设置超时时间来获取阻塞队列中的任务\",{\"1\":{\"216\":1}}],[\"并集\",{\"1\":{\"171\":1,\"216\":1}}],[\"并没有对方法进行加同步锁\",{\"1\":{\"94\":1}}],[\"并在发送缓冲区replication\",{\"1\":{\"216\":1}}],[\"并在用户中进行反复制\",{\"1\":{\"64\":1}}],[\"并在内核用户之间调用内核\",{\"1\":{\"64\":1}}],[\"并在集群中进行复制\",{\"1\":{\"64\":1}}],[\"并对其中的一种的使用举一个例子\",{\"1\":{\"64\":1}}],[\"并行收集器会自动选择年轻代区大小和相应的survivor区比例\",{\"1\":{\"64\":1}}],[\"并行收集器主要以到达一定的吞吐量为目标\",{\"1\":{\"64\":1}}],[\"并行收集器\",{\"1\":{\"64\":1}}],[\"并行\",{\"1\":{\"64\":1}}],[\"并发度低\",{\"1\":{\"216\":1}}],[\"并发度高\",{\"1\":{\"216\":1}}],[\"并发程度不够\",{\"1\":{\"216\":1}}],[\"并发量大的时候\",{\"1\":{\"216\":1}}],[\"并发控制使用\",{\"1\":{\"81\":1}}],[\"并发环境下推荐使用\",{\"1\":{\"80\":1}}],[\"并发下的rehash\",{\"1\":{\"80\":1}}],[\"并发的安全\",{\"1\":{\"64\":1}}],[\"并发收集器主要是保证系统的响应时间\",{\"1\":{\"64\":1}}],[\"并发收集器\",{\"1\":{\"64\":1}}],[\"并发工具类\",{\"1\":{\"64\":2}}],[\"并发\",{\"1\":{\"64\":2}}],[\"并发同步阻塞队列\",{\"1\":{\"64\":1}}],[\"并发问题还是存在的\",{\"1\":{\"64\":1}}],[\"并将该页缓存在buffer\",{\"1\":{\"216\":1}}],[\"并将新的选票发送给其他节点\",{\"1\":{\"216\":1}}],[\"并将选票放入自己的投票箱中\",{\"1\":{\"216\":1}}],[\"并将链表的头节点添加到新数组的对应位置\",{\"1\":{\"216\":1}}],[\"并将根节点的添加到新数组的对应位置\",{\"1\":{\"216\":1}}],[\"并将这类方法关联到和熔断器连在一起的代理上\",{\"1\":{\"64\":1}}],[\"并将多个xml\",{\"1\":{\"64\":1}}],[\"并将确认序号设置为收到序号加1\",{\"1\":{\"18\":1}}],[\"并不需要jdk\",{\"1\":{\"231\":1}}],[\"并不会因为这个容器分配一些磁盘空间\",{\"1\":{\"218\":1}}],[\"并不会修改image的源文件\",{\"1\":{\"218\":1}}],[\"并不会真正的去锁某行记录\",{\"1\":{\"216\":1}}],[\"并不会阻塞线程\",{\"1\":{\"216\":1}}],[\"并不会影响\",{\"1\":{\"57\":1}}],[\"并不是说\",{\"1\":{\"69\":1}}],[\"并不是我多打了一个\",{\"1\":{\"42\":1}}],[\"并不能解决共享变量的并发问题\",{\"1\":{\"64\":1}}],[\"并按照报文格式进一步封装成\",{\"1\":{\"53\":1}}],[\"并立即重传这些丢失的数据段\",{\"1\":{\"26\":1}}],[\"并且不希望用户在执行docker\",{\"1\":{\"231\":1}}],[\"并且不支持断点续传功能\",{\"1\":{\"33\":1}}],[\"并且下一条命令使用了相同的指令\",{\"1\":{\"231\":1}}],[\"并且方便扩展和使用\",{\"1\":{\"231\":1}}],[\"并且能将基础设施当作程序一样进行管理\",{\"1\":{\"217\":1}}],[\"并且叶子节点之间有指针\",{\"1\":{\"216\":1}}],[\"并且排好顺序\",{\"1\":{\"216\":1}}],[\"并且此sql所要查询的字段在当前索引对应的字段中都包含了\",{\"1\":{\"216\":1}}],[\"并且编码简单\",{\"1\":{\"216\":1}}],[\"并且当有数据可读时会通知给线程\",{\"1\":{\"216\":1}}],[\"并且需要处理完一个socket之后才能处理下一个socket\",{\"1\":{\"216\":1}}],[\"并且需要线程主动去查询是否有数据可读\",{\"1\":{\"216\":1}}],[\"并且每层都是可以扩展的\",{\"1\":{\"216\":1}}],[\"并且每个客户端并不会频繁地发送太多数据\",{\"1\":{\"64\":1}}],[\"并且zookeeper底层采用了nio\",{\"1\":{\"216\":1}}],[\"并且这个异常是需要回滚的就会回滚事务\",{\"1\":{\"216\":1}}],[\"并且相应的属性都需要有值\",{\"1\":{\"216\":1}}],[\"并且相互独立的话\",{\"1\":{\"216\":1}}],[\"并且还可以调整io模型\",{\"1\":{\"216\":1}}],[\"并且各个应用中的类是独立的\",{\"1\":{\"216\":1}}],[\"并且线程池中的数量等于maximumpoolsize\",{\"1\":{\"216\":1}}],[\"并且线程池中的数量小于maximumpoolsize\",{\"1\":{\"216\":1}}],[\"并且会调用terminated\",{\"1\":{\"216\":1}}],[\"并且正在运行的线程也会被中断\",{\"1\":{\"216\":1}}],[\"并且存在一个static块\",{\"1\":{\"216\":1}}],[\"并且也不会处理阻塞队列中的任务\",{\"1\":{\"216\":1}}],[\"并且没有业务执行\",{\"1\":{\"216\":1}}],[\"并且是升序的\",{\"1\":{\"216\":1}}],[\"并且固定是升序索引\",{\"1\":{\"216\":1}}],[\"并且set提供了判断某个成员是否在一个set集合内的重要接口\",{\"1\":{\"171\":1}}],[\"并且其内部是通过\",{\"1\":{\"89\":1}}],[\"并且\",{\"1\":{\"79\":1}}],[\"并且可以支持源文件为\",{\"1\":{\"231\":1}}],[\"并且可以在机器错误\",{\"1\":{\"64\":1}}],[\"并且可以保证系统不会因为图片问题而崩溃\",{\"1\":{\"64\":1}}],[\"并且允许重复\",{\"1\":{\"64\":1}}],[\"并且动态变化\",{\"1\":{\"26\":1}}],[\"并且回复确认\",{\"1\":{\"23\":1}}],[\"无论使用cmd还是entrypoint\",{\"1\":{\"231\":1}}],[\"无论在哪里运行\",{\"1\":{\"231\":1}}],[\"无论是否有slave集群进入fail状态\",{\"1\":{\"64\":1}}],[\"无论是哪一层的数据单元\",{\"1\":{\"10\":1}}],[\"无序\",{\"1\":{\"89\":1}}],[\"无序容器\",{\"1\":{\"64\":1}}],[\"无符号右移\",{\"1\":{\"77\":1}}],[\"无解\",{\"1\":{\"64\":1}}],[\"无差别随机删\",{\"1\":{\"64\":1}}],[\"无差错情况\",{\"1\":{\"23\":1}}],[\"无法同时保证cap\",{\"1\":{\"216\":1}}],[\"无法获取响应\",{\"1\":{\"64\":1}}],[\"无法全部手动去挨个实现\",{\"1\":{\"64\":1}}],[\"无法做到线程安全\",{\"1\":{\"64\":1}}],[\"无法发挥多核cpu性能\",{\"1\":{\"64\":1}}],[\"无法对这些代码进行优化\",{\"1\":{\"64\":1}}],[\"无需再像spring那样搞一堆繁琐的xml文件的配置\",{\"1\":{\"64\":1}}],[\"无永久代\",{\"1\":{\"64\":1}}],[\"无同步方案\",{\"1\":{\"64\":1}}],[\"信任的证书的客户端的链接\",{\"1\":{\"225\":1}}],[\"信息交换层\",{\"1\":{\"216\":2}}],[\"信息发布系统可以实现最简单的信息录入自动生成静态页面\",{\"1\":{\"64\":1}}],[\"信息缓存等\",{\"1\":{\"64\":1}}],[\"信息加密然后使用到的时候再去服务器端解密\",{\"1\":{\"32\":1}}],[\"信号\",{\"1\":{\"64\":1}}],[\"信号量实现优雅终止十分重要\",{\"1\":{\"237\":1}}],[\"信号量\",{\"1\":{\"64\":3}}],[\"信号来进行验证\",{\"1\":{\"18\":1}}],[\"信道利用率高\",{\"1\":{\"24\":1}}],[\"信道利用率低\",{\"1\":{\"23\":1}}],[\"缺省是5秒内20次调用失败\",{\"1\":{\"64\":1}}],[\"缺省用\",{\"1\":{\"64\":1}}],[\"缺省只对第一个参数\",{\"1\":{\"64\":1}}],[\"缺点是会产生大量的日志\",{\"1\":{\"64\":1}}],[\"缺点是在某些情况下会导致master\",{\"1\":{\"64\":1}}],[\"缺点\",{\"1\":{\"23\":1,\"24\":1,\"64\":1,\"216\":1}}],[\"缺一不可\",{\"1\":{\"16\":1}}],[\"就算加上\",{\"1\":{\"219\":1}}],[\"就要用这个命令进入容器\",{\"1\":{\"217\":1}}],[\"就要考虑两个方面\",{\"1\":{\"216\":1}}],[\"就要考虑这些存活时间不长的对象是不是比较大\",{\"1\":{\"216\":1}}],[\"就要考虑是否支持异步\",{\"1\":{\"216\":1}}],[\"就要考虑序列化和反序列化\",{\"1\":{\"216\":1}}],[\"就需要手动复制\",{\"1\":{\"217\":1}}],[\"就需要在消费端做控制\",{\"1\":{\"216\":1}}],[\"就需要利用锁来解决幻读\",{\"1\":{\"216\":1}}],[\"就需要用到分布式事务\",{\"1\":{\"216\":1}}],[\"就一定要提供该索引所对应的字段中最左边的字段\",{\"1\":{\"216\":1}}],[\"就很有可能出现订单创建成功\",{\"1\":{\"216\":1}}],[\"就涉及到订单系统创建订单\",{\"1\":{\"216\":1}}],[\"就可在当前宿主机上运行\",{\"1\":{\"217\":1}}],[\"就可以在容器的\",{\"1\":{\"217\":1}}],[\"就可以给broker发送一个ack\",{\"1\":{\"216\":1}}],[\"就可以继续做其他事情了\",{\"1\":{\"216\":1}}],[\"就可以完成非透明的\",{\"1\":{\"216\":1}}],[\"就可以直接从注册中心根据接口名找到接口所在的地址\",{\"1\":{\"216\":1}}],[\"就可从中提出数据部分\",{\"1\":{\"11\":1}}],[\"就没有线程能处理它了\",{\"1\":{\"216\":1}}],[\"就没有必要子classloader再加载一次\",{\"1\":{\"64\":1}}],[\"就开一个窗口就好了\",{\"1\":{\"216\":1}}],[\"就像上面创建索引一样\",{\"1\":{\"216\":1}}],[\"就选择实现collection接口的集合\",{\"1\":{\"91\":1}}],[\"就判断该元素与要存入的元素的\",{\"1\":{\"77\":1}}],[\"就表明了他具有快速随机访问功能\",{\"1\":{\"69\":1}}],[\"就绪状态的线程获取了cpu\",{\"1\":{\"64\":1}}],[\"就绪状态\",{\"1\":{\"64\":1}}],[\"就会开始提交\",{\"1\":{\"216\":1}}],[\"就会开始去阻塞队列中获取任务\",{\"1\":{\"216\":1}}],[\"就会从投票箱中统计票数\",{\"1\":{\"216\":1}}],[\"就会有可能会出现id冲突\",{\"1\":{\"216\":1}}],[\"就会有这个从节点选取一个来充当主节点\",{\"1\":{\"64\":1}}],[\"就会获取启动tomcat的bean\",{\"1\":{\"216\":1}}],[\"就会进入tidying\",{\"1\":{\"216\":1}}],[\"就会违反上面的两个条件\",{\"1\":{\"64\":1}}],[\"就会启动熔断机制\",{\"1\":{\"64\":1}}],[\"就会销毁这个session\",{\"1\":{\"31\":1}}],[\"就新建一个\",{\"1\":{\"64\":1}}],[\"就成功返回\",{\"1\":{\"64\":1}}],[\"就依赖于线程池的实现\",{\"1\":{\"64\":1}}],[\"就是让\",{\"1\":{\"254\":1}}],[\"就是把$\",{\"1\":{\"216\":1}}],[\"就是它只会引用其他对象\",{\"1\":{\"216\":1}}],[\"就是它们有一个大脑\",{\"1\":{\"216\":1}}],[\"就是为了防止脑裂\",{\"1\":{\"216\":1}}],[\"就是对这个表中的数据进行排序\",{\"1\":{\"216\":1}}],[\"就是从某个元素开始读取多少个元素\",{\"1\":{\"170\":1}}],[\"就是链表\",{\"1\":{\"170\":1}}],[\"就是\",{\"1\":{\"77\":1,\"216\":1}}],[\"就是代理java类\",{\"1\":{\"64\":1}}],[\"就是运行逻辑\",{\"1\":{\"64\":1}}],[\"就是线程安全的\",{\"1\":{\"64\":1}}],[\"就是线程同步的意思\",{\"1\":{\"64\":1}}],[\"就是当一个程序对一个线程安全的方法或者语句进行访问的时候\",{\"1\":{\"64\":1}}],[\"就是给某一行加上锁\",{\"1\":{\"64\":1}}],[\"就是利用\",{\"1\":{\"45\":1}}],[\"就是网络能够承受现有的网络负荷\",{\"1\":{\"26\":1}}],[\"就建立一次连接\",{\"1\":{\"30\":1}}],[\"就不会产生并发\",{\"1\":{\"84\":1}}],[\"就不会存在锁竞争\",{\"1\":{\"81\":1}}],[\"就不会因为重传时要求的暂停被耽误\",{\"1\":{\"26\":1}}],[\"就不使用事务\",{\"1\":{\"64\":1}}],[\"就不再发送\",{\"1\":{\"23\":1}}],[\"就证明b的确认消息丢失\",{\"1\":{\"23\":1}}],[\"就重传前面发送过的分组\",{\"1\":{\"23\":1}}],[\"就丢弃该分组\",{\"1\":{\"23\":2}}],[\"直到服务b恢复\",{\"1\":{\"216\":1}}],[\"直到没有空闲许可\",{\"1\":{\"216\":1}}],[\"直到出现真正的故障\",{\"1\":{\"64\":1}}],[\"直到线程进入就绪状态\",{\"1\":{\"64\":1}}],[\"直到内存溢出\",{\"1\":{\"64\":1}}],[\"直到父亲说这件事我也干不了时\",{\"1\":{\"64\":1}}],[\"直到最后本地域名服务器得到\",{\"1\":{\"42\":1}}],[\"直到收到确认后再发下一个分组\",{\"1\":{\"23\":1}}],[\"直接多行写就行\",{\"1\":{\"243\":1}}],[\"直接返回一个结果\",{\"1\":{\"216\":1}}],[\"直接进入到了老年代\",{\"1\":{\"216\":1}}],[\"直接覆盖\",{\"1\":{\"77\":1}}],[\"直接抛出\",{\"1\":{\"73\":1}}],[\"直接选择排序\",{\"1\":{\"64\":1}}],[\"直接插入排序\",{\"1\":{\"64\":1}}],[\"直接联系kafka\",{\"1\":{\"64\":1}}],[\"直接在写操作时返回错误\",{\"1\":{\"64\":1}}],[\"直接通过类的方法调用\",{\"1\":{\"64\":1}}],[\"直接附加在url路径的后面\",{\"1\":{\"31\":1}}],[\"直接丢弃\",{\"1\":{\"23\":1}}],[\"直播等等\",{\"1\":{\"20\":1}}],[\"回到tomcat\",{\"1\":{\"216\":1}}],[\"回滚事务\",{\"1\":{\"64\":1}}],[\"回滚结束事务\",{\"1\":{\"64\":1}}],[\"回流\",{\"1\":{\"57\":1}}],[\"回退\",{\"1\":{\"24\":1}}],[\"回复ack\",{\"1\":{\"23\":1}}],[\"回答为什么要用什么方法这种问题的时候\",{\"1\":{\"64\":1}}],[\"回答\",{\"1\":{\"19\":1}}],[\"4客户端收到服务端的fin\",{\"1\":{\"216\":1}}],[\"4消息不能少\",{\"1\":{\"216\":1}}],[\"4检查表中数据是否过多\",{\"1\":{\"216\":1}}],[\"4针对update语句生成undolog日志\",{\"1\":{\"216\":1}}],[\"4主节点bgsave命令执行完后\",{\"1\":{\"216\":1}}],[\"4同时还要考虑到redis节点挂掉后的情况\",{\"1\":{\"216\":1}}],[\"4集合\",{\"1\":{\"216\":1}}],[\"4串行化处理读写\",{\"1\":{\"216\":1}}],[\"4易用性\",{\"1\":{\"216\":1}}],[\"4spring\",{\"1\":{\"216\":1}}],[\"4sychronized是非公平锁\",{\"1\":{\"216\":1}}],[\"4然后根据查询得到的服务提供者信息生成一个服务接口的代理对象\",{\"1\":{\"216\":1}}],[\"4然后再进行详细的分析和调试\",{\"1\":{\"216\":1}}],[\"4将服务信息注册到注册中心后\",{\"1\":{\"216\":1}}],[\"4将元素添加到新数组中去\",{\"1\":{\"216\":1}}],[\"4一致性哈希\",{\"1\":{\"216\":1}}],[\"4leader节点收到一个写请求时\",{\"1\":{\"216\":1}}],[\"4雪花算法\",{\"1\":{\"216\":1}}],[\"4使用\",{\"1\":{\"216\":1}}],[\"4能够与\",{\"1\":{\"216\":1}}],[\"4jar包外部的application\",{\"1\":{\"216\":1}}],[\"4dispatcherservlet\",{\"1\":{\"216\":1}}],[\"4利用beandefinition创建bean就是bean的创建生命周期\",{\"1\":{\"216\":1}}],[\"4处理aware回调\",{\"1\":{\"216\":1}}],[\"4a\",{\"1\":{\"216\":1}}],[\"4途中可能会经过各种路由器\",{\"1\":{\"216\":1}}],[\"4通过各个命令的结果\",{\"1\":{\"216\":1}}],[\"4自旋锁\",{\"1\":{\"216\":1}}],[\"4transport网络传输层\",{\"1\":{\"216\":1}}],[\"4threadlocal经典的应用场景就是连接管理\",{\"1\":{\"216\":1}}],[\"4tidying\",{\"1\":{\"216\":2}}],[\"4concurrenthashmap是支持多个线程同时扩容的\",{\"1\":{\"216\":1}}],[\"4copyonwritearraylist允许在写操作时来读取数据\",{\"1\":{\"216\":1}}],[\"4先生成新的数组\",{\"1\":{\"216\":1}}],[\"4如果pk是平局则将接收到的选票放入自己的投票箱中\",{\"1\":{\"216\":1}}],[\"4如果加了\",{\"1\":{\"216\":1}}],[\"4如果此时线程池中的线程数量大于corepoolsize\",{\"1\":{\"216\":1}}],[\"4如果是红黑树\",{\"1\":{\"216\":1}}],[\"4如果利用http来发\",{\"1\":{\"216\":1}}],[\"49100\",{\"1\":{\"219\":1}}],[\"49\",{\"0\":{\"142\":1}}],[\"48\",{\"0\":{\"141\":1},\"1\":{\"219\":1}}],[\"47\",{\"0\":{\"140\":1}}],[\"46\",{\"0\":{\"139\":1}}],[\"4560\",{\"1\":{\"219\":2}}],[\"45\",{\"0\":{\"138\":1}}],[\"44\",{\"0\":{\"137\":1}}],[\"443\",{\"1\":{\"49\":1}}],[\"4311d\",{\"1\":{\"216\":2}}],[\"43\",{\"0\":{\"136\":1}}],[\"41\",{\"0\":{\"134\":1}}],[\"410\",{\"1\":{\"33\":1}}],[\"42\",{\"0\":{\"135\":1},\"1\":{\"96\":2,\"219\":1}}],[\"422\",{\"1\":{\"54\":1}}],[\"4的空间\",{\"1\":{\"64\":1}}],[\"4种\",{\"1\":{\"64\":1}}],[\"4096\",{\"1\":{\"223\":3}}],[\"40\",{\"0\":{\"133\":1}}],[\"404\",{\"1\":{\"54\":1,\"255\":1}}],[\"403\",{\"1\":{\"54\":1}}],[\"401\",{\"1\":{\"54\":1}}],[\"400\",{\"1\":{\"54\":1}}],[\"4xx\",{\"1\":{\"54\":1}}],[\"4zt\",{\"1\":{\"33\":1,\"37\":1}}],[\"4\",{\"0\":{\"22\":1,\"62\":1,\"72\":1,\"97\":1,\"155\":1,\"164\":1,\"179\":1,\"195\":1,\"212\":1},\"1\":{\"64\":21,\"68\":1,\"73\":1,\"77\":2,\"86\":5,\"216\":5,\"217\":3,\"218\":2,\"219\":9,\"231\":11}}],[\"超过了则进行扩容\",{\"1\":{\"216\":1}}],[\"超时时间后\",{\"1\":{\"23\":1}}],[\"超时重传\",{\"1\":{\"21\":1,\"23\":1}}],[\"超文本传输协议\",{\"1\":{\"8\":1}}],[\"使\",{\"1\":{\"225\":1}}],[\"使开发者不必为了追求效果而配置高额的硬件\",{\"1\":{\"217\":1}}],[\"使开发者可以直接将自己的成果放入docker中进行管理\",{\"1\":{\"217\":1}}],[\"使得镜像体积尽可能小呢\",{\"1\":{\"231\":1}}],[\"使得写请求像事务一样在其他节点上执行\",{\"1\":{\"216\":1}}],[\"使得集合中的元素能够按score进行有序排列\",{\"1\":{\"172\":1}}],[\"使得上面的结构可以保持键值对的插入顺序\",{\"1\":{\"90\":1}}],[\"使得运行效率降低\",{\"1\":{\"64\":1}}],[\"使得对待问题的思考方式发生了改变\",{\"1\":{\"64\":1}}],[\"使得动态增长成为可能\",{\"1\":{\"64\":1}}],[\"使得堆中的内容可以被多个栈共享\",{\"1\":{\"64\":1}}],[\"使得处理逻辑更为清晰\",{\"1\":{\"64\":1}}],[\"使多线程中的变量可见\",{\"1\":{\"64\":1}}],[\"使慢的提供者收到更少请求\",{\"1\":{\"64\":1}}],[\"使用run指令时应该尽量遵循以下原则\",{\"1\":{\"231\":1}}],[\"使用国内软件源加快镜像构建速度\",{\"1\":{\"231\":1}}],[\"使用不当也会引发很多问题\",{\"1\":{\"231\":1}}],[\"使用idea连接\",{\"0\":{\"229\":1}}],[\"使用宿主端口\",{\"1\":{\"219\":1}}],[\"使用compose\",{\"1\":{\"219\":1}}],[\"使用cow可以有效的提高磁盘的利用率\",{\"1\":{\"218\":1}}],[\"使用微服务架构的应用系统一般包含若干个微服务\",{\"1\":{\"219\":1}}],[\"使用dockerfile构建微服务镜像\",{\"1\":{\"218\":1}}],[\"使用dockerfile构建docker镜像\",{\"1\":{\"218\":1}}],[\"使用docker\",{\"1\":{\"217\":2,\"218\":1}}],[\"使用docker镜像可以运行\",{\"1\":{\"217\":1}}],[\"使用以下docker\",{\"1\":{\"217\":1}}],[\"使用命令docker\",{\"1\":{\"217\":1}}],[\"使用系统安装光盘可以安装系统\",{\"1\":{\"217\":1}}],[\"使用消息队列来作为两个系统之间的通讯方式\",{\"1\":{\"216\":1}}],[\"使用aio读取数据时\",{\"1\":{\"216\":1}}],[\"使用nio读取数据时\",{\"1\":{\"216\":1}}],[\"使用bio读取数据时\",{\"1\":{\"216\":1}}],[\"使用这种语法创建出来的索引就叫降序索引\",{\"1\":{\"216\":1}}],[\"使用这种语法创建出来的索引叫做升序索引\",{\"1\":{\"216\":1}}],[\"使用的队列常见问题\",{\"0\":{\"161\":1}}],[\"使用的流量控制协议是可变大小的滑动窗口协议\",{\"1\":{\"21\":1}}],[\"使用\",{\"1\":{\"77\":1,\"81\":1,\"216\":1,\"217\":7,\"218\":3,\"231\":4}}],[\"使用键值对存储\",{\"1\":{\"67\":1}}],[\"使用limit\",{\"1\":{\"64\":1}}],[\"使用linkedblockingquene作为阻塞队列\",{\"1\":{\"64\":1}}],[\"使用缓存的9大误区\",{\"1\":{\"64\":2}}],[\"使用随机算法产生一个数\",{\"1\":{\"64\":1}}],[\"使用过程中的问题可以百度\",{\"1\":{\"64\":1}}],[\"使用更佳稳定靠谱的jdk代码\",{\"1\":{\"64\":1}}],[\"使用服务器集群来解决单台的瓶颈问题\",{\"1\":{\"64\":1}}],[\"使用该线程池时\",{\"1\":{\"64\":1}}],[\"使用数据库默认的事务隔离级别\",{\"1\":{\"64\":1}}],[\"使用场景有哪些\",{\"0\":{\"115\":1}}],[\"使用场景\",{\"0\":{\"167\":1},\"1\":{\"64\":2}}],[\"使用反射技术要求程序必须在一个没有安全限制的环境中运行\",{\"1\":{\"64\":1}}],[\"使用它可以提供非阻塞式的高伸缩性网络\",{\"1\":{\"64\":1}}],[\"使用threadlocal\",{\"1\":{\"64\":1}}],[\"使用了非对称加密\",{\"1\":{\"48\":1}}],[\"使用长连接的http协议\",{\"1\":{\"30\":1}}],[\"使其上面的数据链路层不必考虑网络的具体传输介质是什么\",{\"1\":{\"12\":1}}],[\"能否分享下java栈最优dockfile\",{\"1\":{\"251\":1}}],[\"能够提高运算效率\",{\"1\":{\"79\":1}}],[\"能够提供非常优秀的性能和很灵活的管理能力\",{\"1\":{\"64\":1}}],[\"能够使人更方便的访问互联网\",{\"1\":{\"8\":1}}],[\"能使用静态页面的地方尽量使用\",{\"1\":{\"64\":1}}],[\"能让你创建仅在特定版本的\",{\"1\":{\"64\":1}}],[\"能最有效地工作\",{\"1\":{\"26\":1}}],[\"能提示发送方降低发送的速率\",{\"1\":{\"21\":1}}],[\"当run指令后面跟的内容比较复杂时\",{\"1\":{\"231\":1}}],[\"当需要修改一个文件时\",{\"1\":{\"218\":1}}],[\"当新建一个虚拟机时\",{\"1\":{\"218\":1}}],[\"当新建一个容器时\",{\"1\":{\"218\":1}}],[\"当容器中的应用有持久化数据的需求时可以在\",{\"1\":{\"218\":1}}],[\"当缓存的消息达到一定数量时再批量发送给broker\",{\"1\":{\"216\":1}}],[\"当发送一条消息时\",{\"1\":{\"216\":1}}],[\"当发现系统压力过载时\",{\"1\":{\"216\":1}}],[\"当调用服务时\",{\"1\":{\"216\":1}}],[\"当调用线程池的shutdownnow\",{\"1\":{\"216\":1}}],[\"当调用线程池的shutdown\",{\"1\":{\"216\":1}}],[\"当服务a调用的某个服务b不可用时\",{\"1\":{\"216\":1}}],[\"当leader节点接收到写请求时\",{\"1\":{\"216\":1}}],[\"当broker发现一段时间half消息没有收到任何操作命令\",{\"1\":{\"216\":2}}],[\"当程序运行时\",{\"1\":{\"216\":1}}],[\"当某个线程释放了某个许可后\",{\"1\":{\"216\":1}}],[\"当某一台提供者挂时\",{\"1\":{\"64\":1}}],[\"当数字被减成0后\",{\"1\":{\"216\":1}}],[\"当锁释放时\",{\"1\":{\"216\":1}}],[\"当机房中间的网络断掉之后\",{\"1\":{\"216\":1}}],[\"当第17个请求过来时\",{\"1\":{\"216\":1}}],[\"当然应该使用add指令了\",{\"1\":{\"231\":1}}],[\"当然\",{\"1\":{\"219\":1}}],[\"当然也可使用\",{\"1\":{\"217\":1}}],[\"当然其实真正的步骤更加细致\",{\"1\":{\"216\":1}}],[\"当然并不是线程池中的所有线程都需要一直保活\",{\"1\":{\"216\":1}}],[\"当然是可以的\",{\"1\":{\"216\":1}}],[\"当然它所占用的空间大小会随着它的功能而减少\",{\"1\":{\"64\":1}}],[\"当创建\",{\"1\":{\"96\":1}}],[\"当对\",{\"1\":{\"83\":1}}],[\"当一个sql想要利用索引是\",{\"1\":{\"216\":1}}],[\"当一个线程获取到锁后\",{\"1\":{\"216\":1}}],[\"当一个线程处理完当前任务后\",{\"1\":{\"216\":1}}],[\"当一个线程占用锁访问其中一个段数据时\",{\"1\":{\"83\":1}}],[\"当一个线程访问同步方法时\",{\"1\":{\"81\":1}}],[\"当一个网页打开完成后\",{\"1\":{\"30\":1}}],[\"当链表长度大于阈值\",{\"1\":{\"73\":1,\"78\":1,\"90\":1}}],[\"当链表长度到8时\",{\"1\":{\"64\":2}}],[\"当follower副本\",{\"1\":{\"64\":1}}],[\"当follower副本从异常中恢复之后\",{\"1\":{\"64\":1}}],[\"当出现消费者宕机重启或rebalance操作时\",{\"1\":{\"64\":1}}],[\"当出现异常或超时的情况时\",{\"1\":{\"64\":1}}],[\"当出现异常时\",{\"1\":{\"64\":1}}],[\"当生产者向kafka发送消息\",{\"1\":{\"64\":1}}],[\"当这个主节点挂掉后\",{\"1\":{\"64\":1}}],[\"当jdk代理的性能也能够同样好的时候\",{\"1\":{\"64\":1}}],[\"当栈中存储数据比较多时\",{\"1\":{\"64\":1}}],[\"当sleep\",{\"1\":{\"64\":1}}],[\"当提交新任务时\",{\"1\":{\"64\":1}}],[\"当读取数据时\",{\"1\":{\"64\":1}}],[\"当前使用的内存和最大可以使用的内存\",{\"1\":{\"218\":1}}],[\"当前线程池中没有工作线程后\",{\"1\":{\"216\":1}}],[\"当前\",{\"1\":{\"64\":1}}],[\"当失败的调用到一定阈值\",{\"1\":{\"64\":1}}],[\"当请求调到第二台时就卡在那\",{\"1\":{\"64\":1}}],[\"当我们利用线程池执行任务时\",{\"1\":{\"216\":1}}],[\"当我们在定义integer数字时\",{\"1\":{\"216\":1}}],[\"当我们只需要存放元素值时\",{\"1\":{\"91\":1}}],[\"当我们需要对某一个集合实现两种排序方式\",{\"1\":{\"85\":1}}],[\"当我们把对象拆开\",{\"1\":{\"64\":1}}],[\"当我们提交更新的时候\",{\"1\":{\"64\":1}}],[\"当我们引入核心依赖时\",{\"1\":{\"64\":1}}],[\"当我们合理使用缓存\",{\"1\":{\"58\":1}}],[\"当父亲已经加载了该类时\",{\"1\":{\"64\":1}}],[\"当线程的空闲时间超过keepalivetime\",{\"1\":{\"64\":1}}],[\"当线程池中没有线程在运行后\",{\"1\":{\"216\":1}}],[\"当线程池中线程数量大于等于\",{\"1\":{\"64\":1}}],[\"当线程池中线程数量小于\",{\"1\":{\"64\":1}}],[\"当线程池没有可执行任务时\",{\"1\":{\"64\":1}}],[\"当线程空闲时间超过了keepalive时\",{\"1\":{\"64\":1}}],[\"当线程退出时\",{\"1\":{\"64\":1}}],[\"当遇到相关的问题时\",{\"1\":{\"59\":1}}],[\"当资源到达浏览器之后\",{\"1\":{\"58\":1}}],[\"当盒模型的位置\",{\"1\":{\"57\":1}}],[\"当使用shell模式时\",{\"1\":{\"231\":1}}],[\"当使用索引列等值查询时\",{\"1\":{\"216\":1}}],[\"当使用paralold时\",{\"1\":{\"64\":1}}],[\"当使用g1\",{\"1\":{\"64\":1}}],[\"当使用\",{\"1\":{\"52\":1}}],[\"当你需要编写编译型语言\",{\"1\":{\"231\":1}}],[\"当你需要存储一个列表数据\",{\"1\":{\"171\":1}}],[\"当你想要使用add向容器中添加\",{\"1\":{\"231\":1}}],[\"当你把对象加入hashset时\",{\"1\":{\"75\":1}}],[\"当你对kafka消息进行迭代时\",{\"1\":{\"64\":1}}],[\"当你将你的应用从\",{\"1\":{\"64\":1}}],[\"当你在浏览器中输入一个地址时\",{\"1\":{\"41\":1}}],[\"当你要添加商品到购物车的时候\",{\"1\":{\"31\":1,\"32\":1}}],[\"当客户端浏览器访问的某个html或其他类型的web页中包含有其他的web资源\",{\"1\":{\"30\":1}}],[\"当有多个数据信息包在某一段很短的时间内丢失时\",{\"1\":{\"26\":1}}],[\"当有单独的数据包丢失时\",{\"1\":{\"26\":1}}],[\"当a发送m1消息\",{\"1\":{\"23\":1}}],[\"当\",{\"1\":{\"21\":1,\"46\":1,\"64\":1}}],[\"当网络拥塞时\",{\"1\":{\"21\":1}}],[\"当接收方来不及处理发送方的数据\",{\"1\":{\"21\":1}}],[\"当另一方也没有数据再发送的时候\",{\"1\":{\"19\":1}}],[\"将编译环境和运行环境分开\",{\"1\":{\"252\":1}}],[\"将文件从只读的lower复制到可写的upper进行修改\",{\"1\":{\"218\":1}}],[\"将微服务镜像发布到远程镜像仓库\",{\"1\":{\"218\":1}}],[\"将微服务运行在docker上\",{\"0\":{\"218\":1}}],[\"将jar包上传linux服务器\",{\"1\":{\"218\":1}}],[\"将该微服务的可运行jar包构建成docker镜像\",{\"1\":{\"218\":1}}],[\"将系统中各个功能个体抽成一个个小的应用程序\",{\"1\":{\"216\":1}}],[\"将减库存消息加入在本地事务中\",{\"1\":{\"216\":1}}],[\"将方法的名字做为beanname\",{\"1\":{\"216\":1}}],[\"将这些自动加载为配置bean\",{\"1\":{\"216\":1}}],[\"将这个变量所在缓存行的数据写会到系统内存\",{\"1\":{\"64\":1}}],[\"将\",{\"1\":{\"216\":3,\"225\":1}}],[\"将对象交给spring来控制\",{\"1\":{\"216\":1}}],[\"将请求传递给绑定了该端口的应用程序\",{\"1\":{\"216\":1}}],[\"将每组分给不同的线程来进行元素的转移\",{\"1\":{\"216\":1}}],[\"将新数组赋值给hashmap对象的table属性\",{\"1\":{\"216\":2}}],[\"将交集存在key1内\",{\"1\":{\"171\":1}}],[\"将其所有粉丝存在一个集合\",{\"1\":{\"171\":1}}],[\"将链表和数组相结合\",{\"1\":{\"77\":1}}],[\"将链表转化为红黑树\",{\"1\":{\"73\":1,\"78\":1,\"90\":1}}],[\"将会看到nginx的主界面如下\",{\"1\":{\"217\":1}}],[\"将会阻塞\",{\"1\":{\"216\":1}}],[\"将会从isr中删除\",{\"1\":{\"64\":1}}],[\"将会使用定时器来要求传输暂停\",{\"1\":{\"26\":1}}],[\"将user对象地址赋值给引用\",{\"1\":{\"64\":1}}],[\"将整个区间段的业务流分配到合适的应用服务器进行处理\",{\"1\":{\"64\":1}}],[\"将version字段的值一同读出\",{\"1\":{\"64\":1}}],[\"将bean注入改为使用注解注入的方式\",{\"1\":{\"64\":1}}],[\"将资源放在浏览器端\",{\"1\":{\"58\":1}}],[\"将信息快速并友好的展示给用户并能够与用户进行交互\",{\"1\":{\"58\":1}}],[\"将窗口字段设置为\",{\"1\":{\"25\":1}}],[\"将重发这个报文段\",{\"1\":{\"21\":1}}],[\"将丢弃这个报文段和不确认收到此报文段\",{\"1\":{\"21\":1}}],[\"将保持它首部和数据的检验和\",{\"1\":{\"21\":1}}],[\"将占用一个序号\",{\"1\":{\"18\":1}}],[\"校验和\",{\"1\":{\"21\":1}}],[\"远程调用层\",{\"1\":{\"216\":1}}],[\"远程登录等场景\",{\"1\":{\"20\":1}}],[\"远地主机在收到\",{\"1\":{\"20\":1}}],[\"还记得上节课\",{\"1\":{\"219\":1}}],[\"还带有简单易懂的实例\",{\"1\":{\"217\":1}}],[\"还包括可以实现计数器\",{\"1\":{\"216\":1}}],[\"还继承了诸如environmentcapable\",{\"1\":{\"216\":1}}],[\"还可以帮助我们减少镜像的体积\",{\"1\":{\"231\":1}}],[\"还可以是一个压缩包\",{\"1\":{\"218\":1}}],[\"还可以分为\",{\"1\":{\"216\":2}}],[\"还可以调整tomcat的线程\",{\"1\":{\"216\":1}}],[\"还可以找到占用cpu最多的线程\",{\"1\":{\"216\":1}}],[\"还可能会延伸考察concurrenthashmap与hashmap\",{\"1\":{\"64\":1}}],[\"还能有哪种方式实现\",{\"0\":{\"106\":1}}],[\"还能具备频道管理\",{\"1\":{\"64\":1}}],[\"还有好处就是\",{\"1\":{\"233\":1}}],[\"还有很多其他命令\",{\"1\":{\"219\":1}}],[\"还有一个核心就是添加注解\",{\"1\":{\"216\":1}}],[\"还有一点需要注意的是\",{\"1\":{\"216\":1}}],[\"还有就是写sql\",{\"0\":{\"159\":1}}],[\"还有就是抽象类和接口的区别\",{\"0\":{\"101\":1}}],[\"还有脏读\",{\"0\":{\"137\":1}}],[\"还有duddo\",{\"1\":{\"64\":1}}],[\"还有redis等不推荐\",{\"1\":{\"64\":1}}],[\"还有mina\",{\"1\":{\"64\":1}}],[\"还有别的选择吗\",{\"1\":{\"64\":2}}],[\"还要为即将拷贝到容器的文件计算校验和\",{\"1\":{\"231\":1}}],[\"还要额外的配置相关的bean\",{\"1\":{\"216\":1}}],[\"还要把前后entry的before\",{\"1\":{\"64\":1}}],[\"还要占用许多处理机资源\",{\"1\":{\"20\":1}}],[\"还会绑定一些监听器\",{\"1\":{\"216\":1}}],[\"还会浪费空间\",{\"1\":{\"64\":2}}],[\"还会有\",{\"1\":{\"64\":1}}],[\"还会断开连接用来节约系统资源\",{\"1\":{\"20\":1}}],[\"还实现了\",{\"1\":{\"64\":1}}],[\"还是资深患者\",{\"1\":{\"217\":1}}],[\"还是得看这个bean对象本身\",{\"1\":{\"216\":1}}],[\"还是用http2呢\",{\"1\":{\"216\":1}}],[\"还是利用http发出去\",{\"1\":{\"216\":1}}],[\"还是开10个窗口让人舒服些呢\",{\"1\":{\"216\":1}}],[\"还是一样\",{\"1\":{\"216\":1}}],[\"还是一个\",{\"1\":{\"64\":1}}],[\"还是会存在其他问题比如数据丢失\",{\"1\":{\"80\":1}}],[\"还是传引用\",{\"1\":{\"64\":1}}],[\"还是背了几道面经\",{\"1\":{\"64\":1}}],[\"还是只停留在表面\",{\"1\":{\"64\":1}}],[\"还是没有收到\",{\"1\":{\"23\":1}}],[\"计算出每个元素在新数组中的下标\",{\"1\":{\"216\":1}}],[\"计算hashcode\",{\"1\":{\"74\":1}}],[\"计算一个正整数的正平方根\",{\"1\":{\"64\":1}}],[\"计算机网络第七版\",{\"1\":{\"36\":1}}],[\"计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路\",{\"1\":{\"10\":1}}],[\"计算机网络\",{\"0\":{\"5\":1,\"6\":1}}],[\"计数器\",{\"1\":{\"64\":1,\"216\":1}}],[\"计时器以及连接管理等\",{\"1\":{\"20\":1}}],[\"窗口\",{\"1\":{\"20\":1}}],[\"面向对象的设计\",{\"1\":{\"64\":1}}],[\"面向对象的引入\",{\"1\":{\"64\":1}}],[\"面向对象方式的程序与以前结构化的程序在执行上没有任何区别\",{\"1\":{\"64\":1}}],[\"面向对象就是堆和栈的完美结合\",{\"1\":{\"64\":1}}],[\"面向连接的传输服务\",{\"1\":{\"20\":1}}],[\"面试题\",{\"0\":{\"215\":1}}],[\"面试大厂的面试题\",{\"1\":{\"92\":1}}],[\"面试\",{\"0\":{\"92\":1,\"257\":1}}],[\"面试突击\",{\"1\":{\"91\":1}}],[\"面试突击版\",{\"1\":{\"91\":2}}],[\"面试必问的volatile\",{\"1\":{\"64\":1}}],[\"面试必问的cas\",{\"1\":{\"64\":1}}],[\"面试必读\",{\"1\":{\"64\":2}}],[\"面试总结\",{\"1\":{\"64\":1}}],[\"面试常客\",{\"0\":{\"14\":1,\"27\":1}}],[\"但只有最后一个有效\",{\"1\":{\"218\":1}}],[\"但不支持url和压缩包\",{\"1\":{\"218\":1}}],[\"但如果想要在其他机器上运行这个镜像\",{\"1\":{\"217\":1}}],[\"但需要线程主动的去查询是否有io事件\",{\"1\":{\"216\":1}}],[\"但值得注意的是\",{\"1\":{\"216\":1}}],[\"但在所有版本的docker中都可以共享镜像层\",{\"1\":{\"218\":1}}],[\"但在分布式系统中\",{\"1\":{\"216\":1}}],[\"但在某些情况下\",{\"1\":{\"20\":1}}],[\"但线程池中的线程不会回收\",{\"1\":{\"216\":1}}],[\"但并没有真正理解\",{\"1\":{\"216\":1}}],[\"但并不能保证字节码指令的原子执行\",{\"1\":{\"64\":1}}],[\"但并不向被动方应用投递消息\",{\"1\":{\"64\":1}}],[\"但它一般有两种使用情况\",{\"1\":{\"96\":1}}],[\"但却要冒多线程不安全的风险\",{\"1\":{\"94\":1}}],[\"但却在传输过程中丢失\",{\"1\":{\"23\":1}}],[\"但问题是一个40亿长度的数组\",{\"1\":{\"79\":1}}],[\"但也可以是任何对象\",{\"1\":{\"67\":1}}],[\"但也避免了上面提到的原生rpc带来的问题\",{\"1\":{\"64\":1}}],[\"但key不能重复\",{\"1\":{\"67\":1}}],[\"但可能会重复传递\",{\"1\":{\"64\":1}}],[\"但绝不会重复传递\",{\"1\":{\"64\":1}}],[\"但对于一个分布式系统\",{\"1\":{\"216\":1}}],[\"但对于服务器本身的io处理性能是没有任何的改变\",{\"1\":{\"64\":1}}],[\"但对称加密的密钥用服务器方的证书进行了非对称加密\",{\"1\":{\"35\":1}}],[\"但没挂\",{\"1\":{\"64\":1}}],[\"但调用量越大分布越均匀\",{\"1\":{\"64\":1}}],[\"但已经逐步\",{\"1\":{\"64\":1}}],[\"但由于malloc是先分配虚拟地址空间\",{\"1\":{\"64\":1}}],[\"但由于\",{\"1\":{\"46\":1}}],[\"但同时还要发送确认\",{\"1\":{\"23\":2}}],[\"但是功能相对也少\",{\"1\":{\"245\":1}}],[\"但是copy指令只支持基本的文件和文件夹拷贝功能\",{\"1\":{\"231\":1}}],[\"但是copyonwritearraylist会比较占内存\",{\"1\":{\"216\":1}}],[\"但是也有一些区别\",{\"1\":{\"231\":1}}],[\"但是有些指令除外\",{\"1\":{\"231\":1}}],[\"但是只能有一个cmd命令\",{\"1\":{\"218\":1}}],[\"但是只能保证趋势递增\",{\"1\":{\"216\":1}}],[\"但是消费者不能按自己的能力来消费消息\",{\"1\":{\"216\":1}}],[\"但是消费者不能及时知道是否有消息\",{\"1\":{\"216\":1}}],[\"但是dubbo的服务调用性能比spring\",{\"1\":{\"216\":1}}],[\"但是减库存失败\",{\"1\":{\"216\":1}}],[\"但是受到单机数据库性能的限制\",{\"1\":{\"216\":1}}],[\"但是会影响存储空间和性能\",{\"1\":{\"216\":1}}],[\"但是会继续处理队列中的任务\",{\"1\":{\"216\":1}}],[\"但是对于copy和add命令会计算镜像内的⽂件和构建⽬录⽂件的校验和然后做⽐较来判断本层是否有改动\",{\"1\":{\"239\":1}}],[\"但是对于大量内容并且频繁更新的网站\",{\"1\":{\"64\":1}}],[\"但是对外看上去应该是一个整体\",{\"1\":{\"216\":1}}],[\"但是具体可以选择不同的策路来进行实例化\",{\"1\":{\"216\":1}}],[\"但是具体有哪些前面提到的对象依赖于具体的jvm实现\",{\"1\":{\"64\":1}}],[\"但是applicationcontext除开继承了beanfactory之外\",{\"1\":{\"216\":1}}],[\"但是arraylist越靠近尾部的元素进行增删时\",{\"1\":{\"64\":1}}],[\"但是直接找\",{\"1\":{\"216\":1}}],[\"但是缓冲队列workqueue未满\",{\"1\":{\"216\":1}}],[\"但是linkedlist还额外实现了deque接口\",{\"1\":{\"216\":1}}],[\"但是此时过半机制的条件是set\",{\"1\":{\"216\":1}}],[\"但是此方法只会被调用一次\",{\"1\":{\"64\":1}}],[\"但是我说不出来\",{\"1\":{\"216\":1}}],[\"但是我更加不愿意排队\",{\"1\":{\"216\":1}}],[\"但是我们在创建索引的时候\",{\"1\":{\"216\":1}}],[\"但是现在只有一台点钞机\",{\"1\":{\"216\":1}}],[\"但是线程池会把阻塞队列中的剩余任务执行完\",{\"1\":{\"216\":1}}],[\"但是为什么索引能提高查询速度呢\",{\"1\":{\"216\":1}}],[\"但是大家不知道的是\",{\"1\":{\"216\":1}}],[\"但是数据不消费怎么处理\",{\"0\":{\"162\":1}}],[\"但是没有用\",{\"1\":{\"94\":1}}],[\"但是已经简化了属性\",{\"1\":{\"81\":1}}],[\"但是还是不建议在多线程下使用\",{\"1\":{\"80\":1}}],[\"但是原理不变\",{\"1\":{\"77\":1}}],[\"但是一个线程访问vector的话代码要在同步操作上耗费大量的时间\",{\"1\":{\"71\":1}}],[\"但是如果你\",{\"1\":{\"231\":1}}],[\"但是如果消息生产者宕机\",{\"1\":{\"216\":1}}],[\"但是如果服务c抗不住\",{\"1\":{\"216\":1}}],[\"但是如果考虑到注册中心应该是注册可用性的话\",{\"1\":{\"216\":1}}],[\"但是如果发现有相同hashcode值的对象\",{\"1\":{\"75\":1}}],[\"但是如果要在指定位置\",{\"1\":{\"68\":1}}],[\"但是如果使用了线程池的话\",{\"1\":{\"64\":1}}],[\"但是从效率上将\",{\"1\":{\"64\":1}}],[\"但是从来源来看的话\",{\"1\":{\"64\":1}}],[\"但是可以消除碎片\",{\"1\":{\"64\":1}}],[\"但是串行收集器只适用于小数据量的情况\",{\"1\":{\"64\":1}}],[\"但是不能写\",{\"1\":{\"216\":1}}],[\"但是不能重复\",{\"1\":{\"216\":1}}],[\"但是不能没有栈\",{\"1\":{\"64\":1}}],[\"但是不可重复读和虚读有可能发生\",{\"1\":{\"64\":1}}],[\"但是当进入被调用方法时\",{\"1\":{\"64\":1}}],[\"但是当文档加载过程中遇到\",{\"1\":{\"57\":1}}],[\"但是传引用的错觉是如何造成的呢\",{\"1\":{\"64\":1}}],[\"但是基本类型\",{\"1\":{\"64\":2}}],[\"但是在高并发下性能较低\",{\"1\":{\"216\":1}}],[\"但是在\",{\"1\":{\"73\":1}}],[\"但是在栈中\",{\"1\":{\"64\":1}}],[\"但是在对象的finalize方法中重新建立引用\",{\"1\":{\"64\":1}}],[\"但是在用户的眼中\",{\"1\":{\"45\":1}}],[\"但是物有所值\",{\"1\":{\"64\":1}}],[\"但是更新不算\",{\"1\":{\"64\":1}}],[\"但是效率很低\",{\"1\":{\"64\":1}}],[\"但是市面上一些主流的\",{\"1\":{\"64\":1}}],[\"但是虚读有可能发生\",{\"1\":{\"64\":1}}],[\"但是spring\",{\"1\":{\"64\":1}}],[\"但是却影响\",{\"1\":{\"57\":1}}],[\"但是又存在某些任务比较耗时\",{\"1\":{\"57\":1}}],[\"但是势必会带来一些时间上的损耗\",{\"1\":{\"48\":1}}],[\"但是这个过程中存在一定的风险\",{\"1\":{\"47\":1}}],[\"但是放在这里好像又说的过去\",{\"1\":{\"47\":1}}],[\"但是你是否发现少了点什么\",{\"1\":{\"42\":1}}],[\"但是内容很是充实\",{\"1\":{\"36\":1}}],[\"但是两者的应用场景不太一样\",{\"1\":{\"32\":1}}],[\"但是\",{\"1\":{\"19\":1,\"35\":1,\"41\":1,\"64\":3,\"79\":1,\"216\":2,\"217\":1}}],[\"但是接收方到发送方的通道还需要\",{\"1\":{\"18\":1}}],[\"虽然小\",{\"1\":{\"245\":1}}],[\"虽然有这么多好处\",{\"1\":{\"231\":1}}],[\"虽然可能会慢一些\",{\"1\":{\"216\":1}}],[\"虽然服务过程会比较慢\",{\"1\":{\"216\":1}}],[\"虽然在jdk1\",{\"1\":{\"81\":1}}],[\"虽然在一定程度上来说\",{\"1\":{\"64\":1}}],[\"虽然提供了安全保证\",{\"1\":{\"48\":1}}],[\"虽然\",{\"1\":{\"20\":1}}],[\"报文分析\",{\"1\":{\"59\":1}}],[\"报文开始\",{\"1\":{\"53\":1}}],[\"报文进行加密\",{\"1\":{\"47\":1}}],[\"报文进入\",{\"1\":{\"47\":1}}],[\"报文之前\",{\"1\":{\"47\":1}}],[\"报文之前对\",{\"1\":{\"47\":1}}],[\"报文是明文\",{\"1\":{\"47\":1}}],[\"报文是包裹在\",{\"1\":{\"47\":1}}],[\"报文时会解包提取出\",{\"1\":{\"47\":1}}],[\"报文中发送的\",{\"1\":{\"47\":1}}],[\"报文\",{\"0\":{\"53\":1},\"1\":{\"39\":1,\"47\":1}}],[\"报文后\",{\"1\":{\"20\":1}}],[\"报文确认\",{\"1\":{\"18\":1}}],[\"7aa5dc458f9d\",{\"1\":{\"217\":1}}],[\"748条\",{\"1\":{\"216\":1}}],[\"7455g\",{\"1\":{\"216\":2}}],[\"7从节点完成rdb的载入后\",{\"1\":{\"216\":1}}],[\"7zuul\",{\"1\":{\"216\":1}}],[\"7当leader节点收到半数以上的ack后\",{\"1\":{\"216\":1}}],[\"7集群中每个节点都会经过同样的流程\",{\"1\":{\"216\":1}}],[\"7jar包内部的application\",{\"1\":{\"216\":1}}],[\"7handleradapter\",{\"1\":{\"216\":1}}],[\"7在源码中会更复杂\",{\"1\":{\"216\":1}}],[\"7执行完当前方法后\",{\"1\":{\"216\":1}}],[\"7初始化后\",{\"1\":{\"216\":1}}],[\"7然后servlet来处理这个请求\",{\"1\":{\"216\":1}}],[\"7版本的concurrenthashmap是基于segment分段实现的\",{\"1\":{\"216\":1}}],[\"7版本\",{\"1\":{\"216\":2}}],[\"7另外像负载均衡\",{\"1\":{\"216\":1}}],[\"7的concurrenthashmap\",{\"1\":{\"81\":1}}],[\"7的时候\",{\"1\":{\"81\":1}}],[\"7的\",{\"1\":{\"77\":1,\"81\":1}}],[\"7取消了循环\",{\"1\":{\"68\":1,\"89\":1}}],[\"7200转\",{\"1\":{\"64\":1}}],[\"72861891\",{\"1\":{\"19\":1}}],[\"766\",{\"1\":{\"64\":1}}],[\"75\",{\"1\":{\"64\":2}}],[\"71075051\",{\"1\":{\"64\":1}}],[\"7843809\",{\"1\":{\"64\":1}}],[\"78248454\",{\"1\":{\"64\":1}}],[\"78297568\",{\"1\":{\"64\":2}}],[\"7和1\",{\"1\":{\"64\":2}}],[\"79781680\",{\"1\":{\"64\":1}}],[\"79664102\",{\"1\":{\"64\":1}}],[\"73743641\",{\"1\":{\"37\":1}}],[\"7\",{\"0\":{\"27\":1,\"75\":1,\"83\":1,\"100\":1,\"158\":1,\"182\":1,\"198\":1},\"1\":{\"64\":6,\"77\":3,\"86\":10,\"216\":5,\"217\":2,\"219\":2,\"231\":8}}],[\"7064869\",{\"1\":{\"13\":1}}],[\"70k\",{\"1\":{\"6\":1,\"66\":1,\"75\":1}}],[\"qa\",{\"1\":{\"219\":1}}],[\"q\",{\"1\":{\"217\":2}}],[\"qualifierannotationautowirecandidateresolver\",{\"1\":{\"216\":1}}],[\"quake\",{\"0\":{\"197\":1}}],[\"queuedtasks\",{\"1\":{\"216\":1}}],[\"queued\",{\"1\":{\"216\":3}}],[\"queue\",{\"1\":{\"57\":1,\"64\":1}}],[\"quicksort\",{\"1\":{\"4\":5}}],[\"qq\",{\"1\":{\"20\":2,\"33\":1,\"37\":2}}],[\"qzcsu\",{\"1\":{\"19\":1}}],[\"于是采取了这种设计\",{\"1\":{\"64\":1}}],[\"于是需要使用数据库集群或者库表散列\",{\"1\":{\"64\":1}}],[\"于是有必要将图片与页面进行分离\",{\"1\":{\"64\":1}}],[\"于是出现了常见的信息发布系统cms\",{\"1\":{\"64\":1}}],[\"于是我自问自答一番\",{\"1\":{\"39\":1}}],[\"于是\",{\"1\":{\"19\":1}}],[\"可写层就是container\",{\"1\":{\"218\":1}}],[\"可正常显示eureka\",{\"1\":{\"218\":1}}],[\"可多次设置\",{\"1\":{\"218\":1}}],[\"可看到下图所示界面\",{\"1\":{\"218\":1}}],[\"可使用\",{\"1\":{\"217\":5}}],[\"可通过\",{\"1\":{\"217\":2}}],[\"可定制性更高\",{\"1\":{\"216\":1}}],[\"可复用的一些工具\",{\"1\":{\"216\":1}}],[\"可见性\",{\"1\":{\"216\":1}}],[\"可变性\",{\"1\":{\"94\":1}}],[\"可伸缩\",{\"1\":{\"64\":1}}],[\"可用性表示\",{\"1\":{\"216\":1}}],[\"可用\",{\"1\":{\"64\":2}}],[\"可与cms收集同时使用\",{\"1\":{\"64\":1}}],[\"可管理的cms是必不可少的\",{\"1\":{\"64\":1}}],[\"可运行线程池\",{\"1\":{\"64\":1}}],[\"可发送\",{\"1\":{\"64\":1}}],[\"可重复读\",{\"1\":{\"64\":2}}],[\"可重入代码\",{\"1\":{\"64\":1}}],[\"可谓说是\",{\"1\":{\"59\":1}}],[\"可以保证我们的业务进程就是\",{\"1\":{\"237\":1}}],[\"可以把你的想法写在留言区\",{\"1\":{\"231\":1}}],[\"可以把一个对象看作为一棵树\",{\"1\":{\"64\":1}}],[\"可以大大缩短镜像构建时间\",{\"1\":{\"231\":1}}],[\"可以大量减少与数据库的交互\",{\"1\":{\"64\":1}}],[\"可以按照如下顺序编写\",{\"1\":{\"231\":1}}],[\"可以相互访问\",{\"1\":{\"219\":1}}],[\"可以相互用服务名访问\",{\"1\":{\"219\":1}}],[\"可以参考docker\",{\"1\":{\"219\":1}}],[\"可以参考arrayblockingqueue的底层实现\",{\"1\":{\"64\":1}}],[\"可以是一个值\",{\"1\":{\"219\":2}}],[\"可以是一个路径\",{\"1\":{\"219\":1}}],[\"可以为单独的文件路径或列表\",{\"1\":{\"219\":1}}],[\"可以为我们带来哪些\",{\"1\":{\"43\":1}}],[\"可以指定只读或者可读写\",{\"1\":{\"219\":1}}],[\"可以指定服务名称和链接的别名使用service\",{\"1\":{\"219\":1}}],[\"可以设置宿主机路径\",{\"1\":{\"219\":1}}],[\"可以设置许可的个数\",{\"1\":{\"216\":1}}],[\"可以查看docker的官方文档\",{\"1\":{\"219\":1}}],[\"可以查看所有仓库中所有docker版本\",{\"1\":{\"217\":1}}],[\"可以挂载一个主机上的目录到容器的目录\",{\"1\":{\"218\":1}}],[\"可以包含多个run命令\",{\"1\":{\"218\":1}}],[\"可以简化部署多种应用实例工作\",{\"1\":{\"217\":1}}],[\"可以批量拉取\",{\"1\":{\"216\":1}}],[\"可以很方便地找到各个版本之间的变更历史\",{\"1\":{\"231\":1}}],[\"可以很好的支持全表扫描\",{\"1\":{\"216\":1}}],[\"可以很快的得到距离当前最小的定时器\",{\"1\":{\"64\":1}}],[\"可以缓存某个简单的字符串\",{\"1\":{\"216\":1}}],[\"可以同时启动多个串行化的线程并行运行\",{\"1\":{\"216\":1}}],[\"可以对访问服务的请求进行数量上的限制\",{\"1\":{\"216\":1}}],[\"可以对hashmap\",{\"1\":{\"64\":1}}],[\"可以利用索引来快速查找\",{\"1\":{\"216\":1}}],[\"可以利用zookeeper的临时节点和watch机制来实现注册中心的自动注册和发现\",{\"1\":{\"216\":1}}],[\"可以利用reentrantlock\",{\"1\":{\"216\":1}}],[\"可以利用该机制将数据缓存在某个线程内部\",{\"1\":{\"216\":1}}],[\"可以适当选用\",{\"1\":{\"216\":1}}],[\"可以根据\",{\"1\":{\"216\":1}}],[\"可以给很多个字段进行注入\",{\"1\":{\"216\":1}}],[\"可以给countdownlatch设置一个数字\",{\"1\":{\"216\":1}}],[\"可以生成bean\",{\"1\":{\"216\":1}}],[\"可以看到镜像加速地址如下图\",{\"1\":{\"217\":1}}],[\"可以看下面的流程图\",{\"1\":{\"216\":1}}],[\"可以看出网址的解析是一个从右向左的过程\",{\"1\":{\"42\":1}}],[\"可以从两个方面来进行调整\",{\"1\":{\"216\":1}}],[\"可以从控制台启动\",{\"1\":{\"64\":1}}],[\"可以正常的接受并处理任务\",{\"1\":{\"216\":1}}],[\"可以直接\",{\"1\":{\"219\":1}}],[\"可以直接作为结果返回了\",{\"1\":{\"216\":1}}],[\"可以直接初始化配置类\",{\"1\":{\"216\":1}}],[\"可以直接面向接口\",{\"1\":{\"216\":1}}],[\"可以直接从线程池中获取线程直接使用\",{\"1\":{\"216\":1}}],[\"可以直连\",{\"1\":{\"64\":1}}],[\"可以好好看下\",{\"1\":{\"216\":1}}],[\"可以针对字段设置asc\",{\"1\":{\"216\":1}}],[\"可以理解为按消息维度的消息排行榜\",{\"1\":{\"172\":1}}],[\"可以将一个用户所有的关注人存在一个集合中\",{\"1\":{\"171\":1}}],[\"可以将任务分为cpu密集型和io密集型\",{\"1\":{\"64\":1}}],[\"可以做类似微博那种下拉不断分页的东西\",{\"1\":{\"170\":1}}],[\"可以基于\",{\"1\":{\"170\":1,\"171\":1}}],[\"可以关注我的公众号\",{\"1\":{\"91\":1}}],[\"可以有效的防止sql注入\",{\"1\":{\"216\":1}}],[\"可以有一个或多个键所对应的值为\",{\"1\":{\"73\":1}}],[\"可以有多个元素引用相同的对象\",{\"1\":{\"67\":1}}],[\"可以作为键\",{\"1\":{\"73\":1}}],[\"可以由两个线程安全地访问一个vector对象\",{\"1\":{\"71\":1}}],[\"可以自定义线程池重写这个方法\",{\"1\":{\"216\":1}}],[\"可以自己定义新的请求方式么\",{\"1\":{\"64\":1}}],[\"可以自动配置spring\",{\"1\":{\"64\":1}}],[\"可以结合zipkin实现分布式服务追踪\",{\"1\":{\"64\":1}}],[\"可以异步调用\",{\"1\":{\"64\":1}}],[\"可以优先考虑选用第二种方案\",{\"1\":{\"64\":1}}],[\"可以确保生产者不会产生重复的消息\",{\"1\":{\"64\":1}}],[\"可以这么说\",{\"1\":{\"64\":2}}],[\"可以节省一定的内存\",{\"1\":{\"64\":1}}],[\"可以考虑parnew加cms的收集器组合\",{\"1\":{\"64\":1}}],[\"可以在数据生成时准确地获得一个语义\",{\"1\":{\"64\":1}}],[\"可以在web开发中使用\",{\"1\":{\"64\":1}}],[\"可以在令一台服务器设置的iis采用网络路径来实现图片服务器\",{\"1\":{\"64\":1}}],[\"可以在不同的服务器软件\",{\"1\":{\"30\":1}}],[\"可以进行不同的配置优化\",{\"1\":{\"64\":1}}],[\"可以无限的往里面添加任务\",{\"1\":{\"64\":1}}],[\"可以通过\",{\"1\":{\"218\":1}}],[\"可以通过关闭某个服务\",{\"1\":{\"216\":1}}],[\"可以通过release\",{\"1\":{\"216\":1}}],[\"可以通过数据分片来增加吞吐量\",{\"1\":{\"64\":1}}],[\"可以通过在单机开多个redis实例来完善\",{\"1\":{\"64\":1}}],[\"可以提供更快速的访问\",{\"1\":{\"64\":1}}],[\"可以提供该资源的路径\",{\"1\":{\"34\":1}}],[\"可以插入多个null元素\",{\"1\":{\"64\":1}}],[\"可以允许重复的对象\",{\"1\":{\"64\":1}}],[\"可以使用数组或者字典两种方式\",{\"1\":{\"219\":1}}],[\"可以使用http协议\",{\"1\":{\"216\":1}}],[\"可以使用新的命令行选项\",{\"1\":{\"64\":1}}],[\"可以使用较大的线程池\",{\"1\":{\"64\":1}}],[\"可以禁止进行指令重排\",{\"1\":{\"64\":1}}],[\"可以具体到调整哪个参数\",{\"1\":{\"64\":2}}],[\"可以返回一个合适的机器的\",{\"1\":{\"45\":1}}],[\"可以用db这个域名访问mysql服务\",{\"1\":{\"219\":8}}],[\"可以用nacos这个域名访问nacos服务\",{\"1\":{\"219\":2}}],[\"可以用es这个域名访问elasticsearch服务\",{\"1\":{\"219\":2}}],[\"可以用来实现排行榜功能\",{\"1\":{\"216\":1}}],[\"可以用来缓存类似微信公众号\",{\"1\":{\"216\":1}}],[\"可以用来存储一些key\",{\"1\":{\"216\":1}}],[\"可以用来做最简单的数据\",{\"1\":{\"216\":1}}],[\"可以用来标识一个资源\",{\"1\":{\"34\":1}}],[\"可以用个长连接来发多个请求\",{\"1\":{\"33\":1}}],[\"可以唯一标识一个资源\",{\"1\":{\"34\":1}}],[\"可提高信道利用率\",{\"1\":{\"23\":1}}],[\"可能用到的索引\",{\"1\":{\"216\":1}}],[\"可能仍然不一致\",{\"1\":{\"216\":1}}],[\"可能加到\",{\"1\":{\"216\":1}}],[\"可能一部分大佬已经能理解\",{\"1\":{\"216\":1}}],[\"可能你会想到\",{\"1\":{\"216\":1}}],[\"可能有环\",{\"0\":{\"209\":1}}],[\"可能再往深处扩展\",{\"0\":{\"142\":1}}],[\"可能会拉到的消息为空\",{\"1\":{\"216\":1}}],[\"可能会出现多个客户端同时加到锁的情况\",{\"1\":{\"216\":1}}],[\"可能会出题\",{\"0\":{\"137\":1}}],[\"可能会进入阻塞或轮询状态\",{\"1\":{\"81\":1}}],[\"可能会影响性能\",{\"1\":{\"64\":1}}],[\"可能会持有相同的值对象但键对象必须是唯一的\",{\"1\":{\"64\":1}}],[\"可能会产生循环链表\",{\"1\":{\"64\":1}}],[\"可能又巴拉巴拉说了一通\",{\"1\":{\"19\":1}}],[\"可能还会有要说的话\",{\"1\":{\"19\":1}}],[\"可靠的数据传输服务\",{\"1\":{\"9\":1}}],[\"说几个熟悉\",{\"0\":{\"142\":1}}],[\"说明\",{\"1\":{\"96\":1}}],[\"说明没有发送成功\",{\"1\":{\"23\":1}}],[\"说一说\",{\"0\":{\"72\":1}}],[\"说白了就是常见的那些查找\",{\"1\":{\"64\":1}}],[\"说白了堆就是一块共享的内存\",{\"1\":{\"64\":1}}],[\"说说类加载器双亲委派模型\",{\"1\":{\"216\":1}}],[\"说说你在重构拆分中遇到的问题\",{\"0\":{\"193\":1}}],[\"说说你知道的几个java集合类\",{\"1\":{\"64\":1}}],[\"说说list\",{\"0\":{\"67\":1}}],[\"说说浏览器访问http\",{\"1\":{\"64\":1}}],[\"说说http\",{\"1\":{\"64\":1}}],[\"说说经验\",{\"1\":{\"64\":1}}],[\"说说核心的配置有哪些\",{\"1\":{\"64\":1}}],[\"说说阻塞队列的实现\",{\"1\":{\"64\":1}}],[\"说说自定义注解的场景及实现\",{\"1\":{\"64\":2}}],[\"说说反射的用途及实现\",{\"1\":{\"64\":2}}],[\"说说线程安全问题\",{\"1\":{\"64\":2}}],[\"说\",{\"1\":{\"19\":2}}],[\"说到通讯\",{\"1\":{\"16\":1}}],[\"发一次调用失败就立即报错\",{\"1\":{\"64\":1}}],[\"发布\",{\"1\":{\"64\":1}}],[\"发生长时间gc而导致kafka僵死或是网络断开连接导致长时间没有拉取消息进行同步\",{\"1\":{\"64\":1}}],[\"发生扩容时\",{\"1\":{\"64\":1}}],[\"发现可以正常访问eureka主页\",{\"1\":{\"219\":1}}],[\"发现没有正在进行扩容\",{\"1\":{\"216\":1}}],[\"发现确实很深\",{\"1\":{\"39\":1}}],[\"发现有一个问题始终绕不开\",{\"1\":{\"39\":1}}],[\"发出一个段后\",{\"1\":{\"21\":1}}],[\"发回\",{\"1\":{\"18\":1}}],[\"发送请求\",{\"1\":{\"64\":1}}],[\"发送给消息中间件\",{\"1\":{\"64\":1}}],[\"发送\",{\"1\":{\"39\":1,\"49\":1}}],[\"发送http请求\",{\"1\":{\"27\":1}}],[\"发送维持一个发送窗口\",{\"1\":{\"23\":1}}],[\"发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个\",{\"1\":{\"26\":1}}],[\"发送方要维持一个\",{\"1\":{\"26\":1}}],[\"发送方无法知道后三个分组的下落\",{\"1\":{\"24\":1}}],[\"发送方发送了\",{\"1\":{\"24\":1}}],[\"发送方发送分组\",{\"1\":{\"23\":1}}],[\"发送方维持一个发送窗口\",{\"1\":{\"24\":1}}],[\"发送方再次发送\",{\"1\":{\"23\":1}}],[\"发送和接收邮件\",{\"1\":{\"20\":1}}],[\"发送一个fin给客户端\",{\"1\":{\"18\":1}}],[\"发送一个\",{\"1\":{\"18\":1}}],[\"发送带有带有\",{\"1\":{\"15\":1}}],[\"发送带有\",{\"1\":{\"15\":2}}],[\"个人开发者一般用不到\",{\"1\":{\"217\":1}}],[\"个元素都要执行向后位\",{\"1\":{\"68\":1}}],[\"个元素之后的\",{\"1\":{\"68\":1}}],[\"个步骤\",{\"1\":{\"43\":1}}],[\"个消息\",{\"1\":{\"24\":1}}],[\"个\",{\"1\":{\"18\":1,\"64\":4}}],[\"用docker\",{\"1\":{\"219\":1}}],[\"用以指定dockerfile和参数\",{\"1\":{\"219\":1}}],[\"用以保持连接特性\",{\"1\":{\"30\":1}}],[\"用时分配是针对原本没有这个文件的场景\",{\"1\":{\"218\":1}}],[\"用时分配\",{\"1\":{\"218\":1}}],[\"用\",{\"1\":{\"217\":1}}],[\"用最少的资源做更多的事情\",{\"1\":{\"216\":1}}],[\"用层的方式画在一起\",{\"1\":{\"216\":1}}],[\"用的是具体的userservice对象\",{\"1\":{\"216\":1}}],[\"用队列求\",{\"0\":{\"214\":1}}],[\"用之前还要先做对数组的长度取模运算\",{\"1\":{\"79\":1}}],[\"用key来搜索的专家\",{\"1\":{\"67\":1}}],[\"用redis做过什么\",{\"1\":{\"64\":1}}],[\"用做同步监控的对象\",{\"1\":{\"64\":1}}],[\"用jprofiler等工具找出性能瓶颈\",{\"1\":{\"64\":1}}],[\"用过并发包的哪些类\",{\"1\":{\"64\":1}}],[\"用数据版本\",{\"1\":{\"64\":1}}],[\"用不着再做部署工作了\",{\"1\":{\"64\":1}}],[\"用途\",{\"1\":{\"64\":1,\"218\":1}}],[\"用红黑树管理timer\",{\"1\":{\"64\":1}}],[\"用红黑树管理进程控制块\",{\"1\":{\"64\":1}}],[\"用来存储容器信息\",{\"1\":{\"218\":1}}],[\"用来保存镜像\",{\"1\":{\"218\":1}}],[\"用来定义bean\",{\"1\":{\"216\":1}}],[\"用来加载classpath下springfactories中所定义的自动配置类\",{\"1\":{\"216\":1}}],[\"用来监听proyfacton创建代理对象完成事件\",{\"1\":{\"216\":1}}],[\"用来访问和设苦某个对象的某个三性\",{\"1\":{\"216\":1}}],[\"用来决定后续操作是消息重传还是继续发送\",{\"1\":{\"64\":1}}],[\"用来构造线程池里的worker线程\",{\"1\":{\"64\":1}}],[\"用来关闭客户端到服务器的数据传送\",{\"1\":{\"18\":1}}],[\"用于事务回滚\",{\"1\":{\"216\":1}}],[\"用于存储键值对数据\",{\"1\":{\"83\":1}}],[\"用于告诉客户端本次\",{\"1\":{\"51\":1}}],[\"用于指定客户端用于接受哪些类型的信息\",{\"1\":{\"51\":1}}],[\"用户可自定义网络配置\",{\"1\":{\"217\":1}}],[\"用户可根据服务端引导类serverbootstrap配置参数选择reactor线程模型\",{\"1\":{\"216\":1}}],[\"用户可根据启动参数配置在这三种模型之间切换\",{\"1\":{\"216\":1}}],[\"用户自定义加载器\",{\"1\":{\"64\":1}}],[\"用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机\",{\"1\":{\"41\":1}}],[\"用户数据报\",{\"1\":{\"10\":1}}],[\"用户数据协议\",{\"1\":{\"9\":1}}],[\"flush\",{\"1\":{\"219\":1}}],[\"flushdisktype\",{\"1\":{\"219\":1}}],[\"float\",{\"1\":{\"73\":2}}],[\"f参数\",{\"1\":{\"217\":1}}],[\"f0b1c8ab3633\",{\"1\":{\"217\":8}}],[\"f\",{\"1\":{\"217\":2,\"219\":19}}],[\"from指令用于指定基础镜像\",{\"1\":{\"218\":1}}],[\"from\",{\"1\":{\"216\":1,\"218\":4,\"219\":3,\"231\":2}}],[\"frr\",{\"1\":{\"26\":5}}],[\"f5等\",{\"1\":{\"64\":1}}],[\"ftp\",{\"1\":{\"64\":1}}],[\"filtered\",{\"1\":{\"216\":1}}],[\"filter\",{\"1\":{\"216\":1,\"219\":1}}],[\"filereservedtime\",{\"1\":{\"219\":1}}],[\"files\",{\"1\":{\"64\":1}}],[\"file\",{\"1\":{\"64\":9,\"219\":8}}],[\"filechannel\",{\"1\":{\"64\":1}}],[\"field\",{\"1\":{\"169\":1}}],[\"fist\",{\"1\":{\"75\":1}}],[\"final\",{\"1\":{\"73\":1,\"77\":1,\"94\":4}}],[\"finalize方法的实现原理\",{\"1\":{\"64\":1}}],[\"finalize\",{\"1\":{\"64\":1}}],[\"fin\",{\"1\":{\"18\":3}}],[\"future相关的\",{\"0\":{\"131\":1}}],[\"functionality\",{\"1\":{\"231\":1}}],[\"function\",{\"1\":{\"77\":1}}],[\"functions\",{\"1\":{\"64\":1}}],[\"fullgc减少\",{\"1\":{\"216\":1}}],[\"fullgc发生的时候是\",{\"1\":{\"64\":1}}],[\"fullgc发生的时候\",{\"1\":{\"64\":1}}],[\"full\",{\"1\":{\"64\":3}}],[\"found\",{\"1\":{\"255\":1}}],[\"follower节点收到commit命令后就会更新各自本地内存数据\",{\"1\":{\"216\":1}}],[\"follows\",{\"1\":{\"64\":1}}],[\"foo\",{\"1\":{\"64\":16}}],[\"force\",{\"1\":{\"219\":2}}],[\"foreach遍历底层也是通过iterator实现的\",{\"1\":{\"69\":1}}],[\"foreach\",{\"1\":{\"69\":1}}],[\"fork\",{\"1\":{\"64\":1}}],[\"forkjoinpool\",{\"1\":{\"64\":1}}],[\"forname和classloader的区别\",{\"1\":{\"64\":2}}],[\"forname\",{\"1\":{\"64\":1}}],[\"forname方式\",{\"1\":{\"64\":1}}],[\"for\",{\"1\":{\"1\":2,\"2\":2,\"3\":2,\"64\":2,\"69\":1,\"73\":1,\"87\":1,\"94\":1,\"231\":2}}],[\"fall\",{\"1\":{\"231\":1}}],[\"false\",{\"1\":{\"64\":2,\"96\":1}}],[\"factorybean\",{\"1\":{\"216\":1}}],[\"factories文件中添加自己的自动配置类\",{\"1\":{\"216\":1}}],[\"factories相当于springboot的spi机制\",{\"1\":{\"216\":1}}],[\"factories来实现自动配置类的加载\",{\"1\":{\"216\":1}}],[\"factories加载过程\",{\"1\":{\"64\":1}}],[\"factor\",{\"1\":{\"73\":2,\"77\":1}}],[\"facebook的thrift\",{\"1\":{\"64\":1}}],[\"fair\",{\"1\":{\"64\":1}}],[\"failed\",{\"1\":{\"64\":2}}],[\"failure\",{\"1\":{\"64\":3}}],[\"fastjson\",{\"1\":{\"64\":1}}],[\"fast\",{\"1\":{\"26\":1,\"217\":1}}],[\"证明发送方到接收方的通道没有问题\",{\"1\":{\"18\":1}}],[\"传统虚拟化技术是在硬件层面实现虚拟化\",{\"1\":{\"218\":1}}],[\"传统虚拟化和容器技术结构比较\",{\"1\":{\"218\":1}}],[\"传统的消息传递方法包括两种\",{\"1\":{\"64\":1}}],[\"传输\",{\"1\":{\"216\":1}}],[\"传输层和\",{\"1\":{\"216\":1}}],[\"传输控制协议\",{\"1\":{\"9\":1}}],[\"传给\",{\"1\":{\"216\":1}}],[\"传递保证语义\",{\"1\":{\"64\":1}}],[\"传引用值\",{\"1\":{\"64\":1}}],[\"传了\",{\"0\":{\"18\":1},\"1\":{\"18\":1}}],[\"它和系统安装光盘有点像\",{\"1\":{\"217\":1}}],[\"它包含创建\",{\"1\":{\"217\":1}}],[\"它可以接受用户命令和配置标识\",{\"1\":{\"217\":1}}],[\"它有很多选项\",{\"1\":{\"217\":1}}],[\"它有助于更快地交付应用\",{\"1\":{\"217\":1}}],[\"它有一个\",{\"1\":{\"85\":1}}],[\"它有一个保持时间\",{\"1\":{\"30\":1}}],[\"它也可以扩展\",{\"1\":{\"216\":1}}],[\"它注重的是一致性\",{\"1\":{\"216\":1}}],[\"它实际上是另外三个注解的组合\",{\"1\":{\"216\":1}}],[\"它实际上充当了一个翻译的角色\",{\"1\":{\"41\":1}}],[\"它才是幕后黑手\",{\"1\":{\"216\":1}}],[\"它们的区别在于\",{\"1\":{\"216\":1}}],[\"它们的底层实现都会使用aqs来进行排队\",{\"1\":{\"216\":1}}],[\"它们也不一定是相等的\",{\"1\":{\"75\":1}}],[\"它们可以通过静态属性的方式持有对象的引用\",{\"1\":{\"64\":1}}],[\"它要判断传入的list\",{\"1\":{\"69\":1}}],[\"它支持将字节从套接口转移到磁盘\",{\"1\":{\"64\":1}}],[\"它还执行其他活动\",{\"1\":{\"64\":1}}],[\"它都可以从之前提交的偏移量中获取\",{\"1\":{\"64\":1}}],[\"它被用于提交偏移量\",{\"1\":{\"64\":1}}],[\"它就不能服务客户端请求\",{\"1\":{\"64\":1}}],[\"它用于kafka的分布式应用\",{\"1\":{\"64\":1}}],[\"它用于指定接受的编码方式\",{\"1\":{\"51\":1}}],[\"它提供了容错保证和持久性\",{\"1\":{\"64\":1}}],[\"它提供了使用索引的随意访问\",{\"1\":{\"64\":1}}],[\"它传输的业务服从的协议多种多样\",{\"1\":{\"64\":1}}],[\"它的工作原理是\",{\"1\":{\"216\":1}}],[\"它的作用就是如果它认为一个key不存在\",{\"1\":{\"216\":1}}],[\"它的作用也是判断两个对象是否相等\",{\"1\":{\"96\":1}}],[\"它的作用是判断两个对象的地址是不是相等\",{\"1\":{\"96\":1}}],[\"它的作用是触发并忘记消息\",{\"1\":{\"64\":1}}],[\"它的实现new\",{\"1\":{\"64\":2}}],[\"它的功能少\",{\"1\":{\"64\":1}}],[\"它的基本原理就是每发完一个分组就停止发送\",{\"1\":{\"21\":1,\"23\":1}}],[\"它分为三个阶段\",{\"1\":{\"64\":1}}],[\"它按照插入顺序进行存储\",{\"1\":{\"64\":1}}],[\"它基本上完全依赖gc线程完成所有的内存管理\",{\"1\":{\"64\":1}}],[\"它并不会自己先去加载\",{\"1\":{\"64\":1}}],[\"它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置\",{\"1\":{\"64\":1}}],[\"它是用来存放那些没有成功消费的消息的\",{\"1\":{\"216\":1}}],[\"它是一个分布式的\",{\"1\":{\"64\":1}}],[\"它是一种全国家通过的一种编码\",{\"1\":{\"64\":1}}],[\"它是一种具体的\",{\"1\":{\"34\":1}}],[\"它是系统进行资源分配和调度的一个独立单位\",{\"1\":{\"64\":1}}],[\"它是如何把页面呈现到屏幕上的\",{\"1\":{\"57\":1}}],[\"它主要发生在客户端\",{\"1\":{\"49\":1}}],[\"它需要的只是处理他的请求\",{\"1\":{\"45\":1}}],[\"它不仅唯一标识资源\",{\"1\":{\"34\":1}}],[\"它允许只请求资源的某个部分\",{\"1\":{\"33\":1}}],[\"它则不能很有效地工作\",{\"1\":{\"26\":1}}],[\"它会破坏用户体验\",{\"1\":{\"57\":1}}],[\"它会对\",{\"1\":{\"53\":1}}],[\"它会假定确认件指出的数据段丢失了\",{\"1\":{\"26\":1}}],[\"它会立即给发送机发送一个重复确认\",{\"1\":{\"26\":1}}],[\"它能快速恢复丢失的数据包\",{\"1\":{\"26\":1}}],[\"它通常会重新发送\",{\"1\":{\"22\":1}}],[\"它通过使用确认和超时这两个机制\",{\"1\":{\"22\":1}}],[\"它启动一个定时器\",{\"1\":{\"21\":1}}],[\"它发回一\",{\"1\":{\"18\":1}}],[\"它表示确认发来的数据已经接受无误\",{\"1\":{\"17\":1}}],[\"它作为可以将域名和ip地址相互映射的一个分布式数据库\",{\"1\":{\"8\":1}}],[\"汉译\",{\"1\":{\"17\":1}}],[\"最佳实践中的原则编写\",{\"1\":{\"252\":1}}],[\"最佳实践前\",{\"1\":{\"231\":2}}],[\"最小化镜像层数\",{\"1\":{\"231\":1}}],[\"最小空闲连接数\",{\"1\":{\"219\":1}}],[\"最大连接数\",{\"1\":{\"219\":1}}],[\"最大线程数量设置值\",{\"1\":{\"64\":1}}],[\"最保险的机制就是消费者实现幂等性\",{\"1\":{\"216\":1}}],[\"最左前缀原则是什么\",{\"1\":{\"216\":1}}],[\"最左原则\",{\"0\":{\"154\":1}}],[\"最终到达服务器\",{\"1\":{\"216\":1}}],[\"最终定位到具体的问题\",{\"1\":{\"216\":1}}],[\"最终oom\",{\"1\":{\"64\":1}}],[\"最好\",{\"1\":{\"64\":1}}],[\"最好能将\",{\"1\":{\"32\":1}}],[\"最坏\",{\"1\":{\"64\":1}}],[\"最常⽤的docker\",{\"1\":{\"217\":1}}],[\"最常见的一个问题就是\",{\"1\":{\"64\":2}}],[\"最常用的就是利用\",{\"1\":{\"31\":1}}],[\"最常用的就是内存和数据库\",{\"1\":{\"31\":1}}],[\"最少活跃调用数\",{\"1\":{\"64\":1}}],[\"最流行的是基于\",{\"1\":{\"64\":1}}],[\"最为流行\",{\"1\":{\"64\":1}}],[\"最近在进行前端面试方面的一些准备\",{\"1\":{\"39\":1}}],[\"最后给出几个常用软件的官方\",{\"1\":{\"231\":1}}],[\"最后再强调一下\",{\"1\":{\"231\":1}}],[\"最后附一个查看容器资源使用情况的指令\",{\"1\":{\"218\":1}}],[\"最后将镜像推送到远程仓库\",{\"1\":{\"218\":1}}],[\"最后还失败则进入死信队列\",{\"1\":{\"216\":2}}],[\"最后一个节点的\",{\"1\":{\"70\":1}}],[\"最后\",{\"1\":{\"19\":1}}],[\"最后客户机再以\",{\"1\":{\"17\":1}}],[\"最初的目的是为了提供一种发布和接收\",{\"1\":{\"8\":1}}],[\"应该尽量避免使用\",{\"1\":{\"231\":1}}],[\"应该尽量遵循的原则\",{\"1\":{\"231\":1}}],[\"应该在\",{\"1\":{\"231\":1}}],[\"应该避免安装无用的软件包\",{\"1\":{\"231\":1}}],[\"应该要把设置的key\",{\"1\":{\"216\":1}}],[\"应答表示接收到了这个消息\",{\"1\":{\"17\":1}}],[\"应用程序需要\",{\"1\":{\"249\":1}}],[\"应用程序在需要把内核中的一块区域数据转移到另外一块内核区域去时\",{\"1\":{\"216\":1}}],[\"应用程序对于这种后果是无法预测的\",{\"1\":{\"64\":1}}],[\"应用名\",{\"1\":{\"216\":1}}],[\"应用级注册代表是把整个应用作为一个微服务注册到注册中心\",{\"1\":{\"216\":1}}],[\"应用\",{\"1\":{\"64\":1,\"217\":1}}],[\"应用java的反射技术\",{\"1\":{\"64\":1}}],[\"应用通常采用\",{\"1\":{\"52\":1}}],[\"应用数据被分割成\",{\"1\":{\"21\":1}}],[\"应用进程利用该服务传送应用层报文\",{\"1\":{\"9\":1}}],[\"应用层协议定义的是应用进程\",{\"1\":{\"8\":1}}],[\"应用层\",{\"0\":{\"8\":1},\"1\":{\"8\":1}}],[\"服务一旦扩容对应了多个容器\",{\"1\":{\"219\":1}}],[\"服务名\",{\"1\":{\"219\":2}}],[\"服务名就相当于hostname\",{\"1\":{\"219\":1}}],[\"服务名称是\",{\"1\":{\"219\":1}}],[\"服务\",{\"1\":{\"219\":1}}],[\"服务b调用c\",{\"1\":{\"216\":1}}],[\"服务熔断\",{\"1\":{\"216\":2}}],[\"服务网关\",{\"1\":{\"216\":3}}],[\"服务代理层\",{\"1\":{\"216\":1}}],[\"服务协议等等\",{\"1\":{\"216\":1}}],[\"服务超时时间\",{\"1\":{\"216\":1}}],[\"服务接口透明代理\",{\"1\":{\"216\":1}}],[\"服务接口是什么\",{\"1\":{\"216\":1}}],[\"服务接口\",{\"1\":{\"216\":1}}],[\"服务重试等功能也要一步步丰满起来了\",{\"1\":{\"216\":1}}],[\"服务路由\",{\"1\":{\"216\":1}}],[\"服务容错\",{\"1\":{\"216\":1}}],[\"服务上线怎么不影响旧版本\",{\"1\":{\"64\":1}}],[\"服务失效踢出基于zookeeper的临时节点原理\",{\"1\":{\"64\":1}}],[\"服务提供者能实现失效踢出是什么原理\",{\"1\":{\"64\":1}}],[\"服务提供方和调用方的依赖只依靠一纸契约\",{\"1\":{\"64\":1}}],[\"服务调用是阻塞的吗\",{\"1\":{\"64\":1}}],[\"服务器公网ip\",{\"1\":{\"223\":1}}],[\"服务器需要支持超大量的长时间连接\",{\"1\":{\"64\":1}}],[\"服务器返回给浏览器的文本信息\",{\"1\":{\"56\":1}}],[\"服务器未能实现合法的请求\",{\"1\":{\"54\":1}}],[\"服务器端并发执行\",{\"1\":{\"64\":2}}],[\"服务器端错误\",{\"1\":{\"54\":1}}],[\"服务器端收到\",{\"1\":{\"47\":1}}],[\"服务器有\",{\"1\":{\"53\":1}}],[\"服务器去进行\",{\"1\":{\"53\":1}}],[\"服务器会返回一个跟用户最接近的点的\",{\"1\":{\"45\":1}}],[\"服务器会在一定时间内保存这个\",{\"1\":{\"31\":1}}],[\"服务器缓存\",{\"1\":{\"44\":1}}],[\"服务器处理请求并返回\",{\"0\":{\"53\":1},\"1\":{\"39\":1}}],[\"服务器处理请求并返回http报文\",{\"1\":{\"27\":1}}],[\"服务器\",{\"1\":{\"18\":2}}],[\"服务器使用\",{\"1\":{\"17\":1}}],[\"服务端启动时\",{\"1\":{\"216\":1}}],[\"服务端并发限流\",{\"1\":{\"64\":1}}],[\"服务端给特定的用户创建特定的\",{\"1\":{\"31\":1,\"32\":1}}],[\"服务端\",{\"1\":{\"15\":3}}],[\"客户机首先发出一个\",{\"1\":{\"17\":1}}],[\"客户端你可以不发数据了\",{\"1\":{\"216\":1}}],[\"客户端不需要连接集群所有节点\",{\"1\":{\"64\":1}}],[\"客户端不一定特指浏览器\",{\"1\":{\"51\":1}}],[\"客户端与redis节点直连\",{\"1\":{\"64\":1}}],[\"客户端并发限流\",{\"1\":{\"64\":1}}],[\"客户端工具\",{\"1\":{\"59\":1}}],[\"客户端错误\",{\"1\":{\"54\":1}}],[\"客户端测试工具等\",{\"1\":{\"51\":1}}],[\"客户端再次访问这个服务器时\",{\"1\":{\"30\":1}}],[\"客户端和服务器端都无法验证对方的身份\",{\"1\":{\"35\":1}}],[\"客户端和服务器之间用于传输http数据的tcp连接不会关闭\",{\"1\":{\"30\":1}}],[\"客户端和服务器每进行一次http操作\",{\"1\":{\"30\":1}}],[\"客户端\",{\"1\":{\"15\":3,\"18\":2}}],[\"我想这也是要尽量用exec的原因是吗\",{\"1\":{\"246\":1}}],[\"我想在官方的\",{\"1\":{\"231\":1}}],[\"我应该怎么写\",{\"1\":{\"242\":1}}],[\"我更推荐你使用copy指令\",{\"1\":{\"231\":1}}],[\"我什么时候应该使用entrypoint\",{\"1\":{\"231\":1}}],[\"我并不需要安装\",{\"1\":{\"231\":1}}],[\"我和某人共同关注的人\",{\"1\":{\"216\":1}}],[\"我个人认为\",{\"1\":{\"216\":1}}],[\"我会专门写一篇文章来讲解innodb中索引的具体实现\",{\"1\":{\"216\":2}}],[\"我举这个例子想告诉大家的是\",{\"1\":{\"216\":1}}],[\"我相信大部分人都能够想到先排序\",{\"1\":{\"216\":1}}],[\"我这边没怎么问\",{\"0\":{\"146\":1}}],[\"我觉得还是和底层数据结构有关\",{\"1\":{\"69\":1}}],[\"我的mysql死锁排查过程\",{\"1\":{\"64\":1}}],[\"我的理解是\",{\"1\":{\"58\":1}}],[\"我要做什么事情\",{\"1\":{\"64\":2}}],[\"我么可以这么理解ioc容器\",{\"1\":{\"64\":1}}],[\"我使用过的\",{\"1\":{\"53\":1}}],[\"我不知道把\",{\"1\":{\"47\":1}}],[\"我平时使用的比较多的是七牛云的\",{\"1\":{\"45\":1}}],[\"我们再来具体了解下这些原则落实到具体的\",{\"1\":{\"231\":1}}],[\"我们再聊一下我们平时书写\",{\"1\":{\"231\":1}}],[\"我们从\",{\"1\":{\"231\":1}}],[\"我们想要定义一些环境变量并且安装一些软件包\",{\"1\":{\"231\":1}}],[\"我们还以此项目为例测试\",{\"1\":{\"219\":1}}],[\"我们还得写\",{\"1\":{\"216\":1}}],[\"我们首先通过一个示例快速入门\",{\"1\":{\"219\":1}}],[\"我们首先可能会想到采用\",{\"1\":{\"79\":1}}],[\"我们登录到docker镜像查看下刚刚推送的镜像\",{\"1\":{\"218\":1}}],[\"我们制作好了微服务镜像\",{\"1\":{\"218\":1}}],[\"我们这里以centos为例\",{\"1\":{\"217\":1}}],[\"我们可使⽤docker命令下载并使⽤\",{\"1\":{\"217\":1}}],[\"我们可以把不轻易改变的指令放到\",{\"1\":{\"231\":1}}],[\"我们可以使用\",{\"1\":{\"231\":1}}],[\"我们可以选择自建镜像仓库\",{\"1\":{\"218\":1}}],[\"我们可以借助阿里云的镜像加速器\",{\"1\":{\"217\":1}}],[\"我们可以结合实际请求\",{\"1\":{\"216\":1}}],[\"我们可以通过数据库的主键\",{\"1\":{\"216\":1}}],[\"我们可以通过直接使用某个服务接口的代理对象来执行方法\",{\"1\":{\"216\":1}}],[\"我们可以总结得出\",{\"1\":{\"216\":1}}],[\"我们可以先对这个表里的数据进行排序\",{\"1\":{\"216\":1}}],[\"我们可以重写compareto\",{\"1\":{\"85\":1}}],[\"我们可以在没有zookeeper的情况下使用kafka吗\",{\"1\":{\"64\":1}}],[\"我们可以参考一下来自bytebuddy的数据\",{\"1\":{\"64\":1}}],[\"我们通常会需要一个唯一id来标识数据\",{\"1\":{\"216\":1}}],[\"我们通常使用下面的语句来创建一个索引\",{\"1\":{\"216\":1}}],[\"我们的代码量以及代码复杂度是要高很多的\",{\"1\":{\"216\":1}}],[\"我们自己来控制比交给spring来控制\",{\"1\":{\"216\":1}}],[\"我们要做的仅仅是定义类\",{\"1\":{\"216\":1}}],[\"我们用spring\",{\"1\":{\"216\":1}}],[\"我们用下面三行数据来模拟一下\",{\"1\":{\"216\":1}}],[\"我们也知道\",{\"1\":{\"216\":1}}],[\"我们也可以看出来\",{\"1\":{\"216\":1}}],[\"我们需要在docke官方镜像仓库里注册一个账号\",{\"1\":{\"218\":1}}],[\"我们需要做什么\",{\"1\":{\"216\":1}}],[\"我们需要查询所有8行数据最终确定a=3\",{\"1\":{\"216\":1}}],[\"我们先来解决第一个问题\",{\"1\":{\"216\":1}}],[\"我们认为spring有两大特性ioc和aop\",{\"1\":{\"216\":1}}],[\"我们一般会根据计算机的核心数来设置线程数\",{\"1\":{\"216\":1}}],[\"我们花了较大篇幅介绍了升序索引的实现原理\",{\"1\":{\"216\":1}}],[\"我们对某个表创建一个索引\",{\"1\":{\"216\":1}}],[\"我们只需要查3次了\",{\"1\":{\"216\":1}}],[\"我们只关心key\",{\"1\":{\"216\":1}}],[\"我们应该使用哪个命令向容器里添加文件呢\",{\"1\":{\"231\":1}}],[\"我们应该保持良好的代码编写习惯\",{\"1\":{\"231\":1}}],[\"我们应该根据哪些字段来确定这个顺序呢\",{\"1\":{\"216\":1}}],[\"我们应该避免在经常被执行的代码或对性能要求很高的程\",{\"1\":{\"64\":1}}],[\"我们现在想对这些数据行进行排序\",{\"1\":{\"216\":1}}],[\"我们如果想提高这个表的查询速度\",{\"1\":{\"216\":1}}],[\"我们就只需要查4次就好了\",{\"1\":{\"216\":1}}],[\"我们就可以利用比如二分法等等算法来提高这个数列的查询速度了\",{\"1\":{\"216\":1}}],[\"我们就要重写compareto\",{\"1\":{\"85\":1}}],[\"我们使用dockerfile为项目microservice\",{\"1\":{\"219\":1}}],[\"我们使用以下sql查看一下索引信息\",{\"1\":{\"216\":1}}],[\"我们使用的教材是\",{\"1\":{\"36\":1}}],[\"我们分别使用mysql7\",{\"1\":{\"216\":1}}],[\"我们都知道\",{\"1\":{\"216\":1}}],[\"我们都覆盖\",{\"1\":{\"96\":1}}],[\"我们都是通过在\",{\"1\":{\"31\":1}}],[\"我们上面也讲到了过了\",{\"1\":{\"79\":1}}],[\"我们将offset和消息处理结果放在一个事务中\",{\"1\":{\"64\":1}}],[\"我们知道线程池的作用就是提高线程的利用率\",{\"1\":{\"216\":1}}],[\"我们知道\",{\"1\":{\"64\":1,\"216\":1}}],[\"我们在microservice\",{\"1\":{\"219\":1}}],[\"我们在用spring的时候\",{\"1\":{\"216\":1}}],[\"我们在编写对象的时候\",{\"1\":{\"64\":1}}],[\"我们在项目中是否要避免使用反射\",{\"1\":{\"64\":2}}],[\"我们系统是如何支撑大量的请求的\",{\"1\":{\"64\":2}}],[\"我们称之为\",{\"1\":{\"64\":2}}],[\"我们回到一个更原始的问题\",{\"1\":{\"58\":1}}],[\"我们把应用层交互的数据单元称为报文\",{\"1\":{\"8\":1}}],[\"我说完了\",{\"1\":{\"19\":1}}],[\"我知道了\",{\"1\":{\"19\":1}}],[\"我没啥要说的了\",{\"1\":{\"19\":1}}],[\"我接收到的信息确实就是你所发送的信号了\",{\"1\":{\"17\":1}}],[\"第四层交换功能就象是虚ip\",{\"1\":{\"64\":1}}],[\"第四层交换使用第三层和第四层信息包的报头信息\",{\"1\":{\"64\":1}}],[\"第三方库\",{\"1\":{\"64\":1}}],[\"第三种\",{\"1\":{\"64\":1}}],[\"第三次握手\",{\"1\":{\"16\":1}}],[\"第二个命令是先创建一个\",{\"1\":{\"247\":1}}],[\"第二个就是\",{\"1\":{\"64\":1}}],[\"第二版\",{\"1\":{\"75\":1}}],[\"第二台机器很慢\",{\"1\":{\"64\":1}}],[\"第二种代表我们只能使用两个参数版的\",{\"1\":{\"85\":1}}],[\"第二种\",{\"1\":{\"64\":1}}],[\"第二次握手\",{\"1\":{\"16\":1}}],[\"第一个命令相当于在容器主进程下执行命令\",{\"1\":{\"247\":1}}],[\"第一个就是\",{\"1\":{\"64\":1}}],[\"第一个数字定义了响应的类别\",{\"1\":{\"54\":1}}],[\"第一种为cmd\",{\"1\":{\"231\":1}}],[\"第一种\",{\"1\":{\"64\":1}}],[\"第一次握手\",{\"1\":{\"16\":1}}],[\"自旋锁是线程通过cas获取预期的一个标记\",{\"1\":{\"216\":1}}],[\"自旋锁就是线程在获取锁的过程中\",{\"1\":{\"216\":1}}],[\"自旋锁\",{\"0\":{\"117\":1}}],[\"自平衡的排序二叉树\",{\"1\":{\"89\":1,\"90\":1}}],[\"自动配置类其实就是spring的配置类\",{\"1\":{\"216\":1}}],[\"自动抓取等功能\",{\"1\":{\"64\":1}}],[\"自动重传请求\",{\"1\":{\"22\":1,\"23\":1}}],[\"自带线程池的各种坑\",{\"1\":{\"64\":1}}],[\"自定义类加载器\",{\"1\":{\"64\":2}}],[\"自定义spring\",{\"1\":{\"64\":3}}],[\"自定义一个注解\",{\"1\":{\"64\":1}}],[\"自然而然这部分对应的就是后端工程师眼中的\",{\"1\":{\"53\":1}}],[\"自己来给对象中的属性赋值\",{\"1\":{\"216\":1}}],[\"自己不得不实现之外\",{\"1\":{\"74\":1}}],[\"自己从classload\",{\"1\":{\"64\":1}}],[\"自己写的string\",{\"1\":{\"64\":1}}],[\"自己发送的请求正在被处理了\",{\"1\":{\"216\":1}}],[\"自己发送\",{\"1\":{\"16\":3}}],[\"自己接收正常\",{\"1\":{\"16\":2}}],[\"自上而下地\",{\"1\":{\"7\":1}}],[\"确保\",{\"1\":{\"217\":1}}],[\"确保数据及时传送\",{\"1\":{\"10\":1}}],[\"确定哪个节点是leader\",{\"1\":{\"216\":1}}],[\"确实很美\",{\"1\":{\"64\":1}}],[\"确是一种最有效的工作方式\",{\"1\":{\"20\":1}}],[\"确认消息在传输过程中迟到\",{\"1\":{\"23\":1}}],[\"确认消息在传输过程丢失\",{\"1\":{\"23\":1}}],[\"确认迟到\",{\"1\":{\"23\":1}}],[\"确认丢失\",{\"1\":{\"23\":1}}],[\"确认丢失和确认迟到\",{\"1\":{\"23\":1}}],[\"确认\",{\"1\":{\"23\":1}}],[\"确认序号为收到的序号加1\",{\"1\":{\"18\":1}}],[\"确认字符\",{\"1\":{\"17\":1}}],[\"确认了\",{\"1\":{\"16\":4}}],[\"确认了对方发送正常\",{\"1\":{\"16\":1}}],[\"为例\",{\"1\":{\"231\":1}}],[\"为后缀的任意文件\",{\"1\":{\"231\":1}}],[\"为准\",{\"1\":{\"219\":1}}],[\"为统一接口\",{\"1\":{\"216\":1}}],[\"为中心\",{\"1\":{\"216\":9}}],[\"为\",{\"1\":{\"216\":1,\"217\":1}}],[\"为队列\",{\"1\":{\"216\":1}}],[\"为宝为nre时\",{\"1\":{\"216\":1}}],[\"为啥分有界和无界\",{\"0\":{\"119\":1}}],[\"为啥还要传\",{\"0\":{\"18\":1}}],[\"为一个引用\",{\"1\":{\"96\":1}}],[\"为每个消息添加一个全局唯一主键\",{\"1\":{\"64\":1}}],[\"为何安全\",{\"1\":{\"64\":1}}],[\"为何不安全\",{\"1\":{\"64\":1}}],[\"为所有的原始类型\",{\"1\":{\"64\":1}}],[\"为什么以下两个命令输出的结果不一样呢\",{\"1\":{\"246\":1}}],[\"为什么基础底层镜像不使用alpine呢\",{\"1\":{\"244\":1}}],[\"为什么推荐exec模式\",{\"1\":{\"236\":1}}],[\"为什么mysql使用b+树\",{\"1\":{\"216\":1}}],[\"为什么zookeeper可以用来作为注册中心\",{\"1\":{\"216\":1}}],[\"为什么不推荐使用\",{\"1\":{\"216\":1}}],[\"为什么不把基本类型放堆中呢\",{\"1\":{\"64\":2}}],[\"为什么过半机制中是大于\",{\"1\":{\"216\":1}}],[\"为什么是200\",{\"1\":{\"216\":1}}],[\"为什么是异步非阻塞\",{\"1\":{\"64\":1}}],[\"为什么呢\",{\"1\":{\"69\":1}}],[\"为什么你的项目还在用\",{\"1\":{\"64\":1}}],[\"为什么jdk8用metaspace数据结构用来替代perm\",{\"1\":{\"64\":1}}],[\"为什么他是同步的且效率高\",{\"1\":{\"64\":1}}],[\"为什么会有多种\",{\"1\":{\"64\":3}}],[\"为什么\",{\"1\":{\"64\":2}}],[\"为什么有两种请求方式\",{\"1\":{\"43\":1}}],[\"为什么要反转\",{\"1\":{\"216\":1}}],[\"为什么要用arraylist取代vector呢\",{\"0\":{\"71\":1}}],[\"为什么要用线程池\",{\"1\":{\"64\":1}}],[\"为什么要把堆和栈区分出来呢\",{\"1\":{\"64\":1}}],[\"为什么要使用两种方式呢\",{\"1\":{\"64\":1}}],[\"为什么要使用\",{\"1\":{\"64\":1}}],[\"为什么要使用线程池\",{\"1\":{\"64\":1}}],[\"为什么要创建线程池\",{\"1\":{\"64\":2}}],[\"为什么要四次挥手\",{\"0\":{\"19\":1}}],[\"为什么要传回\",{\"0\":{\"17\":1}}],[\"为什么要三次握手\",{\"0\":{\"16\":1}}],[\"为了使构建过程更加清晰明了\",{\"1\":{\"231\":1}}],[\"为了简单起见将\",{\"1\":{\"219\":1}}],[\"为了保护系统\",{\"1\":{\"216\":1}}],[\"为了保证数据的高可用性\",{\"1\":{\"64\":1}}],[\"为了能让\",{\"1\":{\"79\":1}}],[\"为了精确地获得kafka的消息\",{\"1\":{\"64\":1}}],[\"为了实现消费者的\",{\"1\":{\"64\":1}}],[\"为了实现\",{\"1\":{\"64\":1}}],[\"为了实现委托模型\",{\"1\":{\"64\":1}}],[\"为了提高效率\",{\"1\":{\"64\":1}}],[\"为了避免新生代晋升到老年代失败\",{\"1\":{\"64\":1}}],[\"为了方便用户\",{\"1\":{\"42\":1}}],[\"为了安全考虑\",{\"1\":{\"32\":1}}],[\"为了进行拥塞控制\",{\"1\":{\"26\":1}}],[\"为了准确无误地把数据送达目标处\",{\"1\":{\"14\":1}}],[\"二维表格模型\",{\"1\":{\"64\":1}}],[\"二叉树的遍历算法\",{\"1\":{\"64\":1}}],[\"二者的区别\",{\"1\":{\"64\":1}}],[\"二\",{\"1\":{\"64\":8,\"216\":1}}],[\"二次握手\",{\"1\":{\"15\":1}}],[\"二字已经不是我们通常谈到的具体网络\",{\"1\":{\"10\":1}}],[\"一种内存压测工具\",{\"1\":{\"231\":1}}],[\"一直广受瞩目\",{\"1\":{\"217\":1}}],[\"一直打开\",{\"1\":{\"64\":1}}],[\"一页就是b+树中的一个节点\",{\"1\":{\"216\":1}}],[\"一页一页的往下走\",{\"1\":{\"170\":1}}],[\"一开始都会投票给自己\",{\"1\":{\"216\":1}}],[\"一起提交到数据库存入本地消息表\",{\"1\":{\"216\":1}}],[\"一切问题如果能直接用算法解决\",{\"1\":{\"216\":1}}],[\"一并返回给\",{\"1\":{\"216\":1}}],[\"一倍入风\",{\"1\":{\"216\":1}}],[\"一千万的用户实时排名如何实现\",{\"1\":{\"64\":1}}],[\"一旦进入了容器\",{\"1\":{\"217\":1}}],[\"一旦改票就会告诉给其他服务器\",{\"1\":{\"216\":1}}],[\"一旦redis中的数据出现了不一致\",{\"1\":{\"216\":1}}],[\"一旦数字被减为0\",{\"1\":{\"216\":1}}],[\"一旦没竞争到锁\",{\"1\":{\"216\":1}}],[\"一旦内存不足\",{\"1\":{\"64\":1}}],[\"一旦zookeeper停止工作\",{\"1\":{\"64\":1}}],[\"一旦系统内部引发类似致命异常\",{\"1\":{\"64\":1}}],[\"一组用户可以从服务器中读取消息\",{\"1\":{\"64\":1}}],[\"一方面\",{\"1\":{\"217\":1}}],[\"一方面是因为这个代码库已经渐趋稳定\",{\"1\":{\"64\":1}}],[\"一方面这种共享提供了一种有效的数据交互方式\",{\"1\":{\"64\":1}}],[\"一些额外的信息\",{\"1\":{\"216\":1}}],[\"一些\",{\"1\":{\"91\":1}}],[\"一些为处理异常预留的对象\",{\"1\":{\"64\":1}}],[\"一些重要的异常处理类\",{\"1\":{\"64\":1}}],[\"一些大型社区使用了这样的架构\",{\"1\":{\"64\":1}}],[\"一定要注意控制并发的任务数\",{\"1\":{\"64\":1}}],[\"一定成功\",{\"1\":{\"64\":1}}],[\"一定时间内存活对象和销毁对象一起统计\",{\"1\":{\"64\":1}}],[\"一致性\",{\"1\":{\"64\":2}}],[\"一棵自平衡的排序二叉树\",{\"1\":{\"64\":1}}],[\"一次业务处理可能需要多个应用来实现\",{\"1\":{\"216\":1}}],[\"一次性安全发布\",{\"1\":{\"64\":1}}],[\"一次握手\",{\"1\":{\"15\":1}}],[\"一\",{\"1\":{\"64\":6,\"216\":1}}],[\"一般推荐写成\",{\"1\":{\"243\":1}}],[\"一般称为exec模式\",{\"1\":{\"231\":1}}],[\"一般mysql服务可以这么设置\",{\"1\":{\"219\":1}}],[\"一般就是docker\",{\"1\":{\"218\":1}}],[\"一般需要发布到镜像仓库供别人使用\",{\"1\":{\"218\":1}}],[\"一般需要配置docker镜像加速器\",{\"1\":{\"217\":1}}],[\"一般默认值代表大多数情况\",{\"1\":{\"216\":1}}],[\"一般\",{\"1\":{\"96\":1}}],[\"一般我们需要对一个集合使用自定义排序时\",{\"1\":{\"85\":1}}],[\"一般应用是很难出现碰撞的\",{\"1\":{\"79\":1}}],[\"一般使用什么注册中心\",{\"1\":{\"64\":1}}],[\"一般都需要考虑线程同步\",{\"1\":{\"64\":1}}],[\"一般来说\",{\"1\":{\"64\":1}}],[\"一般是通过为数据库表增加一个数字类型的\",{\"1\":{\"64\":1}}],[\"一般的复制使用statement模式保存binlog\",{\"1\":{\"64\":1}}],[\"一般cpu核心数\",{\"1\":{\"64\":1}}],[\"一般cpu核心数+1\",{\"1\":{\"64\":1}}],[\"一般用来保存用户信息\",{\"1\":{\"32\":1}}],[\"一般用于文件传输\",{\"1\":{\"20\":1}}],[\"一般用于即时通信\",{\"1\":{\"20\":1}}],[\"一般情况下是扫描不到这些自动配置的\",{\"1\":{\"216\":1}}],[\"一般情况下由自定义的类加载器加载的类不能成为gc\",{\"1\":{\"64\":1}}],[\"一般情况下\",{\"1\":{\"31\":1,\"231\":1}}],[\"一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解\",{\"1\":{\"29\":1}}],[\"一个建议的\",{\"1\":{\"231\":1}}],[\"一个容器代表一个进程\",{\"1\":{\"231\":1}}],[\"一个服务对应了多个容器\",{\"1\":{\"219\":1}}],[\"一个服务可包括多个容器实例\",{\"1\":{\"219\":1}}],[\"一个工程可包含多个服务\",{\"1\":{\"219\":1}}],[\"一个目录在下层\",{\"1\":{\"218\":1}}],[\"一个主键占8b\",{\"1\":{\"216\":1}}],[\"一个主节点对应一个或多个从节点\",{\"1\":{\"64\":1}}],[\"一个innodb页默认16kb\",{\"1\":{\"216\":1}}],[\"一个分布式系统对外要保证可用\",{\"1\":{\"216\":1}}],[\"一个分布式系统中各个结点之间能及时的同步数据\",{\"1\":{\"216\":1}}],[\"一个分布式系统是必须要保证分区容错性的\",{\"1\":{\"216\":1}}],[\"一个系统虽然是分布式的\",{\"1\":{\"216\":1}}],[\"一个数据库连接一个事务\",{\"1\":{\"216\":1}}],[\"一个数组的倒序\",{\"1\":{\"64\":1}}],[\"一个tomcat\",{\"1\":{\"216\":1}}],[\"一个tomcat中可以部署多个应用\",{\"1\":{\"216\":1}}],[\"一个库存系统中可能也存在com\",{\"1\":{\"216\":1}}],[\"一个检snaaca\",{\"1\":{\"216\":1}}],[\"一个线程调用countdownlatch的await\",{\"1\":{\"216\":1}}],[\"一个线程持有一个连接\",{\"1\":{\"216\":1}}],[\"一个线程只能属于一个进程\",{\"1\":{\"64\":1}}],[\"一个rpc框架就是一个能支持调用远程方法的框架\",{\"1\":{\"216\":1}}],[\"一个next指向后一个节点\",{\"1\":{\"70\":1}}],[\"一个prev指向前一个节点\",{\"1\":{\"70\":1}}],[\"一个web应用的性能瓶颈一般有哪些呢\",{\"1\":{\"64\":1}}],[\"一个是jdk原生代码\",{\"1\":{\"64\":1}}],[\"一个是实现有序集合键\",{\"1\":{\"64\":1}}],[\"一个对象只对应了一个4btye的引用\",{\"1\":{\"64\":1}}],[\"一个对象的大小是不可估计的\",{\"1\":{\"64\":1}}],[\"一个对象是否可以同时访问\",{\"1\":{\"64\":1}}],[\"一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性\",{\"1\":{\"64\":1}}],[\"一个事务给某行数据加了写锁\",{\"1\":{\"216\":1}}],[\"一个事务给某行数据加了读锁\",{\"1\":{\"216\":1}}],[\"一个事务读到了另一个事务已经提交的\",{\"1\":{\"64\":2}}],[\"一个事务读到了另一个事务的未提交的数据\",{\"1\":{\"64\":1}}],[\"一个事务执行的过程中\",{\"1\":{\"64\":1}}],[\"一个网页平常很快\",{\"0\":{\"63\":1}}],[\"一个\",{\"1\":{\"18\":1,\"83\":2,\"217\":1,\"218\":1}}],[\"一个公司的\",{\"1\":{\"8\":1}}],[\"一样\",{\"1\":{\"18\":1}}],[\"简洁明了\",{\"1\":{\"231\":1}}],[\"简化程序\",{\"1\":{\"217\":1}}],[\"简单来说就是如果第n层有改动\",{\"1\":{\"239\":1}}],[\"简单来说就是数据的发送与接收\",{\"1\":{\"16\":1}}],[\"简单的来说\",{\"1\":{\"94\":1}}],[\"简单的介绍一下自己的工作经历与职责\",{\"1\":{\"64\":1}}],[\"简单谈谈堆外内存以及你的理解和认识\",{\"1\":{\"64\":1}}],[\"简单\",{\"1\":{\"23\":1,\"64\":3}}],[\"简单示意图\",{\"1\":{\"15\":1}}],[\"简称\",{\"1\":{\"10\":1}}],[\"图灵商城公共配置\",{\"1\":{\"219\":1}}],[\"图灵课堂\",{\"1\":{\"216\":7}}],[\"图中\",{\"1\":{\"217\":1}}],[\"图\",{\"1\":{\"64\":1}}],[\"图片是最消耗资源的\",{\"1\":{\"64\":1}}],[\"图片服务器分离\",{\"1\":{\"64\":1}}],[\"图片等文件就放在这一部分\",{\"1\":{\"56\":1}}],[\"图片来源\",{\"1\":{\"13\":1,\"15\":1,\"27\":1,\"29\":1,\"81\":1}}],[\"图像文件\",{\"1\":{\"30\":1}}],[\"图解\",{\"1\":{\"27\":1}}],[\"图解http\",{\"1\":{\"15\":1,\"27\":1,\"29\":1,\"36\":1}}],[\"ben\",{\"0\":{\"233\":1}}],[\"be\",{\"1\":{\"231\":1}}],[\"bean注解的方法进行解析\",{\"1\":{\"216\":1}}],[\"bean注解\",{\"1\":{\"216\":1}}],[\"beannamegenerato\",{\"1\":{\"216\":1}}],[\"beanname生成器\",{\"1\":{\"216\":1}}],[\"beanwrapper\",{\"1\":{\"216\":1}}],[\"beanfactoryaspecuadvisorsbuilder\",{\"1\":{\"216\":1}}],[\"beanfactory\",{\"1\":{\"216\":1}}],[\"beanfactory是spring中非常核心的组件\",{\"1\":{\"216\":1}}],[\"beanfactory以及applicationcontext\",{\"0\":{\"127\":1}}],[\"bean的作用域只是表示bean的生命周期范围\",{\"1\":{\"216\":1}}],[\"bean的作用域和生命周期\",{\"1\":{\"64\":2}}],[\"bean是不是线程安全\",{\"1\":{\"216\":1}}],[\"beandefinitionbuilder\",{\"1\":{\"216\":1}}],[\"beandefinition构造芸\",{\"1\":{\"216\":1}}],[\"beandefinitionmapsbeanna\",{\"1\":{\"216\":1}}],[\"beandehinition\",{\"1\":{\"216\":1}}],[\"bean定义dsl\",{\"1\":{\"64\":2}}],[\"bean\",{\"1\":{\"64\":1}}],[\"btrfs和zfs等\",{\"1\":{\"218\":1}}],[\"b树的特点\",{\"1\":{\"216\":1}}],[\"b树和b+树的区别\",{\"1\":{\"216\":1}}],[\"b滑动窗口算法\",{\"1\":{\"216\":1}}],[\"b再创建订单\",{\"1\":{\"216\":2}}],[\"b再次收到该消息后采取以下两点措施\",{\"1\":{\"23\":1}}],[\"b类里也有一个属性c\",{\"1\":{\"216\":1}}],[\"bundle\",{\"1\":{\"219\":2}}],[\"buildno\",{\"1\":{\"219\":1}}],[\"build会重新构建镜像\",{\"1\":{\"219\":1}}],[\"build命令构建镜像\",{\"1\":{\"218\":1}}],[\"build\",{\"1\":{\"218\":3,\"219\":17}}],[\"build等都是\",{\"1\":{\"217\":1}}],[\"buffer的写命令\",{\"1\":{\"216\":1}}],[\"buffer中的写命令\",{\"1\":{\"216\":1}}],[\"buffer记录的写命令\",{\"1\":{\"216\":1}}],[\"buffer记录在这个过程中接收到的写命令\",{\"1\":{\"216\":1}}],[\"bufferpoolsize等缓存区来提高吞吐量\",{\"1\":{\"216\":1}}],[\"but\",{\"1\":{\"216\":1}}],[\"bubblesort\",{\"1\":{\"1\":1}}],[\"b如果该位置下的元素个数超过了8\",{\"1\":{\"216\":1}}],[\"bridge\",{\"1\":{\"219\":1}}],[\"brain\",{\"1\":{\"216\":1}}],[\"browser\",{\"1\":{\"92\":1}}],[\"brokerip1=192\",{\"1\":{\"219\":1}}],[\"brokerid\",{\"1\":{\"219\":1}}],[\"brokerrole\",{\"1\":{\"219\":1}}],[\"brokername\",{\"1\":{\"219\":1}}],[\"broker接收到ack后才会删除消息\",{\"1\":{\"216\":1}}],[\"broker中获得补偿\",{\"1\":{\"64\":1}}],[\"broker将完成剩下的工作\",{\"1\":{\"64\":1}}],[\"broker什么时候离开isr\",{\"1\":{\"64\":1}}],[\"broker\",{\"1\":{\"64\":1,\"219\":6}}],[\"broker术语用于引用服务器\",{\"1\":{\"64\":1}}],[\"b+树的特点\",{\"1\":{\"216\":1}}],[\"b+树\",{\"1\":{\"216\":1}}],[\"bcd的三行记录\",{\"1\":{\"216\":1}}],[\"bcd\",{\"1\":{\"216\":6}}],[\"b方法没有使用\",{\"0\":{\"137\":1}}],[\"bb\",{\"1\":{\"96\":2}}],[\"b为另一个引用\",{\"1\":{\"96\":1}}],[\"bossgroup负责处理客户端的连接请求\",{\"1\":{\"216\":1}}],[\"bounded\",{\"1\":{\"77\":1}}],[\"boolean\",{\"1\":{\"64\":1}}],[\"boolean类型除外\",{\"1\":{\"64\":1}}],[\"bootstrap\",{\"1\":{\"219\":1}}],[\"boot缓存实战\",{\"1\":{\"64\":1}}],[\"boot设置有效时间和自动刷新缓存\",{\"1\":{\"64\":1}}],[\"boot\",{\"1\":{\"64\":7}}],[\"boot比spring做了哪些改进\",{\"1\":{\"64\":2}}],[\"bio\",{\"1\":{\"216\":1}}],[\"bit\",{\"1\":{\"77\":1}}],[\"bin\",{\"1\":{\"217\":2,\"218\":1,\"223\":1,\"225\":1,\"231\":3}}],[\"binarysearch\",{\"1\":{\"69\":2}}],[\"binlog的格式也有三种\",{\"1\":{\"64\":1}}],[\"by是不是就没有办法利用b\",{\"1\":{\"216\":1}}],[\"by是order\",{\"1\":{\"216\":1}}],[\"by语句可以直接使用已经排好序的数据了\",{\"1\":{\"216\":1}}],[\"by也是管用的\",{\"1\":{\"216\":1}}],[\"byte\",{\"1\":{\"94\":2}}],[\"by\",{\"1\":{\"77\":1,\"216\":5}}],[\"bfs算法\",{\"1\":{\"64\":1}}],[\"block\",{\"1\":{\"218\":1}}],[\"blocked\",{\"1\":{\"64\":1}}],[\"blockingqueue的使用\",{\"1\":{\"64\":1}}],[\"blockingqueue\",{\"1\":{\"64\":1}}],[\"blog\",{\"1\":{\"13\":1,\"19\":1,\"37\":3,\"64\":13}}],[\"bash\",{\"1\":{\"217\":2,\"218\":1,\"223\":1}}],[\"basically\",{\"1\":{\"216\":1}}],[\"baseurl=http\",{\"1\":{\"231\":4}}],[\"baseurl=\",{\"1\":{\"231\":1}}],[\"base\",{\"1\":{\"216\":1,\"231\":6}}],[\"base理论\",{\"1\":{\"64\":1}}],[\"based\",{\"1\":{\"64\":3}}],[\"barservice\",{\"1\":{\"64\":10}}],[\"baidu\",{\"1\":{\"41\":1}}],[\"backend\",{\"1\":{\"219\":10}}],[\"back\",{\"1\":{\"24\":1,\"37\":1,\"231\":1}}],[\"b仍然收到并继续发送确认消息\",{\"1\":{\"23\":1}}],[\"b收到重复的m1后\",{\"1\":{\"23\":1}}],[\"b收到了2份m1\",{\"1\":{\"23\":1}}],[\"b收到并发送确认\",{\"1\":{\"23\":1}}],[\"b收到后\",{\"1\":{\"23\":1}}],[\"b向a发送了一个m1确认消息\",{\"1\":{\"23\":1}}],[\"b回答\",{\"1\":{\"19\":1}}],[\"b\",{\"0\":{\"155\":1},\"1\":{\"19\":5,\"96\":3,\"216\":19,\"254\":1}}],[\"上节示例里工程名称是\",{\"1\":{\"219\":1}}],[\"上游服务a为了保证自己不受影响\",{\"1\":{\"216\":1}}],[\"上\",{\"1\":{\"64\":2}}],[\"上图是使用\",{\"1\":{\"51\":1}}],[\"上文中请求到\",{\"1\":{\"43\":1}}],[\"上述图片是查找\",{\"1\":{\"42\":1}}],[\"上面所的行锁\",{\"1\":{\"216\":1}}],[\"上面的记录是按照b\",{\"1\":{\"216\":1}}],[\"上面这个sql实际上和下面的这个sql是等价的\",{\"1\":{\"216\":1}}],[\"上面sql的意思是在t1表中\",{\"1\":{\"216\":1}}],[\"上面有示意图\",{\"0\":{\"83\":1,\"84\":1}}],[\"上面部分主要介绍了一次完整的请求对应的过程\",{\"1\":{\"58\":1}}],[\"上面讲的比较概括\",{\"1\":{\"19\":1}}],[\"上面我们对计算机网络的五层体系结构有了初步的了解\",{\"1\":{\"13\":1}}],[\"上交给网络层\",{\"1\":{\"11\":1}}],[\"总之\",{\"1\":{\"216\":1}}],[\"总是使用2的幂作为哈希表的大小\",{\"1\":{\"73\":2}}],[\"总是在一段一段的链路上传送的\",{\"1\":{\"11\":1}}],[\"总结来说就是对表中的数据按照指定的字段比较大小进行升序排序\",{\"1\":{\"216\":1}}],[\"总结\",{\"0\":{\"59\":1},\"1\":{\"216\":1}}],[\"总结一下\",{\"0\":{\"13\":1},\"1\":{\"216\":1}}],[\"总体来说分为以下几个过程\",{\"1\":{\"27\":1,\"39\":1}}],[\"两个系统不需要相互依赖了\",{\"1\":{\"216\":1}}],[\"两个集群刚刚都对外提供服务了\",{\"1\":{\"216\":1}}],[\"两个机房内的zkserver还是可以相互通信的\",{\"1\":{\"216\":1}}],[\"两个对象有相同的hashcode值\",{\"1\":{\"75\":1}}],[\"两个对象相等\",{\"1\":{\"75\":1}}],[\"两个key可以引用相同的对象\",{\"1\":{\"67\":1}}],[\"两个有序数组的合并排序\",{\"1\":{\"64\":1}}],[\"两个协议\",{\"1\":{\"12\":1}}],[\"两种方法的优劣又在什么地方呢\",{\"1\":{\"64\":1}}],[\"两种代理方式\",{\"1\":{\"64\":1}}],[\"两者的对比图\",{\"1\":{\"81\":1}}],[\"两者在完成这件事情上\",{\"1\":{\"64\":1}}],[\"两者所解决的问题域不一样\",{\"1\":{\"64\":1}}],[\"两阶段提交\",{\"1\":{\"64\":1}}],[\"两台主机之间的数据传输\",{\"1\":{\"11\":1}}],[\"对其它层都不会造成影响\",{\"1\":{\"216\":1}}],[\"对外提供统一的文件系统为merged\",{\"1\":{\"218\":1}}],[\"对外提供的功能与list类似是一个列表的功能\",{\"1\":{\"171\":1}}],[\"对外配置接口\",{\"1\":{\"216\":1}}],[\"对开发人员编写sql\",{\"1\":{\"216\":1}}],[\"对这个变量的读取也会直接从主内存中读取\",{\"1\":{\"216\":1}}],[\"对mysql表中的存储的数据也是一样的\",{\"1\":{\"216\":1}}],[\"对整个桶数组进行了分割分段\",{\"1\":{\"81\":1}}],[\"对比一下\",{\"1\":{\"77\":1}}],[\"对比完之后\",{\"1\":{\"64\":1}}],[\"对两个equals方法返回true\",{\"1\":{\"75\":1}}],[\"对null\",{\"1\":{\"73\":1}}],[\"对应修改后的配置文件如下\",{\"1\":{\"219\":1}}],[\"对应了两个独立的reactor线程池\",{\"1\":{\"216\":1}}],[\"对应于get\",{\"1\":{\"68\":1}}],[\"对应的底层原理就是\",{\"1\":{\"216\":1}}],[\"对应的\",{\"1\":{\"64\":1}}],[\"对应的就是根域名服务器\",{\"1\":{\"42\":1}}],[\"对付顺序的好帮手\",{\"1\":{\"67\":1}}],[\"对什么东西\",{\"1\":{\"64\":2}}],[\"对apache比较熟悉的人都能知道apache提供了自己的缓存模块\",{\"1\":{\"64\":1}}],[\"对此version值加1\",{\"1\":{\"64\":1}}],[\"对于add和copy指令不仅要校验命令是否一致\",{\"1\":{\"231\":1}}],[\"对于已停止的容器\",{\"1\":{\"217\":1}}],[\"对于已经发生了oom的系统\",{\"1\":{\"216\":1}}],[\"对于zookeeper集群\",{\"1\":{\"216\":1}}],[\"对于java这种面试对象语言\",{\"1\":{\"216\":1}}],[\"对于分布式系统而言是一定要保证分区容错性的\",{\"1\":{\"216\":1}}],[\"对于多例bean会在每次获取bean时利用beandefinition去创建\",{\"1\":{\"216\":1}}],[\"对于多例bean不需要在启动过程中去进行创建\",{\"1\":{\"216\":1}}],[\"对于任何生命周期的bean都是一个对象\",{\"1\":{\"216\":1}}],[\"对于很多初学者来说\",{\"1\":{\"216\":1}}],[\"对于tomcat调优\",{\"1\":{\"216\":1}}],[\"对于还在正常运行的系统\",{\"1\":{\"216\":1}}],[\"对于加了volatile关键字的属性\",{\"1\":{\"216\":1}}],[\"对于如何设计一个rpc框架\",{\"1\":{\"216\":1}}],[\"对于消费者而言就需要消耗资源来进行同步\",{\"1\":{\"216\":1}}],[\"对于消费者而言\",{\"1\":{\"216\":2}}],[\"对于机房2来说是选不出来leader的\",{\"1\":{\"216\":1}}],[\"对于机房1来说是没有影响的\",{\"1\":{\"216\":1}}],[\"对于这个问题\",{\"1\":{\"216\":1}}],[\"对于这个排序\",{\"1\":{\"216\":1}}],[\"对于这种情况\",{\"1\":{\"216\":2}}],[\"对于上面的那份原始数据\",{\"1\":{\"216\":1}}],[\"对于三者使用的总结\",{\"1\":{\"94\":1}}],[\"对于两个对象来说hashcode可能相同\",{\"1\":{\"74\":1}}],[\"对于一个zookeeper集群\",{\"1\":{\"216\":1}}],[\"对于一个集群\",{\"1\":{\"216\":1}}],[\"对于一个大型网站来说\",{\"1\":{\"64\":1}}],[\"对于一些动态产生的进程\",{\"1\":{\"64\":1}}],[\"对于千万级的大表要怎么优化\",{\"1\":{\"64\":1}}],[\"对于web服务器来说\",{\"1\":{\"64\":1}}],[\"对于网站打开速度而言\",{\"1\":{\"64\":1}}],[\"对于statement模式无法复制的操作使用row模式保存binlog\",{\"1\":{\"64\":1}}],[\"对于动态代理技术\",{\"1\":{\"64\":1}}],[\"对于不同类型的任务需要分配不同大小的线程池\",{\"1\":{\"64\":1}}],[\"对于不同的网络应用需要不同的应用层协议\",{\"1\":{\"8\":1}}],[\"对每个结点\",{\"1\":{\"64\":1}}],[\"对象是比较耗时的\",{\"1\":{\"216\":1}}],[\"对象是不可变的\",{\"1\":{\"94\":1}}],[\"对象什么时候进入老年代\",{\"0\":{\"181\":1}}],[\"对象本身进行操作\",{\"1\":{\"94\":1}}],[\"对象引用类型分为哪几类\",{\"1\":{\"64\":1}}],[\"对象引用和对象本身就有所区别了\",{\"1\":{\"64\":2}}],[\"对象的内容一样\",{\"1\":{\"96\":1}}],[\"对象的强\",{\"1\":{\"64\":1}}],[\"对象的属性如果还是对象\",{\"1\":{\"64\":1}}],[\"对象的属性其实就是数据\",{\"1\":{\"64\":1}}],[\"对象的引用就会一直存在\",{\"1\":{\"64\":1}}],[\"对象如何不分配在堆而是栈上\",{\"1\":{\"64\":1}}],[\"对象池管理等\",{\"1\":{\"64\":1}}],[\"对象信息查看\",{\"1\":{\"64\":1}}],[\"对象从老年代区域消失的过程\",{\"1\":{\"64\":1}}],[\"对象从新生代区域消失的过程\",{\"1\":{\"64\":1}}],[\"对象锁\",{\"1\":{\"64\":1}}],[\"对象\",{\"1\":{\"53\":1,\"64\":1,\"94\":2,\"96\":1,\"216\":2}}],[\"对\",{\"1\":{\"47\":1,\"53\":1,\"81\":1}}],[\"对称加密和非对称加密\",{\"1\":{\"64\":1}}],[\"对称加密以及\",{\"1\":{\"48\":1}}],[\"对称加密\",{\"1\":{\"35\":1}}],[\"对按序到达的最后一个分组发送确认\",{\"1\":{\"23\":1,\"24\":1}}],[\"对方法加了同步锁或者对调用的方法加了同步锁\",{\"1\":{\"94\":1}}],[\"对方确认后就完全关闭了tcp连接\",{\"1\":{\"19\":1}}],[\"对方发送正常\",{\"1\":{\"16\":1}}],[\"对方发送\",{\"1\":{\"16\":3}}],[\"对传送的比特流来说\",{\"1\":{\"12\":1}}],[\"透明传送比特流\",{\"1\":{\"12\":1}}],[\"尽管存储方式不尽相同\",{\"1\":{\"218\":1}}],[\"尽可能少的loadmodule\",{\"1\":{\"64\":1}}],[\"尽可能屏蔽掉具体传输介质和物理设备的差异\",{\"1\":{\"12\":1}}],[\"尽量减少不必要的内存拷贝\",{\"1\":{\"216\":1}}],[\"尽量减少网络io的时间消耗\",{\"1\":{\"64\":1}}],[\"尽量较少碰撞\",{\"1\":{\"79\":1}}],[\"尽量将动态内容生成静态html来显示\",{\"1\":{\"64\":1}}],[\"尽量使用构建缓存\",{\"1\":{\"231\":1,\"238\":1}}],[\"尽量使用缓存\",{\"1\":{\"64\":1}}],[\"尽量使用较小的线程池\",{\"1\":{\"64\":1}}],[\"尽最大努力的数据传输服务\",{\"1\":{\"9\":1}}],[\"物理层\",{\"0\":{\"12\":1},\"1\":{\"12\":1}}],[\"如下面的es就是elasticsearch服务的别名\",{\"1\":{\"219\":1}}],[\"如下图所示\",{\"1\":{\"15\":1}}],[\"如上图\",{\"1\":{\"219\":1}}],[\"如上文所述\",{\"1\":{\"64\":2}}],[\"如需删除正在运行的容器\",{\"1\":{\"217\":1}}],[\"如需列出所有容器\",{\"1\":{\"217\":1}}],[\"如才兰纳u味是队列\",{\"1\":{\"216\":1}}],[\"如使用\",{\"1\":{\"81\":1}}],[\"如链表\",{\"1\":{\"64\":1}}],[\"如加了服务可restful调用\",{\"1\":{\"64\":1}}],[\"如sleep\",{\"1\":{\"64\":1}}],[\"如量度工具\",{\"1\":{\"64\":1}}],[\"如jre目标下的rt\",{\"1\":{\"64\":1}}],[\"如javascript文件\",{\"1\":{\"30\":1}}],[\"如图像\",{\"1\":{\"57\":1}}],[\"如\",{\"1\":{\"57\":1,\"64\":6,\"94\":1,\"217\":1}}],[\"如颜色\",{\"1\":{\"57\":1}}],[\"如握手和加密等过程\",{\"1\":{\"48\":1}}],[\"如何分离编译环境和运行环境\",{\"1\":{\"231\":1}}],[\"如何分配直接内存\",{\"1\":{\"64\":1}}],[\"如何控制的\",{\"1\":{\"216\":1}}],[\"如何创建线程\",{\"0\":{\"100\":1}}],[\"如何选用集合\",{\"0\":{\"91\":1}}],[\"如何选择合适的垃圾收集算法\",{\"1\":{\"64\":1}}],[\"如何高效地获得玩家排名\",{\"1\":{\"64\":1}}],[\"如何给100亿个数字排序\",{\"1\":{\"64\":2}}],[\"如何做到1秒发布百万级条消息\",{\"1\":{\"64\":2}}],[\"如何保证消息不会被重复消费\",{\"0\":{\"165\":1}}],[\"如何保证消息一致性\",{\"0\":{\"161\":1}}],[\"如何保证\",{\"1\":{\"64\":1}}],[\"如何保存用户状态\",{\"0\":{\"31\":1}}],[\"如何解决脑裂问题\",{\"1\":{\"216\":1}}],[\"如何解决服务调用链过长的问题\",{\"1\":{\"64\":1}}],[\"如何解决服务器响应不及时问题\",{\"1\":{\"64\":2}}],[\"如何解决\",{\"1\":{\"64\":1}}],[\"如何理解\",{\"1\":{\"216\":1}}],[\"如何理解volatile关键字\",{\"1\":{\"216\":1}}],[\"如何理解内存泄漏问题\",{\"1\":{\"64\":1}}],[\"如何理解观察者模式\",{\"1\":{\"64\":1}}],[\"如何合理的规划一次jvm性能调优\",{\"1\":{\"64\":1}}],[\"如何合理配置线程池的大小\",{\"1\":{\"64\":2}}],[\"如何进行jvm调优\",{\"1\":{\"64\":1}}],[\"如何进行消息的重试机制\",{\"1\":{\"64\":1}}],[\"如何处理\",{\"1\":{\"64\":1}}],[\"如何查找\",{\"1\":{\"64\":2}}],[\"如何提高服务器并发处理能力\",{\"1\":{\"64\":2}}],[\"如何设计一个rpc框架\",{\"1\":{\"216\":1}}],[\"如何设计整个系统\",{\"1\":{\"64\":2}}],[\"如何设计算法\",{\"1\":{\"64\":2}}],[\"如何能够高并发\",{\"1\":{\"64\":1}}],[\"如何自定义一个spring\",{\"1\":{\"64\":2}}],[\"如何实现线程安全\",{\"1\":{\"64\":2}}],[\"如何尽快的加载资源\",{\"1\":{\"58\":1}}],[\"如何减少该过程的步骤呢\",{\"1\":{\"43\":1}}],[\"如409\",{\"1\":{\"33\":1}}],[\"如apache\",{\"1\":{\"30\":1}}],[\"如主动队列管理\",{\"1\":{\"26\":1}}],[\"如确认\",{\"1\":{\"20\":1}}],[\"如果构建时发现要构建的镜像层的父镜像层已经存在\",{\"1\":{\"231\":1}}],[\"如果微服务较多\",{\"1\":{\"219\":1}}],[\"如果感兴趣的\",{\"1\":{\"219\":1}}],[\"如果通过\",{\"1\":{\"219\":1}}],[\"如果访问模式没有指定\",{\"1\":{\"219\":1}}],[\"如果该镜像在本地不存在\",{\"1\":{\"219\":1}}],[\"如果服务做了扩容\",{\"1\":{\"219\":1}}],[\"如果服务器集群操作起来更方便\",{\"1\":{\"64\":1}}],[\"如果镜像之前构建过且构建文件没有变化或构建的内容没有变化\",{\"1\":{\"219\":1}}],[\"如果镜像存在则不构建\",{\"1\":{\"219\":1}}],[\"如果镜像\",{\"1\":{\"219\":1}}],[\"如果docker\",{\"1\":{\"217\":1}}],[\"如果本地不存在该名称的镜像\",{\"1\":{\"217\":1}}],[\"如果安装过旧版本的话\",{\"1\":{\"217\":1}}],[\"如果把\",{\"1\":{\"217\":1}}],[\"如果把他存在堆中是没有什么意义的\",{\"1\":{\"64\":2}}],[\"如果确认没问题了\",{\"1\":{\"216\":1}}],[\"如果使用消息队列的方式来调用某个系统\",{\"1\":{\"216\":1}}],[\"如果更新redis失败\",{\"1\":{\"216\":1}}],[\"如果缓存中某一时刻大批热点数据同时过期\",{\"1\":{\"216\":1}}],[\"如果key存在\",{\"1\":{\"216\":1}}],[\"如果key不存在才能获取到锁\",{\"1\":{\"216\":1}}],[\"如果持久化成功则发送一个ack给leader节点\",{\"1\":{\"216\":1}}],[\"如果pk输了\",{\"1\":{\"216\":1}}],[\"如果消费成功\",{\"1\":{\"216\":2}}],[\"如果调用库存系统失败\",{\"1\":{\"216\":1}}],[\"如果调用成功则修改本地消息状态为成功\",{\"1\":{\"216\":1}}],[\"如果传播机制配置为需要新开一个事务\",{\"1\":{\"216\":1}}],[\"如果类在多一些\",{\"1\":{\"216\":1}}],[\"如果没加载到才由自己进行加载\",{\"1\":{\"216\":1}}],[\"如果没有新建\",{\"1\":{\"217\":1}}],[\"如果没有则优化sql利用索引\",{\"1\":{\"216\":1}}],[\"如果没有出现异常就直接提交事务\",{\"1\":{\"216\":1}}],[\"如果没有就将域名发送给电脑所配置的dns进行域名解析\",{\"1\":{\"216\":1}}],[\"如果没有就在常量池中重新创建一个\",{\"1\":{\"96\":1}}],[\"如果没有加载到\",{\"1\":{\"216\":1}}],[\"如果没有获取到\",{\"1\":{\"216\":1}}],[\"如果没有许可可用则线程阻塞\",{\"1\":{\"216\":1}}],[\"如果没有重写hashcode\",{\"1\":{\"75\":1}}],[\"如果没有相符的hashcode\",{\"1\":{\"75\":1}}],[\"如果没有空闲线程\",{\"1\":{\"64\":1}}],[\"如果没有找到的情况下\",{\"1\":{\"42\":1}}],[\"如果bootstrapclassloader没有加载到\",{\"1\":{\"216\":1}}],[\"如果bootstrapclassloader加载到了就直接成功\",{\"1\":{\"216\":1}}],[\"如果改完之后\",{\"1\":{\"216\":1}}],[\"如果频繁发生fullgc但是又一直没有出现内存溢出\",{\"1\":{\"216\":1}}],[\"如果某线程空闲时间超过keepalivetime\",{\"1\":{\"216\":1}}],[\"如果某台zkserver获得了超过半数的选票\",{\"1\":{\"216\":1}}],[\"如果获取到了则表示获取到了锁\",{\"1\":{\"216\":1}}],[\"如果加到锁则返回true\",{\"1\":{\"216\":1}}],[\"如果加载的资源数比较少的话\",{\"1\":{\"58\":1}}],[\"如果用好volatile关键字可以很好的提高执行效率\",{\"1\":{\"216\":1}}],[\"如果用户位于与broker不同的数据中心\",{\"1\":{\"64\":1}}],[\"如果尝试去修改\",{\"1\":{\"216\":1}}],[\"如果存在则不下载\",{\"1\":{\"218\":1}}],[\"如果存在则会生成一个启动tomcat的bean\",{\"1\":{\"216\":1}}],[\"如果存在则直接从cache数组中获取integer对象\",{\"1\":{\"216\":1}}],[\"如果存在则返回该字符串引用\",{\"1\":{\"216\":1}}],[\"如果存入一个值\",{\"1\":{\"64\":1}}],[\"如果存入的是共享变量\",{\"1\":{\"64\":1}}],[\"如果假设我们现在只有5台机器\",{\"1\":{\"216\":1}}],[\"如果现在集群中有5台zkserver\",{\"1\":{\"216\":1}}],[\"如果过了一会\",{\"1\":{\"216\":1}}],[\"如果过了一段时间\",{\"1\":{\"23\":1}}],[\"如果每个微服务都要手动启停\",{\"1\":{\"219\":1}}],[\"如果每个container都去分配一个image一样的文件系统\",{\"1\":{\"218\":1}}],[\"如果每个请求都需要查询数据库\",{\"1\":{\"216\":1}}],[\"如果每次运行结果和单线程运行的结果是一样的\",{\"1\":{\"64\":1}}],[\"如果每次都一样是否说明你请求的资源都位于同一台机器上面\",{\"1\":{\"45\":1}}],[\"如果每次都经过这么多步骤\",{\"1\":{\"43\":1}}],[\"如果每次请求都要这样的话\",{\"1\":{\"33\":1}}],[\"如果只有16个线程\",{\"1\":{\"216\":1}}],[\"如果多余核心线程数\",{\"1\":{\"216\":1}}],[\"如果已经在t1表建立了b\",{\"1\":{\"216\":1}}],[\"如果我们自己来负责创建对象\",{\"1\":{\"216\":1}}],[\"如果我们不用spring\",{\"1\":{\"216\":1}}],[\"如果我们不使用springboot\",{\"1\":{\"216\":1}}],[\"如果我们将这份数据按照a\",{\"1\":{\"216\":1}}],[\"如果我们写的是下面的sql\",{\"1\":{\"216\":1}}],[\"如果我们基于未排序之前的存储方式\",{\"1\":{\"216\":1}}],[\"如果我们现在需要查找a=3\",{\"1\":{\"216\":1}}],[\"如果我们还是查找a=3的这行记录\",{\"1\":{\"216\":1}}],[\"如果根据压测流量路由到影子库\",{\"0\":{\"196\":1}}],[\"如果根域名服务器也不存在该域名时\",{\"1\":{\"42\":1}}],[\"如果整个链路通的\",{\"0\":{\"162\":1}}],[\"如果整个流程正常结束\",{\"1\":{\"64\":1}}],[\"如果大家想要实时关注我更新的文章以及分享的干货的话\",{\"1\":{\"91\":1}}],[\"如果大家都按接口\",{\"1\":{\"64\":1}}],[\"如果相同的话\",{\"1\":{\"77\":1}}],[\"如果当前位置存在元素的话\",{\"1\":{\"77\":1}}],[\"如果当前事务存在\",{\"1\":{\"64\":1}}],[\"如果两个文件计算的数值一致\",{\"1\":{\"231\":1}}],[\"如果两个对象相等\",{\"1\":{\"75\":1}}],[\"如果两者相同\",{\"1\":{\"75\":1}}],[\"如果业务过程没有过多的这种动态申请内存或者创建子进程\",{\"1\":{\"64\":1}}],[\"如果业务数据产生消息可以找到合适的字段作为主键\",{\"1\":{\"64\":1}}],[\"如果超过半数\",{\"1\":{\"216\":1}}],[\"如果超过\",{\"1\":{\"64\":1,\"216\":1}}],[\"如果按时间排序查询\",{\"1\":{\"64\":1}}],[\"如果随机写入磁盘\",{\"1\":{\"64\":1}}],[\"如果首选的副本不在isr中\",{\"1\":{\"64\":1}}],[\"如果副本在isr中停留了很长时间表明什么\",{\"1\":{\"64\":1}}],[\"如果生产者发送消息后\",{\"1\":{\"64\":1}}],[\"如果进群超过半数以上master挂掉\",{\"1\":{\"64\":1}}],[\"如果无法满足此时间\",{\"1\":{\"64\":1}}],[\"如果这个值是一个非叶子节点\",{\"1\":{\"64\":1}}],[\"如果这个垃圾较多无法放入预留的空间就会产生cms\",{\"1\":{\"64\":1}}],[\"如果此时进行修改\",{\"1\":{\"64\":1}}],[\"如果是三层高的b+树\",{\"1\":{\"216\":1}}],[\"如果是单体架构\",{\"1\":{\"216\":1}}],[\"如果是springmvc中的dispatcherservlet\",{\"1\":{\"216\":1}}],[\"如果是非公平锁\",{\"1\":{\"216\":1}}],[\"如果是公平锁\",{\"1\":{\"216\":1}}],[\"如果是order\",{\"1\":{\"216\":2}}],[\"如果是\",{\"1\":{\"69\":1}}],[\"如果是要在指定位置i插入和删除元素的话\",{\"1\":{\"68\":1}}],[\"如果是传引用的方法调用\",{\"1\":{\"64\":1}}],[\"如果是独立的服务器\",{\"1\":{\"64\":1}}],[\"如果想使用其他收集器需要在启动时加入相应参数\",{\"1\":{\"64\":1}}],[\"如果想在\",{\"1\":{\"64\":1}}],[\"如果想不被gc怎么办\",{\"1\":{\"64\":1}}],[\"如果遇到必须使用此参数的场合\",{\"1\":{\"64\":1}}],[\"如果遇到请求外部资源时\",{\"1\":{\"57\":1}}],[\"如果出现大面积并发\",{\"1\":{\"64\":2}}],[\"如果所有读写访问都要排序\",{\"1\":{\"64\":1}}],[\"如果设置accessorder属性为true\",{\"1\":{\"64\":1}}],[\"如果设置为false\",{\"1\":{\"64\":1}}],[\"如果在这过程中实现失败\",{\"1\":{\"64\":1}}],[\"如果true\",{\"1\":{\"64\":1}}],[\"如果一条sql语句用不到索引是不会使用行级锁的\",{\"1\":{\"64\":1}}],[\"如果一个人有多个大脑\",{\"1\":{\"216\":1}}],[\"如果一个副本在isr中保留了很长一段时间\",{\"1\":{\"64\":1}}],[\"如果一个副本从leader中脱离出来\",{\"1\":{\"64\":1}}],[\"如果一个follower副本出现异常\",{\"1\":{\"64\":1}}],[\"如果一个结点是红的\",{\"1\":{\"64\":1}}],[\"如果一个类加载器收到了类加载请求\",{\"1\":{\"64\":1}}],[\"如果数据库表当前版本号与第一次取出来的version值相等\",{\"1\":{\"64\":1}}],[\"如果数据包丢失了\",{\"1\":{\"26\":1}}],[\"如果要缩容执行如下操作\",{\"1\":{\"219\":1}}],[\"如果要给服务取别名则可以用links实现\",{\"1\":{\"219\":1}}],[\"如果要下载指定版本则在java后面加冒号指定版本\",{\"1\":{\"217\":1}}],[\"如果要避免出现问题\",{\"1\":{\"216\":1}}],[\"如果要修改\",{\"1\":{\"64\":2}}],[\"如果要在\",{\"1\":{\"32\":1}}],[\"如果有变量名称与\",{\"1\":{\"219\":1}}],[\"如果有\",{\"1\":{\"217\":1}}],[\"如果有多个协议\",{\"1\":{\"216\":1}}],[\"如果有多个线程同时在操作主内存中的变量\",{\"1\":{\"64\":1}}],[\"如果有则生成\",{\"1\":{\"216\":1}}],[\"如果有很多属性需要注入\",{\"1\":{\"216\":1}}],[\"如果有线程在排队\",{\"1\":{\"216\":1}}],[\"如果有就把它赋给当前引用\",{\"1\":{\"96\":1}}],[\"如果有一个特别大的访问量\",{\"1\":{\"64\":2}}],[\"如果有事务存在\",{\"1\":{\"64\":3}}],[\"如果不一致\",{\"1\":{\"231\":1}}],[\"如果不一致则要进行同步\",{\"1\":{\"216\":1}}],[\"如果不需要在容器里执行这些命令可以不加\",{\"1\":{\"218\":1,\"219\":10}}],[\"如果不做处理\",{\"1\":{\"216\":1}}],[\"如果不考虑过半机制\",{\"1\":{\"216\":1}}],[\"如果不考虑隔离性引发安全性问题\",{\"1\":{\"64\":1}}],[\"如果不是\",{\"1\":{\"69\":1}}],[\"如果不是按分表字段来查询的话\",{\"1\":{\"64\":1}}],[\"如果不存在\",{\"1\":{\"64\":3,\"216\":1}}],[\"如果不能及时收到一个确认\",{\"1\":{\"21\":1}}],[\"如果经常添加删除元素的\",{\"1\":{\"64\":1}}],[\"如果你希望你的镜像足够灵活\",{\"1\":{\"231\":1}}],[\"如果你有选择恐惧症\",{\"1\":{\"217\":1}}],[\"如果你选择\",{\"1\":{\"216\":1}}],[\"如果你当前系统压力\",{\"0\":{\"195\":1}}],[\"如果你看过\",{\"1\":{\"74\":1}}],[\"如果你要保证线程安全的话就使用\",{\"1\":{\"73\":1}}],[\"如果你注视simpleconsumer类\",{\"1\":{\"64\":1}}],[\"如果你的镜像只执行单一的具体程序\",{\"1\":{\"231\":1}}],[\"如果你的代码所在的进程中有多个线程在同时运行\",{\"1\":{\"64\":1}}],[\"如果你的网站涉及到多个国家的语言\",{\"1\":{\"64\":1}}],[\"如果你以键和值的形式进行数据存储那么\",{\"1\":{\"64\":1}}],[\"如果你想要在容器中使用中国区标准时间\",{\"1\":{\"231\":1}}],[\"如果你想保证插入元素的唯一性\",{\"1\":{\"64\":1}}],[\"如果你想容器中的元素能够按照它们插入的次序进行有序存储\",{\"1\":{\"64\":1}}],[\"如果你已经知道索引了的话\",{\"1\":{\"64\":1}}],[\"如果你经常会使用索引来对容器中的元素进行访问\",{\"1\":{\"64\":1}}],[\"如果你连源码都没看过\",{\"1\":{\"64\":1}}],[\"如果父类加载器可以完成类加载任务\",{\"1\":{\"64\":1}}],[\"如果父类加载器还存在其父类加载器\",{\"1\":{\"64\":1}}],[\"如果线程池中线程数量\",{\"1\":{\"64\":4}}],[\"如果线程池中线程数大于\",{\"1\":{\"64\":1}}],[\"如果线程池不销毁线程的话\",{\"1\":{\"64\":1}}],[\"如果线程执行过程中不会产生共享资源的冲突\",{\"1\":{\"64\":1}}],[\"如果资源必须从网络中加载\",{\"1\":{\"58\":1}}],[\"如果中间被截取的话会存在一些信息泄露的风险\",{\"1\":{\"47\":1}}],[\"如果接收机接收到一个不按顺序的数据段\",{\"1\":{\"26\":1}}],[\"如果立即把大量数据字节注入到网络\",{\"1\":{\"26\":1}}],[\"如果发现fullgc比较频繁\",{\"1\":{\"216\":1}}],[\"如果发现concurrenthashmap正在进行扩容那么该线程一起进行扩容\",{\"1\":{\"216\":1}}],[\"如果发现差错\",{\"1\":{\"11\":1}}],[\"如果发送机接收到三个重复确认\",{\"1\":{\"26\":1}}],[\"如果发送方在发送后一段时间之内没有收到确认帧\",{\"1\":{\"22\":1}}],[\"如果收到段的检验和有差错\",{\"1\":{\"21\":1}}],[\"如果需要改正数据在链路层传输时出现差错\",{\"1\":{\"11\":1}}],[\"如同步信息\",{\"1\":{\"11\":1}}],[\"如域名系统dns\",{\"1\":{\"8\":1}}],[\"每对对应一个数据页\",{\"1\":{\"216\":1}}],[\"每种状态的效果是怎样的\",{\"1\":{\"216\":1}}],[\"每种数据结构有它各自的特点\",{\"1\":{\"216\":1}}],[\"每种模式的优缺点是什么\",{\"1\":{\"64\":2}}],[\"每次都会对\",{\"1\":{\"94\":1}}],[\"每次对\",{\"1\":{\"94\":1}}],[\"每次有活就丢给父亲去干\",{\"1\":{\"64\":1}}],[\"每当你发现一个网络错误\",{\"1\":{\"64\":1}}],[\"每秒处理数兆字节的读写操作\",{\"1\":{\"64\":1}}],[\"每条消息都发送给其中一个人\",{\"1\":{\"64\":1}}],[\"每条消息只会被传递一次\",{\"1\":{\"64\":1}}],[\"每客户端并发执行\",{\"1\":{\"64\":2}}],[\"每个容器只负责单一业务进程\",{\"1\":{\"231\":1}}],[\"每个容器修改的都是自己的副本\",{\"1\":{\"218\":1}}],[\"每个服务中定义了容器运行的镜像\",{\"1\":{\"219\":1}}],[\"每个微服务一般都会部署多个实例\",{\"1\":{\"219\":1}}],[\"每个标签对应一个\",{\"1\":{\"217\":1}}],[\"每个仓库可包含多个镜像标签\",{\"1\":{\"217\":1}}],[\"每个节点会收到其他节点发过来的选票\",{\"1\":{\"216\":1}}],[\"每个节点至少有一个备份节点\",{\"1\":{\"64\":1}}],[\"每个thread对象\",{\"1\":{\"216\":1}}],[\"每个线程负责一组或多组的元素转移工作\",{\"1\":{\"216\":1}}],[\"每个自动配置类中就定义了该业务相关的bean\",{\"1\":{\"216\":1}}],[\"每个分区使用一个单独的写入器\",{\"1\":{\"64\":1}}],[\"每个分区中的leader副本都会维护此分区的isr集合\",{\"1\":{\"64\":1}}],[\"每个分区只有一个生产者写入消息\",{\"1\":{\"64\":1}}],[\"每个\",{\"1\":{\"64\":1,\"83\":2}}],[\"每个虚拟地址区域都对应红黑树的一个节点\",{\"1\":{\"64\":1}}],[\"每个叶结点\",{\"1\":{\"64\":1}}],[\"每个结点要么是红的\",{\"1\":{\"64\":1}}],[\"每一条\",{\"1\":{\"231\":1}}],[\"每一条会修改数据的sql语句会记录到binlog中\",{\"1\":{\"64\":1}}],[\"每一行可以忽略一些文件或者文件夹\",{\"1\":{\"231\":1}}],[\"每一把锁只锁容器其中一部分数据\",{\"1\":{\"81\":1}}],[\"每一次建立或者断开连接都需要三次握手四次挥手的开销\",{\"1\":{\"33\":1}}],[\"每一帧包括数据和必要的控制信息\",{\"1\":{\"11\":1}}],[\"每遇到这样一个web资源\",{\"1\":{\"30\":1}}],[\"每经过一个传播轮次\",{\"1\":{\"26\":1}}],[\"每周都会在公众号更新一些自己原创干货\",{\"1\":{\"6\":1,\"66\":1,\"75\":1}}],[\"分离编译环境和运行环境对于生产环境很重要\",{\"1\":{\"234\":1}}],[\"分为了很多层次\",{\"1\":{\"216\":1}}],[\"分为三个阶段\",{\"1\":{\"216\":1}}],[\"分为不同的自动配置类\",{\"1\":{\"216\":1}}],[\"分区容错性表示\",{\"1\":{\"216\":1}}],[\"分区的和重复的日志服务\",{\"1\":{\"64\":1}}],[\"分库分表的场景题\",{\"0\":{\"192\":1}}],[\"分页查询除了使用limit\",{\"0\":{\"106\":1}}],[\"分段锁\",{\"1\":{\"81\":1}}],[\"分段的数组+链表\",{\"1\":{\"81\":1}}],[\"分表之后想让一个id多个表是自增的\",{\"1\":{\"64\":1}}],[\"分表后\",{\"1\":{\"64\":1}}],[\"分包\",{\"1\":{\"64\":1}}],[\"分布式系统中的应用程序都可以来使用这个生成器所提供的锁\",{\"1\":{\"216\":1}}],[\"分布式系统要么保证cp\",{\"1\":{\"216\":1}}],[\"分布式id\",{\"1\":{\"216\":1}}],[\"分布式id是什么\",{\"1\":{\"216\":1}}],[\"分布式id生成算法\",{\"1\":{\"64\":1}}],[\"分布式同步\",{\"1\":{\"64\":1}}],[\"分布式存储系统\",{\"1\":{\"64\":1}}],[\"分布式锁你们用什么实现的\",{\"0\":{\"200\":1}}],[\"分布式锁的使用场景是什么\",{\"1\":{\"216\":1}}],[\"分布式锁的实现过程\",{\"1\":{\"64\":1}}],[\"分布式锁的几种实现方式\",{\"1\":{\"64\":1}}],[\"分布式锁\",{\"1\":{\"64\":1}}],[\"分布式\",{\"1\":{\"64\":1,\"216\":1}}],[\"分布式事务成功结束\",{\"1\":{\"216\":2}}],[\"分布式事务有没有了解过目前业内比较成熟的解决方案\",{\"0\":{\"198\":1}}],[\"分布式事务\",{\"1\":{\"64\":1,\"216\":1}}],[\"分布式事务实现\",{\"1\":{\"64\":2}}],[\"分布式事务的原理2阶段提交\",{\"1\":{\"64\":2}}],[\"分布式事物的理解\",{\"1\":{\"64\":2}}],[\"分而治之的思想\",{\"1\":{\"64\":1}}],[\"分析system\",{\"1\":{\"64\":1}}],[\"分代收集算法\",{\"1\":{\"64\":1}}],[\"分工\",{\"1\":{\"64\":1}}],[\"分别是工程\",{\"1\":{\"219\":1}}],[\"分别是如何变化的\",{\"1\":{\"216\":1}}],[\"分别有哪些典型的应用场景\",{\"1\":{\"216\":1}}],[\"分别采用什么算法\",{\"1\":{\"64\":2}}],[\"分别表示什么请自行查找\",{\"1\":{\"54\":1}}],[\"分组\",{\"1\":{\"10\":1}}],[\"分用和复用相反\",{\"1\":{\"9\":1}}],[\"都尽量使用exec模式\",{\"1\":{\"231\":1}}],[\"都申请到了才证明获取锁成功\",{\"1\":{\"216\":1}}],[\"都不会用上\",{\"1\":{\"216\":1}}],[\"都不支持\",{\"1\":{\"64\":1}}],[\"都支持\",{\"1\":{\"216\":1}}],[\"都会进行排队\",{\"1\":{\"216\":1}}],[\"都会生成一个新的\",{\"1\":{\"94\":1}}],[\"都需要进行磁盘io或网络io\",{\"1\":{\"216\":1}}],[\"都继承自\",{\"1\":{\"94\":1}}],[\"都是从外部往容器内添加文件\",{\"1\":{\"231\":1}}],[\"都是指定\",{\"1\":{\"218\":1}}],[\"都是允许的\",{\"1\":{\"216\":1}}],[\"都是唤醒排在最前面的线程\",{\"1\":{\"216\":1}}],[\"都是不同步的\",{\"1\":{\"68\":1}}],[\"都是不支持事务消息的\",{\"1\":{\"64\":1}}],[\"都是很模糊的描述\",{\"1\":{\"64\":1}}],[\"都是传值\",{\"1\":{\"64\":1}}],[\"都是通过信息发布系统来管理和实现的\",{\"1\":{\"64\":1}}],[\"都是通过connection完成的\",{\"1\":{\"64\":1}}],[\"都要注册一个与其对应的确认和补偿\",{\"1\":{\"64\":1}}],[\"都在使用同一个connection对象\",{\"1\":{\"64\":1}}],[\"都持有两个对象\",{\"1\":{\"64\":1}}],[\"都可笼统地用\",{\"1\":{\"10\":1}}],[\"都有哪些协议\",{\"0\":{\"7\":1}}],[\"弄混\",{\"1\":{\"10\":1}}],[\"不太懂编译环境和运行环境\",{\"1\":{\"248\":1}}],[\"不一定访问我列的这几个接口\",{\"1\":{\"219\":1}}],[\"不统计这些请求数据\",{\"1\":{\"219\":1}}],[\"不配置该容器的网络\",{\"1\":{\"217\":1}}],[\"不同点\",{\"1\":{\"216\":1}}],[\"不同方法的优劣是什么\",{\"1\":{\"64\":1}}],[\"不那么看起来像调本地服务一样调远程服务\",{\"1\":{\"216\":1}}],[\"不用影响程序发布\",{\"1\":{\"233\":1}}],[\"不用\",{\"1\":{\"216\":1}}],[\"不用利用filesort再次进行排序了\",{\"1\":{\"216\":1}}],[\"不然有可能启动不成功\",{\"1\":{\"219\":1}}],[\"不然就会造成数据不一致\",{\"1\":{\"216\":1}}],[\"不然服务端接收到字节流之后不知道该如何解析字节流\",{\"1\":{\"216\":1}}],[\"不带spring\",{\"1\":{\"216\":2}}],[\"不出现冲突\",{\"1\":{\"216\":1}}],[\"不管内部部署了多少应用\",{\"1\":{\"216\":1}}],[\"不管是公平锁还是非公平锁都是可重入的\",{\"1\":{\"216\":1}}],[\"不管是公平锁还是非公平锁\",{\"1\":{\"216\":1}}],[\"不管是apache\",{\"1\":{\"64\":1}}],[\"不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助\",{\"1\":{\"36\":1}}],[\"不听使唤\",{\"1\":{\"216\":1}}],[\"不消费怎么处理\",{\"0\":{\"161\":1}}],[\"不相同就通过拉链法解决冲突\",{\"1\":{\"77\":1}}],[\"不支持高效的随机元素访问\",{\"1\":{\"68\":1}}],[\"不支持批量操作\",{\"1\":{\"64\":1}}],[\"不进行修改\",{\"1\":{\"64\":1}}],[\"不稳定\",{\"1\":{\"64\":4,\"216\":1}}],[\"不影响旧版本\",{\"1\":{\"64\":1}}],[\"不可能越过zookeeper\",{\"1\":{\"64\":1}}],[\"不可重复读\",{\"0\":{\"137\":1},\"1\":{\"64\":2}}],[\"不\",{\"1\":{\"64\":1}}],[\"不需要经过先复制到用户空间\",{\"1\":{\"216\":1}}],[\"不需要线程主动去查询\",{\"1\":{\"216\":1}}],[\"不需要手动开关连接\",{\"1\":{\"216\":1}}],[\"不需要就选择实现list接口的比如arraylist或linkedlist\",{\"1\":{\"91\":1}}],[\"不需要排序时就选择hashmap\",{\"1\":{\"91\":1}}],[\"不需要中间proxy层\",{\"1\":{\"64\":1}}],[\"不需要给出任何确认\",{\"1\":{\"20\":1}}],[\"不难看出\",{\"1\":{\"64\":1}}],[\"不过服务端这边可能还有数据正在处理\",{\"1\":{\"216\":1}}],[\"不过spring\",{\"1\":{\"216\":1}}],[\"不过在这个方法中\",{\"1\":{\"216\":1}}],[\"不过带来了部分额外的内存开销\",{\"1\":{\"170\":1}}],[\"不过还是有一点点区别的\",{\"1\":{\"89\":1}}],[\"不过\",{\"1\":{\"64\":1,\"80\":1}}],[\"不得不承认\",{\"1\":{\"64\":1}}],[\"不只是设置\",{\"1\":{\"64\":1}}],[\"不存在先构建镜像\",{\"1\":{\"219\":1}}],[\"不存在竞争的线程就是安全的\",{\"1\":{\"64\":1}}],[\"不存在代码级别的强依赖\",{\"1\":{\"64\":1}}],[\"不允许重复的集合\",{\"1\":{\"67\":1}}],[\"不允许重复对象\",{\"1\":{\"64\":1}}],[\"不允许有重复元素\",{\"1\":{\"64\":1}}],[\"不记录每条sql语句的上下文信息\",{\"1\":{\"64\":1}}],[\"不会出现混乱\",{\"1\":{\"216\":1}}],[\"不会对应用程序或者数据库的现有设计造成任何影响\",{\"1\":{\"216\":1}}],[\"不会去阻塞线程\",{\"1\":{\"216\":1}}],[\"不会有多个元素引用相同的对象\",{\"1\":{\"67\":1}}],[\"不会直接传对象本身\",{\"1\":{\"64\":1}}],[\"不会引起剧烈变动\",{\"1\":{\"64\":1}}],[\"不会认为已经发送过了\",{\"1\":{\"23\":1}}],[\"不应该受到其他事务的干扰\",{\"1\":{\"64\":1}}],[\"不适合指定位置的插入\",{\"1\":{\"64\":1}}],[\"不适合指定位置的插入删除操作\",{\"1\":{\"64\":1}}],[\"不适合查找\",{\"1\":{\"64\":2}}],[\"不仅可以使得我们的\",{\"1\":{\"231\":1}}],[\"不仅解决了硬件管理的问题\",{\"1\":{\"217\":1}}],[\"不仅支持http1\",{\"1\":{\"64\":1}}],[\"不仅要等到文档中\",{\"1\":{\"57\":1}}],[\"不知道大家有没有思考过一个问题\",{\"1\":{\"45\":1}}],[\"不确定大家能不能心平气和的读完\",{\"1\":{\"36\":1}}],[\"不推荐大家看这本教材\",{\"1\":{\"36\":1}}],[\"不要直接用我这里的配置\",{\"1\":{\"219\":1}}],[\"不要直接写入\",{\"1\":{\"32\":1}}],[\"不要求分布式系统数据实时达到一致\",{\"1\":{\"216\":1}}],[\"不要在代码中使用它\",{\"1\":{\"73\":1}}],[\"不要使用limit\",{\"1\":{\"64\":1}}],[\"不要试图与c进行类比\",{\"1\":{\"64\":1}}],[\"不要把运输层的\",{\"1\":{\"10\":1}}],[\"不能由于分布式系统内部的某个结点挂点\",{\"1\":{\"216\":1}}],[\"不能随意更换数据库\",{\"1\":{\"216\":1}}],[\"不能接受新任务\",{\"1\":{\"216\":2}}],[\"不能设置超时时间\",{\"1\":{\"216\":1}}],[\"不能代理被final修饰的类\",{\"1\":{\"64\":1}}],[\"不能进行写操作\",{\"1\":{\"64\":1}}],[\"不能超过\",{\"1\":{\"64\":4}}],[\"不能保证原子性\",{\"1\":{\"64\":1}}],[\"不能向发送方反映出接收方已经正确收到的所有分组的信息\",{\"1\":{\"24\":1}}],[\"不能要求\",{\"1\":{\"19\":1}}],[\"不向上层交付\",{\"1\":{\"23\":1}}],[\"不提供广播或多播服务\",{\"1\":{\"20\":1}}],[\"不提供可靠交付\",{\"1\":{\"20\":1}}],[\"不保证数据传输的可靠性\",{\"1\":{\"9\":1}}],[\"这对于需要处理\",{\"1\":{\"237\":1}}],[\"这位同学理解很到位\",{\"1\":{\"234\":1}}],[\"这跟\",{\"1\":{\"217\":1}}],[\"这三个注解是\",{\"1\":{\"216\":1}}],[\"这三个类的对象都需要创建出来\",{\"1\":{\"216\":1}}],[\"这期间包括了合并beandefinition\",{\"1\":{\"216\":1}}],[\"这五行代码是不用spring的情况下多出来的代码\",{\"1\":{\"216\":1}}],[\"这两件事情就不用我们做了\",{\"1\":{\"216\":1}}],[\"这两个指令的区别\",{\"1\":{\"231\":1}}],[\"这两个指令的相同之处\",{\"1\":{\"231\":1}}],[\"这两个指令使用中有很多相似的地方\",{\"1\":{\"231\":1}}],[\"这两个方法都会阻塞式的从队列中获取元素\",{\"1\":{\"216\":1}}],[\"这两个结果中的collation字段的结果是不一样的\",{\"1\":{\"216\":1}}],[\"这两种方式均可以有效的提高apache的访问响应能力\",{\"1\":{\"64\":1}}],[\"这两种方式各有优劣\",{\"1\":{\"64\":1}}],[\"这相当于完全屏蔽了应用进程对系统内存状态的感知\",{\"1\":{\"64\":1}}],[\"这点没有问题\",{\"1\":{\"64\":1}}],[\"这点可以参考c的传值调用\",{\"1\":{\"64\":1}}],[\"这点很容易理解\",{\"1\":{\"64\":1}}],[\"这点跟java中synchronized很相似\",{\"1\":{\"64\":1}}],[\"这也是默认的docker\",{\"1\":{\"217\":1}}],[\"这也是最后一道屏障\",{\"1\":{\"64\":1}}],[\"这也就解释了\",{\"1\":{\"79\":1}}],[\"这也会对\",{\"1\":{\"64\":1}}],[\"这也叫\",{\"1\":{\"24\":1}}],[\"这在强调快速演化的微服务环境下\",{\"1\":{\"64\":1}}],[\"这可以带来很多好处\",{\"1\":{\"64\":1}}],[\"这意味着切换到g1将会为应用线程带来额外的工作\",{\"1\":{\"64\":1}}],[\"这不就是传说中的双亲委派模式\",{\"1\":{\"64\":1}}],[\"这不仅使协议数据单元的首部增大很多\",{\"1\":{\"20\":1}}],[\"这\",{\"1\":{\"58\":1}}],[\"这些指令对于刚接触\",{\"1\":{\"231\":1}}],[\"这些都是利用条件注解来实现的\",{\"1\":{\"216\":1}}],[\"这些都需要浏览器去计算其位置和大小等\",{\"1\":{\"57\":1}}],[\"这些条件注解可以用来控制\",{\"1\":{\"216\":1}}],[\"这些数据结构实际上就是对数据进行排序\",{\"1\":{\"216\":1}}],[\"这些数据就储存在请求正文中\",{\"1\":{\"52\":1}}],[\"这些信息维护在哪\",{\"0\":{\"190\":1}}],[\"这些对象可能是系统的类加载器\",{\"1\":{\"64\":1}}],[\"这些对象由于特殊的目的不被gc回收\",{\"1\":{\"64\":1}}],[\"这些类从不会被卸载\",{\"1\":{\"64\":1}}],[\"这些产品很昂贵\",{\"1\":{\"64\":1}}],[\"这些业务在物理服务器基础上\",{\"1\":{\"64\":1}}],[\"这些应用必须使用数据库\",{\"1\":{\"64\":1}}],[\"这一课时我就教你如何在生产环境中编写最优的\",{\"1\":{\"231\":1}}],[\"这一实现起来是比较容易的一现\",{\"1\":{\"64\":1}}],[\"这一部分工作一般是由\",{\"1\":{\"53\":1}}],[\"这一部分对应于编程语言中的\",{\"1\":{\"53\":1}}],[\"这一难以避免增加了许多开销\",{\"1\":{\"20\":1}}],[\"这时就会提醒你\",{\"1\":{\"216\":1}}],[\"这时就需要设置\",{\"1\":{\"52\":1}}],[\"这时会调用equals\",{\"1\":{\"75\":1}}],[\"这时一台数据库将很快无法满足应用\",{\"1\":{\"64\":1}}],[\"这时候应该使用concurrenthashmap\",{\"1\":{\"64\":1}}],[\"这时接收方只能对前两个发送确认\",{\"1\":{\"24\":1}}],[\"这本书页数不多\",{\"1\":{\"36\":1}}],[\"这本书\",{\"1\":{\"36\":1}}],[\"这个需要根据不同的业务场景来制定的\",{\"1\":{\"252\":1}}],[\"这个有什么区别呢\",{\"1\":{\"242\":1}}],[\"这个声明有什么用\",{\"1\":{\"240\":1}}],[\"这个docker学习通俗易懂\",{\"1\":{\"235\":1}}],[\"这个参数是让docker能支持在容器里能执行jdk自带的类似jinfo\",{\"1\":{\"219\":10}}],[\"这个参数是让docker能支持在容器里能执行jdk自带类似jinfo\",{\"1\":{\"218\":1}}],[\"这个配置需要先在宿主机对应目录放好broker\",{\"1\":{\"219\":1}}],[\"这个是针对已有文件的修改场景\",{\"1\":{\"218\":1}}],[\"这个是在代理一个实现了具有18个方法的接口的类\",{\"1\":{\"64\":1}}],[\"这个新建过程是分钟级别的\",{\"1\":{\"218\":1}}],[\"这个不常出现\",{\"1\":{\"216\":1}}],[\"这个注解实际就是一个\",{\"1\":{\"216\":1}}],[\"这个注解标识了一个springboot工程\",{\"1\":{\"216\":1}}],[\"这个对象是不是线程安全的\",{\"1\":{\"216\":1}}],[\"这个对于发送请求的客户来说体验是比较好的\",{\"1\":{\"216\":1}}],[\"这个对于很多有强迫症的面试官\",{\"1\":{\"64\":1}}],[\"这个状态是自动发生在shutdown和stop之后的\",{\"1\":{\"216\":1}}],[\"这个状态下的子进程就是僵死进程\",{\"1\":{\"64\":1}}],[\"这个order\",{\"1\":{\"216\":1}}],[\"这个sql表示要对t1创建一个索引\",{\"1\":{\"216\":1}}],[\"这个也是list所不能提供的\",{\"1\":{\"171\":1}}],[\"这个很棒的一个功能\",{\"1\":{\"170\":1}}],[\"这个算法应该如何设计呢\",{\"1\":{\"79\":1}}],[\"这个数组下标的计算方法是\",{\"1\":{\"79\":1}}],[\"这个时候就需要降序索引了\",{\"1\":{\"216\":1}}],[\"这个时候才对应到真正的对象\",{\"1\":{\"64\":1}}],[\"这个时候你还有心情去购买吗\",{\"1\":{\"58\":1}}],[\"这个最简单的方法其实也是最有效的方法\",{\"1\":{\"64\":1}}],[\"这个全局变量是线程安全的\",{\"1\":{\"64\":1}}],[\"这个队列是无界的\",{\"1\":{\"64\":1}}],[\"这个同一管理的平台可以称为ioc容器\",{\"1\":{\"64\":1}}],[\"这个主要为了缓解面试者的压力\",{\"1\":{\"64\":1}}],[\"这个\",{\"1\":{\"42\":1,\"253\":1}}],[\"这个过程线程一直在运行中\",{\"1\":{\"216\":1}}],[\"这个过程也就是求交集的过程\",{\"1\":{\"171\":1}}],[\"这个过程会有一定的延迟\",{\"1\":{\"64\":1}}],[\"这个过程是不断重复的\",{\"1\":{\"57\":1}}],[\"这个过程称为\",{\"1\":{\"57\":2}}],[\"这个过程比较复杂\",{\"1\":{\"57\":1}}],[\"这个过程中存在多个请求\",{\"1\":{\"43\":1}}],[\"这个过程就是\",{\"1\":{\"41\":1}}],[\"这个过程涉及到的东西很多\",{\"1\":{\"39\":1}}],[\"这个权衡就是一个网址到\",{\"1\":{\"41\":1}}],[\"这个问题的回答真的能够很好的考验一个\",{\"1\":{\"39\":1}}],[\"这个资源\",{\"1\":{\"34\":1}}],[\"这个电路好像是看不见的\",{\"1\":{\"12\":1}}],[\"这部分回答引用这篇文章\",{\"1\":{\"33\":1}}],[\"这是docker默认的配置文件\",{\"1\":{\"217\":1}}],[\"这是指定版本安装\",{\"1\":{\"217\":1}}],[\"这是由于在建立a\",{\"1\":{\"216\":1}}],[\"这是实现spring事务非常重要的一步\",{\"1\":{\"216\":1}}],[\"这是beanfactory所不具备的\",{\"1\":{\"216\":1}}],[\"这是有问题的\",{\"1\":{\"216\":1}}],[\"这是不是就有点懵了\",{\"1\":{\"216\":1}}],[\"这是整个副本集合的一个子集\",{\"1\":{\"64\":1}}],[\"这是对于有过期时间的key\",{\"1\":{\"64\":1}}],[\"这是基本上大型网站都会采用的策略\",{\"1\":{\"64\":1}}],[\"这是乐观锁最常用的一种实现方式\",{\"1\":{\"64\":1}}],[\"这是在编译时增强\",{\"1\":{\"64\":1}}],[\"这是一个无序的数列或数组\",{\"1\":{\"216\":1}}],[\"这是一个platfromtransactionmanager默认的隔离级别\",{\"1\":{\"64\":1}}],[\"这是一个端到端的检验和\",{\"1\":{\"21\":1}}],[\"这是一款超级好用的\",{\"1\":{\"59\":1}}],[\"这是最快的方式\",{\"1\":{\"58\":1}}],[\"这是因为用户登录的时候我们可以存放了一个\",{\"1\":{\"32\":1}}],[\"这种格式是基于\",{\"1\":{\"231\":1}}],[\"这种格式是使用\",{\"1\":{\"231\":1}}],[\"这种书写格式为cmd\",{\"1\":{\"231\":1}}],[\"这种做法减少了网络io\",{\"1\":{\"216\":1}}],[\"这种局部无锁化的串行线程设计相比一个队里\",{\"1\":{\"216\":1}}],[\"这种方案能解决1方案的问题\",{\"1\":{\"216\":1}}],[\"这种方案也能保证分布式架构中的系统id唯一\",{\"1\":{\"216\":1}}],[\"这种方案和单机数据库\",{\"1\":{\"216\":1}}],[\"这种方案复杂度最低\",{\"1\":{\"216\":1}}],[\"这种方法会使链路层的协议复杂些\",{\"1\":{\"11\":1}}],[\"这种语法在mysql中也是支持的\",{\"1\":{\"216\":1}}],[\"这种情况时间复杂度就是o\",{\"1\":{\"68\":1}}],[\"这种情况下整个集群当机房间的网络断掉后\",{\"1\":{\"216\":1}}],[\"这种情况下\",{\"1\":{\"64\":1}}],[\"这种情况就叫拥塞\",{\"1\":{\"26\":1}}],[\"这种可能\",{\"1\":{\"64\":1}}],[\"这种共享的收益是很多的\",{\"1\":{\"64\":1}}],[\"这种隔离\",{\"1\":{\"64\":1}}],[\"这种gc是full\",{\"1\":{\"64\":1}}],[\"这种字符仅能存储简体中文字符\",{\"1\":{\"64\":1}}],[\"这种过程就是\",{\"1\":{\"45\":1}}],[\"这种自动重传方式常称为\",{\"1\":{\"23\":1}}],[\"这就相当于原本一个集群\",{\"1\":{\"216\":1}}],[\"这就可以看出来在mysql7中降序索引只是语法层面的支持\",{\"1\":{\"216\":1}}],[\"这就可能出现\",{\"1\":{\"64\":1}}],[\"这就解释了\",{\"1\":{\"79\":1}}],[\"这就涉及到了数据的更新\",{\"1\":{\"64\":1}}],[\"这就意味着\",{\"1\":{\"57\":1}}],[\"这就是缓存穿透\",{\"1\":{\"216\":1}}],[\"这就是缓存击穿\",{\"1\":{\"216\":1}}],[\"这就是服务降级\",{\"1\":{\"216\":1}}],[\"这就是服务雪崩\",{\"1\":{\"216\":1}}],[\"这就是反转\",{\"1\":{\"216\":1}}],[\"这就是控制\",{\"1\":{\"216\":1}}],[\"这就是解决这一类大问题的思路\",{\"1\":{\"216\":1}}],[\"这就是更脑裂问题有关系了\",{\"1\":{\"216\":1}}],[\"这就是脑裂\",{\"1\":{\"216\":1}}],[\"这就是降序索引\",{\"1\":{\"216\":1}}],[\"这就是索引\",{\"1\":{\"216\":1}}],[\"这就是双亲委派模式\",{\"1\":{\"64\":1}}],[\"这就是\",{\"1\":{\"57\":2}}],[\"这就是说\",{\"1\":{\"11\":1}}],[\"这就需要使用专门的链路层的协议\",{\"1\":{\"11\":1}}],[\"这样设计是为了方便多个\",{\"1\":{\"241\":1}}],[\"这样不仅可以加快容器构建速度\",{\"1\":{\"231\":1}}],[\"这样可以大大提升构建速度\",{\"1\":{\"231\":1}}],[\"这样可以非常节约存储空间\",{\"1\":{\"218\":1}}],[\"这样可以提高存储资源的利用率\",{\"1\":{\"218\":1}}],[\"这样可以使下次\",{\"1\":{\"51\":1}}],[\"这样镜像就能给别人用了\",{\"1\":{\"218\":1}}],[\"这样才能用到联合索引\",{\"1\":{\"216\":1}}],[\"这样才不会出错\",{\"1\":{\"87\":1}}],[\"这样其它人只要关注\",{\"1\":{\"216\":1}}],[\"这样集群的leader就选举出来了\",{\"1\":{\"216\":1}}],[\"这样tomcat中每个应用就可以使用自己的类加载器去加载自己的类\",{\"1\":{\"216\":1}}],[\"这样比较快\",{\"1\":{\"216\":1}}],[\"这样能让我更快的感受到自己被服务了\",{\"1\":{\"216\":1}}],[\"这样一旦时间到了还没有获取到任务\",{\"1\":{\"216\":1}}],[\"这样一旦内存使用量上去以后\",{\"1\":{\"64\":1}}],[\"这样只要hash不冲突\",{\"1\":{\"84\":1}}],[\"这样分开\",{\"1\":{\"64\":1}}],[\"这样的指令\",{\"1\":{\"231\":1}}],[\"这样的键只有一个\",{\"1\":{\"73\":1}}],[\"这样的架构可以降低提供页面访问请求的服务器系统压力\",{\"1\":{\"64\":1}}],[\"这样的话只要我们的线程不退出\",{\"1\":{\"64\":1}}],[\"这样便可以防止核心api库被随意篡改\",{\"1\":{\"64\":1}}],[\"这样就能启动一个\",{\"1\":{\"217\":1}}],[\"这样就算在更新mysql时\",{\"1\":{\"216\":1}}],[\"这样就算其中某个redis节点挂掉了\",{\"1\":{\"216\":1}}],[\"这样就避免了多线程竞争和同步锁\",{\"1\":{\"216\":1}}],[\"这样就避免了脑裂问题\",{\"1\":{\"216\":1}}],[\"这样就出现了脑裂\",{\"1\":{\"216\":1}}],[\"这样就不使用offsets\",{\"1\":{\"64\":1}}],[\"这样就方便了开发者自由的选择以便于充分利用带宽和连接\",{\"1\":{\"33\":1}}],[\"这样就可以使网络中的路由器或链路不致过载\",{\"1\":{\"26\":1}}],[\"这样通话才算结束\",{\"1\":{\"19\":1}}],[\"这样在客户机和服务器之间才能建立起可靠的tcp连接\",{\"1\":{\"17\":1}}],[\"这样\",{\"1\":{\"11\":1,\"216\":1}}],[\"这样既简洁又能将概念阐述清楚\",{\"1\":{\"7\":1}}],[\"这里我以\",{\"1\":{\"231\":1}}],[\"这里我们选择docker官方镜像仓库\",{\"1\":{\"218\":1}}],[\"这里我们应该想的是\",{\"1\":{\"216\":1}}],[\"这里再强调一下\",{\"1\":{\"231\":1}}],[\"这里启动的微服务跟上面启动的mysql\",{\"1\":{\"219\":1}}],[\"这里仅挑选常用命令进行讲解\",{\"1\":{\"219\":1}}],[\"这里通常就是消费端ack机制\",{\"1\":{\"216\":1}}],[\"这里有两种方法\",{\"1\":{\"64\":1}}],[\"这里利用事务的原子性来实现\",{\"1\":{\"64\":1}}],[\"这里提供两个可选方案\",{\"1\":{\"64\":1}}],[\"这里的\",{\"1\":{\"77\":1}}],[\"这里的回答比较简单\",{\"1\":{\"64\":1}}],[\"这里的aop指的是面向切面编程思想\",{\"1\":{\"64\":1}}],[\"这里不阐述太深\",{\"1\":{\"64\":1}}],[\"这里主要考察面试者是否对技术有钻研的精神\",{\"1\":{\"64\":1}}],[\"这里强调指出\",{\"1\":{\"10\":1}}],[\"这里要注意\",{\"1\":{\"10\":1}}],[\"协议进行解析\",{\"1\":{\"53\":1}}],[\"协议中发送到服务器指定端口\",{\"1\":{\"49\":1}}],[\"协议之间\",{\"1\":{\"47\":1}}],[\"协议与\",{\"1\":{\"47\":1}}],[\"协议的实现\",{\"1\":{\"216\":1}}],[\"协议的本质就是\",{\"1\":{\"47\":1}}],[\"协议的区别\",{\"0\":{\"20\":1}}],[\"协议是使用\",{\"1\":{\"46\":1}}],[\"协议是无状态的\",{\"1\":{\"31\":1,\"32\":1}}],[\"协议自身不对请求和响应之间的通信状态进行保存\",{\"1\":{\"31\":1}}],[\"协议可提高信道利用率\",{\"1\":{\"24\":1}}],[\"协议如何保证可靠传输\",{\"0\":{\"21\":1}}],[\"协议\",{\"0\":{\"47\":1},\"1\":{\"10\":1,\"23\":1,\"31\":1,\"49\":2,\"216\":1}}],[\"体系结构中\",{\"1\":{\"10\":1}}],[\"也有写作env\",{\"1\":{\"242\":1}}],[\"也有廉价的通过软件实现的思路\",{\"1\":{\"64\":1}}],[\"也改变了虚拟化的方式\",{\"1\":{\"217\":1}}],[\"也能解决生产者重复发送消息的问题\",{\"1\":{\"216\":1}}],[\"也比较难控制\",{\"1\":{\"216\":1}}],[\"也导致了大量请求直接访问mysql数据库\",{\"1\":{\"216\":1}}],[\"也叫做nio\",{\"1\":{\"216\":1}}],[\"也叫后端控制器\",{\"1\":{\"216\":1}}],[\"也要创建新的线程来处理被添加的任务\",{\"1\":{\"216\":1}}],[\"也会导致\",{\"1\":{\"216\":1}}],[\"也会处理队列中的任务\",{\"1\":{\"216\":1}}],[\"也会受到影响\",{\"1\":{\"46\":1}}],[\"也想提供一些自动配置类\",{\"1\":{\"216\":1}}],[\"也增加了消费者应用的压力\",{\"1\":{\"216\":1}}],[\"也部署在两个机房\",{\"1\":{\"216\":1}}],[\"也非常简单\",{\"1\":{\"216\":1}}],[\"也就无所谓唤醒线程\",{\"1\":{\"216\":1}}],[\"也就可以理解为常量\",{\"1\":{\"94\":1}}],[\"也就是生产者不能重复生产消息\",{\"1\":{\"216\":1}}],[\"也就是消息不能重复\",{\"1\":{\"216\":1}}],[\"也就是2000万条左右\",{\"1\":{\"216\":1}}],[\"也就是写锁\",{\"1\":{\"216\":1}}],[\"也就是读锁\",{\"1\":{\"216\":1}}],[\"也就是叶子节点中存储了所有的元素\",{\"1\":{\"216\":1}}],[\"也就是内存中的数据\",{\"1\":{\"216\":1}}],[\"也就是排在最前面的字段\",{\"1\":{\"216\":1}}],[\"也就是去掉\",{\"1\":{\"216\":1}}],[\"也就是只要有\",{\"1\":{\"216\":1}}],[\"也就是启动spring时\",{\"1\":{\"216\":1}}],[\"也就是依赖注入\",{\"1\":{\"216\":1}}],[\"也就是正常对象\",{\"1\":{\"216\":1}}],[\"也就是没有被引用的对象\",{\"1\":{\"216\":1}}],[\"也就是entry对象进行回收\",{\"1\":{\"216\":1}}],[\"也就是如果用spring\",{\"1\":{\"216\":1}}],[\"也就是如果进程本身占用的虚拟地址空间比较大或者剩余内存比较小时\",{\"1\":{\"64\":1}}],[\"也就是如何高效的调用远程方法\",{\"1\":{\"216\":1}}],[\"也就是至少要3台服务器才能选出一个leader\",{\"1\":{\"216\":1}}],[\"也就是本来一个\",{\"1\":{\"216\":1}}],[\"也就是线程池没有工作线程在运行了\",{\"1\":{\"216\":1}}],[\"也就是回收了\",{\"1\":{\"216\":1}}],[\"也就是c字段数据小者在下\",{\"1\":{\"216\":1}}],[\"也就是上面我说的文件中保存这些数据的格式是不准确的\",{\"1\":{\"216\":1}}],[\"也就是上面提到的百度的网址\",{\"1\":{\"41\":1}}],[\"也就是要尽量把数据分配均匀\",{\"1\":{\"79\":1}}],[\"也就是不保证线程安全\",{\"1\":{\"68\":1}}],[\"也就是更改服务器的数据\",{\"1\":{\"64\":1}}],[\"也就是所谓的查\",{\"1\":{\"64\":1}}],[\"也就是会浪费1\",{\"1\":{\"64\":1}}],[\"也就是每条执行的sql语句都是一个单独的事务\",{\"1\":{\"64\":1}}],[\"也就是一个jvm\",{\"1\":{\"216\":1}}],[\"也就是一个键一个值\",{\"1\":{\"64\":1}}],[\"也就是一条记录加上锁\",{\"1\":{\"64\":1}}],[\"也就是我们平时在创建索引的时候\",{\"1\":{\"216\":1}}],[\"也就是我们说的耦合度\",{\"1\":{\"64\":1}}],[\"也就是我们熟悉的雅虎\",{\"1\":{\"58\":1}}],[\"也就是你不想有重复值的出现\",{\"1\":{\"64\":1}}],[\"也就是说至少要4台zkserver才能选出来一个leader\",{\"1\":{\"216\":1}}],[\"也就是说创建一个链表数组\",{\"1\":{\"77\":1}}],[\"也就是说isr中包含了所有提交的消息\",{\"1\":{\"64\":1}}],[\"也就是说我们不用考虑同步的问题\",{\"1\":{\"64\":1}}],[\"也就是说进程是可以独立运行的一段程序\",{\"1\":{\"64\":1}}],[\"也就是说可以直接跑起来\",{\"1\":{\"64\":1}}],[\"也就是说每次请求都要重新建立一次连接\",{\"1\":{\"33\":1}}],[\"也就是说\",{\"1\":{\"30\":1,\"31\":1,\"57\":1,\"73\":1,\"79\":1}}],[\"也就是由小到大逐渐增大拥塞窗口数值\",{\"1\":{\"26\":1}}],[\"也就是中和\",{\"1\":{\"7\":1}}],[\"也同时可以理解为\",{\"1\":{\"64\":1}}],[\"也编写的处理数据的逻辑\",{\"1\":{\"64\":1}}],[\"也是docker\",{\"1\":{\"231\":1}}],[\"也是可以理解的\",{\"1\":{\"216\":1}}],[\"也是spring事务中最复杂的\",{\"1\":{\"216\":1}}],[\"也是一种代码\",{\"1\":{\"231\":1}}],[\"也是一个bean工厂\",{\"1\":{\"216\":1}}],[\"也是一样的\",{\"1\":{\"216\":1}}],[\"也是redis最重要的数据结构之一\",{\"1\":{\"170\":1}}],[\"也是有一定影响的\",{\"1\":{\"64\":1}}],[\"也是为了实现可靠传输的\",{\"1\":{\"21\":1}}],[\"也按照元素的插入顺序对它们进行存储\",{\"1\":{\"64\":1}}],[\"也通过\",{\"1\":{\"64\":1}}],[\"也不能写\",{\"1\":{\"216\":1}}],[\"也不能使用\",{\"1\":{\"81\":1}}],[\"也不会有问题\",{\"1\":{\"216\":1}}],[\"也不会处理队列中的任务\",{\"1\":{\"216\":1}}],[\"也不会释放线程\",{\"1\":{\"64\":1}}],[\"也不会把前面的指令排到内存屏障的后面\",{\"1\":{\"64\":1}}],[\"也不必重传\",{\"1\":{\"24\":1}}],[\"也成内存栅栏\",{\"1\":{\"64\":1}}],[\"也基本上是一笔带过\",{\"1\":{\"59\":1}}],[\"也可共享给其他容器\",{\"1\":{\"218\":1}}],[\"也可使用\",{\"1\":{\"217\":1}}],[\"也可能加不到\",{\"1\":{\"216\":1}}],[\"也可能还要经过很多通信子网\",{\"1\":{\"10\":1}}],[\"也可以单独使用\",{\"1\":{\"231\":1}}],[\"也可以单条拉取\",{\"1\":{\"216\":1}}],[\"也可以把compose的容器日志输出到日志文件里去\",{\"1\":{\"219\":1}}],[\"也可以直接使用docker官方镜像仓库\",{\"1\":{\"218\":1}}],[\"也可以是一个列表\",{\"1\":{\"219\":2}}],[\"也可以是一个list\",{\"1\":{\"219\":1}}],[\"也可以是一个对象\",{\"1\":{\"219\":1}}],[\"也可以是一个\",{\"1\":{\"218\":1}}],[\"也可以是数字\",{\"1\":{\"168\":1}}],[\"也可以存储多个元素\",{\"1\":{\"216\":1}}],[\"也可以当做队列来使用\",{\"1\":{\"216\":1}}],[\"也可以缓存某个json格式的字符串\",{\"1\":{\"216\":1}}],[\"也可以通过\",{\"1\":{\"216\":1}}],[\"也可以通过telnet直接某个服务\",{\"1\":{\"64\":1}}],[\"也可以理解为远程方法调用\",{\"1\":{\"216\":1}}],[\"也可以理解为多个线程访问同一个对象\",{\"1\":{\"64\":1}}],[\"也可以使用外加的squid模块进行缓存\",{\"1\":{\"64\":1}}],[\"也可以快速的响应用户\",{\"1\":{\"58\":1}}],[\"也直接丢弃重复的m1\",{\"1\":{\"23\":1}}],[\"在全局中也有volumn的声明\",{\"1\":{\"240\":1}}],[\"在构建镜像时尽可能地减少\",{\"1\":{\"231\":1}}],[\"在构建镜像时\",{\"1\":{\"231\":1}}],[\"在介绍\",{\"1\":{\"231\":2}}],[\"在每个微服务目录下新建一个dockerfile\",{\"1\":{\"219\":1}}],[\"在下载镜像时\",{\"1\":{\"218\":1}}],[\"在overlayfs中\",{\"1\":{\"218\":1}}],[\"在linux服务器上用docker\",{\"1\":{\"218\":1}}],[\"在docker\",{\"1\":{\"219\":6}}],[\"在docker中\",{\"1\":{\"218\":1}}],[\"在dockerfile中添加以下内容\",{\"1\":{\"218\":1}}],[\"在dockerfile所在路径执行以下命令构建镜像\",{\"1\":{\"218\":1}}],[\"在docker容器的处理下\",{\"1\":{\"217\":1}}],[\"在里面增加如下内容\",{\"1\":{\"218\":1}}],[\"在里面再新建文件夹app\",{\"1\":{\"218\":1}}],[\"在app目录下新建一个名为dockerfile的文件\",{\"1\":{\"218\":1}}],[\"在本例中\",{\"1\":{\"217\":1}}],[\"在断开tcp连接时\",{\"1\":{\"216\":1}}],[\"在建立tcp连接时\",{\"1\":{\"216\":1}}],[\"在事务的隔离级别实现中\",{\"1\":{\"216\":1}}],[\"在秒杀中\",{\"1\":{\"216\":1}}],[\"在很多场景下都使用\",{\"1\":{\"216\":1}}],[\"在很多并发场景下\",{\"1\":{\"216\":1}}],[\"在分布式系统中\",{\"1\":{\"216\":1}}],[\"在单体架构中\",{\"1\":{\"216\":1}}],[\"在开发中\",{\"1\":{\"216\":1}}],[\"在达到一致过程中\",{\"1\":{\"216\":1}}],[\"在处理$\",{\"1\":{\"216\":1}}],[\"在处理\",{\"1\":{\"216\":1}}],[\"在此新数据库连接上执行sql\",{\"1\":{\"216\":1}}],[\"在此事务结束之前\",{\"1\":{\"64\":1}}],[\"在锁对象的对象头中记录一下当前获取到该锁的线程id\",{\"1\":{\"216\":1}}],[\"在示前一个节用并\",{\"1\":{\"216\":1}}],[\"在对这个属性进行修改时\",{\"1\":{\"216\":1}}],[\"在并发环境下可以保证这个属性的可见性\",{\"1\":{\"216\":1}}],[\"在并发领域中\",{\"1\":{\"216\":1}}],[\"在并发的情况\",{\"1\":{\"64\":1}}],[\"在向copyonwritearraylist添加元素时\",{\"1\":{\"216\":1}}],[\"在interger类中\",{\"1\":{\"216\":1}}],[\"在ip世界\",{\"1\":{\"64\":1}}],[\"在领导者选举的过程中\",{\"1\":{\"216\":1}}],[\"在threadpoolexecutor中terminated\",{\"1\":{\"216\":1}}],[\"在调用poll或take方法之前\",{\"1\":{\"216\":1}}],[\"在调用具体方法前调用invokehandler方法来处理\",{\"1\":{\"64\":1}}],[\"在没有任务执行时\",{\"1\":{\"216\":1}}],[\"在创建索引的时候你所指定的列就是用来对表里的数据行进行排序的\",{\"1\":{\"216\":1}}],[\"在创建的索引的时候\",{\"1\":{\"216\":1}}],[\"在mysql中一个innodb页就是一个b+树节点\",{\"1\":{\"216\":1}}],[\"在mysql7\",{\"1\":{\"216\":1}}],[\"在mysql8\",{\"1\":{\"216\":1}}],[\"在直播系统中\",{\"1\":{\"172\":1}}],[\"在微博应用中\",{\"1\":{\"171\":1}}],[\"在上面结构的基础上\",{\"1\":{\"90\":1}}],[\"在解决哈希冲突时有了较大的变化\",{\"1\":{\"73\":1}}],[\"在我看来\",{\"1\":{\"69\":1}}],[\"在内存不足的情况下\",{\"1\":{\"64\":1}}],[\"在大多数队列系统中\",{\"1\":{\"64\":1}}],[\"在消息中包含一个主键\",{\"1\":{\"64\":1}}],[\"在kafka中传递消息是通过使用sendfile\",{\"1\":{\"64\":1}}],[\"在kafka中\",{\"1\":{\"64\":1}}],[\"在kafka中broker的意义是什么\",{\"1\":{\"64\":1}}],[\"在kafka集群中\",{\"1\":{\"64\":1}}],[\"在队列中\",{\"1\":{\"64\":1}}],[\"在功能上讲\",{\"1\":{\"64\":1}}],[\"在这个模型中\",{\"1\":{\"64\":1}}],[\"在这个方面上\",{\"1\":{\"64\":1}}],[\"在这里\",{\"1\":{\"218\":1}}],[\"在这里提供一种方案\",{\"1\":{\"64\":1}}],[\"在这里打个免费的广告\",{\"1\":{\"45\":1}}],[\"在运行栈中\",{\"1\":{\"64\":1}}],[\"在运行期间对业务方法进行增强\",{\"1\":{\"64\":1}}],[\"在jar包所在目录创建名为dockerfile的文件\",{\"1\":{\"218\":1}}],[\"在java中\",{\"1\":{\"216\":1}}],[\"在java中表示远程方法调用\",{\"1\":{\"216\":1}}],[\"在java中一个线程就会相应有一个线程栈与之对应\",{\"1\":{\"64\":1}}],[\"在jdk1\",{\"1\":{\"81\":1}}],[\"在jdbc中处理事务\",{\"1\":{\"64\":1}}],[\"在什么时候\",{\"1\":{\"64\":2}}],[\"在不增加服务器的基础上\",{\"1\":{\"64\":2}}],[\"在不可靠服务的基础上实现可靠的信息传输\",{\"1\":{\"22\":1}}],[\"在硬件四层交换产品领域\",{\"1\":{\"64\":1}}],[\"在第四层交换中的应用区间则由源端和终端ip地址\",{\"1\":{\"64\":1}}],[\"在镜像的细节技术方面\",{\"1\":{\"64\":1}}],[\"在应用服务器和图片服务器上\",{\"1\":{\"64\":1}}],[\"在多线程并发执行下\",{\"1\":{\"64\":1}}],[\"在多台处理器上同时处理多个任务\",{\"1\":{\"64\":1}}],[\"在一组机器上对数据进行分区和简化\",{\"1\":{\"64\":1}}],[\"在一个主线程中\",{\"1\":{\"64\":1}}],[\"在一个截面上碰撞的概率高\",{\"1\":{\"64\":1}}],[\"在一台处理器上\",{\"1\":{\"64\":1}}],[\"在哪些情况下\",{\"1\":{\"64\":1}}],[\"在使用git时\",{\"1\":{\"231\":1}}],[\"在使用了threadlocal对象之后\",{\"1\":{\"216\":1}}],[\"在使用过程中都遇到了些什么问题\",{\"1\":{\"64\":1}}],[\"在使用web语言开发的时候\",{\"1\":{\"64\":1}}],[\"在使用iterator遍历的时候\",{\"1\":{\"64\":1}}],[\"在使用长连接的情况下\",{\"1\":{\"30\":1}}],[\"在某些特殊的情况下\",{\"1\":{\"64\":1}}],[\"在某段时间\",{\"1\":{\"26\":1}}],[\"在外层trab\",{\"1\":{\"64\":2}}],[\"在进行每次操作时都要通过获取锁才能进行对相同数据的操作\",{\"1\":{\"64\":1}}],[\"在spring\",{\"1\":{\"64\":1}}],[\"在需要加解密的方法上添加该注解\",{\"1\":{\"64\":1}}],[\"在执行get的时候\",{\"1\":{\"64\":1}}],[\"在2中gc线程与用户线程同时执行\",{\"1\":{\"64\":1}}],[\"在它前面的操作已经全部完成\",{\"1\":{\"64\":1}}],[\"在校或者工作中主要的工作内容\",{\"1\":{\"64\":1}}],[\"在谈到\",{\"1\":{\"58\":1}}],[\"在同一个时间内只能做一件事\",{\"1\":{\"57\":1}}],[\"在请求包头中有一些与请求正文相关的信息\",{\"1\":{\"52\":1}}],[\"在握手过程中将确立双方加密传输数据的密码信息\",{\"1\":{\"48\":1}}],[\"在传输数据之前需要客户端与服务器进行一个握手\",{\"1\":{\"48\":1}}],[\"在传送数据之前必须先建立连接\",{\"1\":{\"20\":1}}],[\"在传送数据之前不需要先建立连接\",{\"1\":{\"20\":1}}],[\"在你的\",{\"1\":{\"44\":1}}],[\"在浏览器中输入\",{\"1\":{\"39\":1}}],[\"在浏览器中输入url地址\",{\"0\":{\"27\":1}}],[\"在服务端保存\",{\"1\":{\"31\":1}}],[\"在http1\",{\"1\":{\"33\":2}}],[\"在http\",{\"1\":{\"30\":1,\"33\":1}}],[\"在暂停的这段时间内\",{\"1\":{\"26\":1}}],[\"在网络层也可以使路由器采用适当的分组丢弃策略\",{\"1\":{\"26\":1}}],[\"在超时时间内没有收到确认消息\",{\"1\":{\"23\":1}}],[\"在超时计时过后\",{\"1\":{\"23\":1}}],[\"在停止等待协议中\",{\"1\":{\"23\":1}}],[\"在收到确认后再发下一个分组\",{\"1\":{\"21\":1}}],[\"在数据同步过程中\",{\"1\":{\"216\":1}}],[\"在数据生产过程中避免重复\",{\"1\":{\"64\":1}}],[\"在数据消耗期间避免重复\",{\"1\":{\"64\":1}}],[\"在数据中\",{\"1\":{\"64\":1}}],[\"在数据制作过程中\",{\"1\":{\"64\":1}}],[\"在数据传完后\",{\"1\":{\"20\":1}}],[\"在数据通信传输中\",{\"1\":{\"17\":1}}],[\"在客户机和服务器之间建立正常的\",{\"1\":{\"17\":1}}],[\"在互联网使用的各种协中最重要和最著名的就是\",{\"1\":{\"12\":1}}],[\"在互联网中应用层协议很多\",{\"1\":{\"8\":1}}],[\"在物理层上所传送的数据单位是比特\",{\"1\":{\"12\":1}}],[\"在接收数据时\",{\"1\":{\"11\":1}}],[\"在两个相邻节点间的链路上传送帧\",{\"1\":{\"11\":1}}],[\"在两个相邻节点之间传送数据时\",{\"1\":{\"11\":1}}],[\"在发送数据时\",{\"1\":{\"10\":1}}],[\"在\",{\"1\":{\"10\":2,\"26\":1,\"32\":1,\"47\":1,\"59\":1,\"64\":1,\"69\":1,\"94\":2,\"230\":3,\"241\":1}}],[\"网易等公司都免费提供的软件加速源\",{\"1\":{\"231\":1}}],[\"网站缓存技术\",{\"1\":{\"64\":1}}],[\"网站程序开发方面的缓存\",{\"1\":{\"64\":1}}],[\"网站架构和网站开发中的缓存也是非常重要\",{\"1\":{\"64\":1}}],[\"网站可看作是它在网上的门户\",{\"1\":{\"8\":1}}],[\"网址\",{\"1\":{\"64\":1}}],[\"网址到\",{\"1\":{\"41\":1}}],[\"网络传输层\",{\"1\":{\"216\":1}}],[\"网络通信\",{\"1\":{\"64\":1}}],[\"网络通过路由器\",{\"1\":{\"10\":1}}],[\"网络架构及单线程模型\",{\"1\":{\"64\":1}}],[\"网络总结\",{\"0\":{\"38\":1}}],[\"网络的性能就要变坏\",{\"1\":{\"26\":1}}],[\"网络连接时\",{\"1\":{\"17\":1}}],[\"网络\",{\"1\":{\"10\":1,\"218\":1}}],[\"网络层中的\",{\"1\":{\"10\":1}}],[\"网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送\",{\"1\":{\"10\":1}}],[\"网络层的任务就是选择合适的网间路由和交换结点\",{\"1\":{\"10\":1}}],[\"网络层\",{\"0\":{\"10\":1}}],[\"与云的结合\",{\"1\":{\"217\":1}}],[\"与索引列进行等值匹配的对象信息\",{\"1\":{\"216\":1}}],[\"与程序代码的耦合\",{\"1\":{\"216\":1}}],[\"与equals\",{\"1\":{\"75\":1}}],[\"与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求\",{\"1\":{\"33\":1}}],[\"与\",{\"0\":{\"68\":1,\"71\":1},\"1\":{\"9\":1,\"51\":1,\"64\":4,\"94\":3}}],[\"ubuntu\",{\"1\":{\"231\":2}}],[\"uid\",{\"1\":{\"218\":1}}],[\"up时\",{\"1\":{\"219\":1}}],[\"up\",{\"1\":{\"219\":6}}],[\"up表示运行中\",{\"1\":{\"217\":1}}],[\"updates\",{\"1\":{\"231\":5}}],[\"updated\",{\"1\":{\"231\":1}}],[\"update语法实现行锁\",{\"1\":{\"64\":1}}],[\"update\",{\"1\":{\"64\":21,\"217\":2,\"219\":1,\"231\":1}}],[\"usage\",{\"1\":{\"218\":1}}],[\"usr\",{\"1\":{\"216\":1,\"218\":2,\"219\":4,\"222\":2,\"223\":1,\"225\":4,\"231\":3,\"248\":2}}],[\"useful\",{\"1\":{\"231\":1}}],[\"use\",{\"1\":{\"231\":1}}],[\"uses\",{\"1\":{\"231\":1}}],[\"usessl=false\",{\"1\":{\"219\":1}}],[\"useunicode=true\",{\"1\":{\"219\":1}}],[\"used\",{\"1\":{\"94\":2}}],[\"username=test\",{\"1\":{\"219\":1}}],[\"username\",{\"1\":{\"219\":2}}],[\"user类\",{\"1\":{\"216\":3}}],[\"user\",{\"1\":{\"9\":1,\"51\":1,\"64\":12,\"218\":1,\"219\":1}}],[\"uzm\",{\"1\":{\"216\":1}}],[\"uuid或其他\",{\"1\":{\"64\":1}}],[\"u\",{\"1\":{\"64\":1}}],[\"utc\",{\"1\":{\"231\":1}}],[\"utm\",{\"1\":{\"92\":1}}],[\"utf8编码格式很强大\",{\"1\":{\"64\":1}}],[\"utf\",{\"1\":{\"64\":1}}],[\"utils\",{\"1\":{\"217\":1}}],[\"util\",{\"1\":{\"64\":1,\"85\":1,\"217\":1}}],[\"udf\",{\"1\":{\"64\":1}}],[\"udp之间关系和区别\",{\"1\":{\"64\":1}}],[\"udp\",{\"0\":{\"20\":1},\"1\":{\"9\":2,\"10\":1,\"20\":4,\"43\":1,\"216\":1}}],[\"u013925989\",{\"1\":{\"64\":1}}],[\"unless\",{\"1\":{\"231\":1}}],[\"uname\",{\"1\":{\"217\":2}}],[\"undo\",{\"1\":{\"216\":1}}],[\"uncommited\",{\"1\":{\"64\":1}}],[\"unix\",{\"1\":{\"225\":1}}],[\"unicode\",{\"1\":{\"219\":1}}],[\"unit=\",{\"1\":{\"223\":1}}],[\"unit\",{\"1\":{\"64\":1,\"223\":1}}],[\"uniform\",{\"1\":{\"34\":2}}],[\"unmodified\",{\"1\":{\"33\":1}}],[\"uri的作用像身份证号一样\",{\"1\":{\"34\":1}}],[\"uri\",{\"1\":{\"34\":2}}],[\"uri和url的区别是什么\",{\"0\":{\"34\":1}}],[\"url是一种具体的uri\",{\"1\":{\"34\":1}}],[\"url的作用更像家庭住址一样\",{\"1\":{\"34\":1}}],[\"url\",{\"1\":{\"31\":1,\"34\":2,\"39\":1,\"50\":1,\"216\":1,\"218\":1,\"219\":1,\"231\":2}}],[\"所在的目录名\",{\"1\":{\"219\":1}}],[\"所在路径执行\",{\"1\":{\"219\":1}}],[\"所做的写操作都是对从image中复制到自己的文件系统的副本上进行\",{\"1\":{\"218\":1}}],[\"所需要的字段都在当前索引的叶子节点上存在\",{\"1\":{\"216\":1}}],[\"所谓\",{\"1\":{\"77\":1}}],[\"所谓扰动函数指的就是\",{\"1\":{\"77\":1}}],[\"所谓复用就是指多个应用层进程可同时使用下面运输层的服务\",{\"1\":{\"9\":1}}],[\"所涉及到的大部分内容\",{\"1\":{\"59\":1}}],[\"所以容器占用的空间是很少的\",{\"1\":{\"218\":1}}],[\"所以可能会造成网络堵塞\",{\"1\":{\"216\":1}}],[\"所以可以在缓存之前加一层布隆过滤器来拦截不存在的key\",{\"1\":{\"216\":1}}],[\"所以可以用来作为注册中心\",{\"1\":{\"216\":1}}],[\"所以可以按jvm调优的方式来进行调整\",{\"1\":{\"216\":1}}],[\"所以肯定是有消息时才会推送\",{\"1\":{\"216\":1}}],[\"所以pull可以由消费者自己控制\",{\"1\":{\"216\":1}}],[\"所以理论上kafka利用此机制提高了性能却降低了可靠性\",{\"1\":{\"216\":1}}],[\"所以两层高的b+树能存储的数据条数为1170\",{\"1\":{\"216\":1}}],[\"所以一般情况下一颗两层的b+树可以存2000万行左右的数据\",{\"1\":{\"216\":1}}],[\"所以一定要避免在并发环境下使用hashmap\",{\"1\":{\"64\":1}}],[\"所以dubbo所提供的功能没有spring\",{\"1\":{\"216\":1}}],[\"所以各个节点最终选出来的leader也是一样的\",{\"1\":{\"216\":1}}],[\"所以最终各个节点中的投票箱中的选票也将是一样的\",{\"1\":{\"216\":1}}],[\"所以用redis\",{\"1\":{\"216\":1}}],[\"所以集群数据不一致时\",{\"1\":{\"216\":1}}],[\"所以集群中至少应该有奇数个节点\",{\"1\":{\"64\":1}}],[\"所以zookeeper的性能也是比较高的\",{\"1\":{\"216\":1}}],[\"所以由它实现的分布式锁可能不可靠\",{\"1\":{\"216\":1}}],[\"所以由它实现的分布式锁更可靠\",{\"1\":{\"216\":1}}],[\"所以需要采用红锁的方式来同时向n\",{\"1\":{\"216\":1}}],[\"所以需要额外的一个看门狗定时任务来监听锁是否需要续约\",{\"1\":{\"216\":1}}],[\"所以需要分布式锁\",{\"1\":{\"216\":1}}],[\"所以需要一种机制可以先执行排在后面的任务\",{\"1\":{\"57\":1}}],[\"所以出现了base理论\",{\"1\":{\"216\":1}}],[\"所以强一致性和可用性是不能同时满足的\",{\"1\":{\"216\":1}}],[\"所以只要jdbc\",{\"1\":{\"216\":1}}],[\"所以springboot扫描的路径是启动类所在的当前目录\",{\"1\":{\"216\":1}}],[\"所以建议用\",{\"1\":{\"216\":1}}],[\"所以无论有多少个容器共享一个image\",{\"1\":{\"218\":1}}],[\"所以无法很好的利用代理\",{\"1\":{\"216\":1}}],[\"所以无需再设置此值\",{\"1\":{\"64\":1}}],[\"所以某个加了\",{\"1\":{\"216\":1}}],[\"所以applicationcontext拥有beanfactory所有的特点\",{\"1\":{\"216\":1}}],[\"所以如果想要利用b+树进行快速查找也得符合这个规则\",{\"1\":{\"216\":1}}],[\"所以如果是被代理对象来调用这个方法\",{\"1\":{\"216\":1}}],[\"所以如果tomcat中只存在一个类加载器\",{\"1\":{\"216\":1}}],[\"所以如果第三方框架\",{\"1\":{\"216\":1}}],[\"所以反过来\",{\"1\":{\"216\":1}}],[\"所以非公平锁只是体现在了线程加锁阶段\",{\"1\":{\"216\":1}}],[\"所以同时也就保证了有序性\",{\"1\":{\"216\":1}}],[\"所以会禁止指令重排\",{\"1\":{\"216\":1}}],[\"所以linkedlist还可以当做队列来使用\",{\"1\":{\"216\":1}}],[\"所以在线程并发执行时\",{\"1\":{\"216\":1}}],[\"所以在单线程环境下stringbuilder效率会更高\",{\"1\":{\"216\":1}}],[\"所以在springboot中会利用\",{\"1\":{\"216\":1}}],[\"所以在不需要保证线程安全时建议使用arraylist\",{\"1\":{\"71\":1}}],[\"所以叫自动配置类\",{\"1\":{\"216\":1}}],[\"所以叫快速领导者选举算法呗\",{\"1\":{\"216\":1}}],[\"所以实际上zookeeper集群中是不会出现脑裂问题的\",{\"1\":{\"216\":1}}],[\"所以实际上就是对原本的数据按照b\",{\"1\":{\"216\":1}}],[\"所以我们构建镜像的时候想要安装一些软件包可能会非常慢\",{\"1\":{\"231\":1}}],[\"所以我们可以发现\",{\"1\":{\"216\":1}}],[\"所以我们就把它拆细了来回答\",{\"1\":{\"216\":1}}],[\"所以我们就知道了\",{\"1\":{\"216\":1}}],[\"所以我们不应该纠结为什么是200\",{\"1\":{\"216\":1}}],[\"所以我们应该尽可能少的减少\",{\"1\":{\"57\":1}}],[\"所以就得到了上面的结果\",{\"1\":{\"216\":1}}],[\"所以对这个原则不是很理解\",{\"1\":{\"238\":1}}],[\"所以对于机房1来说它不能选出一个leader\",{\"1\":{\"216\":1}}],[\"所以对于order\",{\"1\":{\"216\":1}}],[\"所以对于add\",{\"1\":{\"68\":1}}],[\"所以对应的行排在前面\",{\"1\":{\"216\":1}}],[\"所以innodb存储引擎在处理这些插入的数据时\",{\"1\":{\"216\":1}}],[\"所以文件中保存这些数据的格式大概如下\",{\"1\":{\"216\":1}}],[\"所以是非线程安全的\",{\"1\":{\"94\":1}}],[\"所以是线程安全的\",{\"1\":{\"94\":1}}],[\"所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成\",{\"1\":{\"90\":1}}],[\"所以它都是进行传值调用\",{\"1\":{\"64\":1}}],[\"所以必须实现\",{\"1\":{\"87\":1}}],[\"所以equals\",{\"1\":{\"74\":1}}],[\"所以称为快速随机访问\",{\"1\":{\"69\":1}}],[\"所以插入和删除元素的时间复杂度受元素位置的影响\",{\"1\":{\"68\":1}}],[\"所以至少有三个节点\",{\"1\":{\"64\":1}}],[\"所以运行一段时间以后会产生\",{\"1\":{\"64\":1}}],[\"所以这些对象最好能在younggc过程中就直接回收掉\",{\"1\":{\"216\":1}}],[\"所以这也间接的使得线程池中的线程阻塞等待从而达到保活的效果\",{\"1\":{\"216\":1}}],[\"所以这两种对象都是可变的\",{\"1\":{\"94\":1}}],[\"所以这个散列值是不能直接拿来用的\",{\"1\":{\"79\":1}}],[\"所以这个修改是可以保持的了\",{\"1\":{\"64\":1}}],[\"所以这里的选择主要针对并行收集器和并发收集器\",{\"1\":{\"64\":1}}],[\"所以这一部分我也就不在这里分析了\",{\"1\":{\"46\":1}}],[\"所以能在gc中生存一次\",{\"1\":{\"64\":1}}],[\"所以尽可能使网站上的页面采用静态页面来实现\",{\"1\":{\"64\":1}}],[\"所以要判断下\",{\"1\":{\"64\":1}}],[\"所以不适合实时性要求很高的场景\",{\"1\":{\"216\":1}}],[\"所以不去深究\",{\"1\":{\"216\":1}}],[\"所以不需要另外实现了\",{\"1\":{\"87\":1}}],[\"所以不支持快速随机访问\",{\"1\":{\"69\":1}}],[\"所以不会出现动态增长的情况\",{\"1\":{\"64\":2}}],[\"所以不会生成新类\",{\"1\":{\"64\":1}}],[\"所以不好下笔\",{\"1\":{\"59\":1}}],[\"所以使用反射可能会导致意料之外的副作用\",{\"1\":{\"64\":1}}],[\"所以\",{\"1\":{\"64\":5,\"69\":1,\"83\":1,\"94\":1,\"216\":10,\"217\":1,\"231\":1}}],[\"所以围绕这一部分就是考虑如何减少\",{\"1\":{\"58\":1}}],[\"所以又叫做事件循环\",{\"1\":{\"57\":1}}],[\"所以互联网设计者需要在用户的方便性与可用性方面做一个权衡\",{\"1\":{\"41\":1}}],[\"所以说\",{\"1\":{\"35\":1}}],[\"所以三次握手就能确认双发收发功能都正常\",{\"1\":{\"16\":1}}],[\"所有镜像层和容器层都保存在宿主机的文件系统\",{\"1\":{\"218\":1}}],[\"所有数据都从image中读取\",{\"1\":{\"218\":1}}],[\"所有驱动都用到的技术\",{\"1\":{\"218\":1}}],[\"所有配置会形成互补配置\",{\"1\":{\"216\":1}}],[\"所有这些都是我们程序员做的\",{\"1\":{\"216\":1}}],[\"所有await的线程都将被唤醒\",{\"1\":{\"216\":1}}],[\"所有文件\",{\"1\":{\"64\":1}}],[\"所有请求都卡在调到第二台上\",{\"1\":{\"64\":1}}],[\"所有存储于\",{\"1\":{\"64\":1}}],[\"所有\",{\"1\":{\"64\":1}}],[\"所有组件的日志记录\",{\"1\":{\"64\":1}}],[\"所有网址真正的解析过程为\",{\"1\":{\"42\":1}}],[\"所有传输的内容都经过加密\",{\"1\":{\"35\":1}}],[\"所有传输的内容都是明文\",{\"1\":{\"35\":1}}],[\"所有的写请求都会交给leader节点来进行处理\",{\"1\":{\"216\":1}}],[\"所有的写请求都会由leader节点来处理\",{\"1\":{\"216\":1}}],[\"所有的配置都可以在命令行上进行指定\",{\"1\":{\"216\":1}}],[\"所有的这些都是spring做的\",{\"1\":{\"216\":1}}],[\"所有的redis节点彼此互联\",{\"1\":{\"64\":1}}],[\"所有的事务只能对其进行读操作不能写操作\",{\"1\":{\"64\":1}}],[\"所有的同步任务在主线程上执行\",{\"1\":{\"57\":1}}],[\"所有的任务都需要排队\",{\"1\":{\"57\":1}}],[\"所有的路由器\",{\"1\":{\"26\":1}}],[\"所有的\",{\"1\":{\"8\":1}}],[\"通过网关访问创建订单接口\",{\"1\":{\"219\":1}}],[\"通过网关访问查询购物车接口\",{\"1\":{\"219\":1}}],[\"通过网关访问添加购物车接口\",{\"1\":{\"219\":1}}],[\"通过网关访问登录接口获取token\",{\"1\":{\"219\":1}}],[\"通过pip安装\",{\"1\":{\"219\":1}}],[\"通过幂等性\",{\"1\":{\"216\":1}}],[\"通过读写锁提升并发性能\",{\"1\":{\"216\":1}}],[\"通过调整nio线程池的线程参数\",{\"1\":{\"216\":1}}],[\"通过acquire\",{\"1\":{\"216\":1}}],[\"通过执行explain\",{\"0\":{\"154\":1}}],[\"通过源码一步一步分析arraylist\",{\"1\":{\"72\":1}}],[\"通过内核空间保存副本\",{\"1\":{\"64\":1}}],[\"通过\",{\"1\":{\"64\":1,\"77\":1,\"217\":1}}],[\"通过压缩\",{\"1\":{\"64\":1}}],[\"通过volatile修饰的变量可以保证线程之间的可见性\",{\"1\":{\"64\":1}}],[\"通过一个命令来编译\",{\"1\":{\"64\":1}}],[\"通过class\",{\"1\":{\"64\":1}}],[\"通过对象实例方法获取对象\",{\"1\":{\"64\":1}}],[\"通过object类的getclass方法\",{\"1\":{\"64\":1}}],[\"通道\",{\"1\":{\"51\":1}}],[\"通话即将结束后\",{\"1\":{\"19\":1}}],[\"通常称为shell模式\",{\"1\":{\"231\":1}}],[\"通常可以用来处理一些具有过期性操作的业务\",{\"1\":{\"216\":1}}],[\"通常可以用来作为消息重试\",{\"1\":{\"216\":1}}],[\"通常会创建两个nioeventloopgroup实例\",{\"1\":{\"216\":1}}],[\"通常会采用多机房部署\",{\"1\":{\"216\":1}}],[\"通常采取什么手段解决呢\",{\"1\":{\"64\":1}}],[\"通常首先要回答两个问题\",{\"1\":{\"64\":1}}],[\"通常\",{\"1\":{\"56\":1,\"216\":1}}],[\"通常需要客户端向服务器传递数据\",{\"1\":{\"52\":1}}],[\"通常都会省略\",{\"1\":{\"42\":1}}],[\"通常简称为链路层\",{\"1\":{\"11\":1}}],[\"通常域名都使用该公司的名称或简称\",{\"1\":{\"8\":1}}],[\"通用的\",{\"1\":{\"9\":1}}],[\"万维网\",{\"1\":{\"8\":1}}],[\"是的\",{\"1\":{\"234\":1}}],[\"是对\",{\"1\":{\"216\":1}}],[\"是对字符串的内容进行比较\",{\"1\":{\"75\":1}}],[\"是可以结合起来一起使用的\",{\"1\":{\"216\":1}}],[\"是可以\",{\"1\":{\"216\":1}}],[\"是可以自动排重的\",{\"1\":{\"171\":1}}],[\"是外围概念\",{\"1\":{\"216\":1}}],[\"是抽象概念\",{\"1\":{\"216\":1}}],[\"是核心层\",{\"1\":{\"216\":1}}],[\"是拼接符\",{\"1\":{\"216\":1}}],[\"是字符串替换\",{\"1\":{\"216\":1}}],[\"是占位符\",{\"1\":{\"216\":1}}],[\"是预编译处理\",{\"1\":{\"216\":1}}],[\"是直接通过socket发出去呢\",{\"1\":{\"216\":1}}],[\"是在springboot内部定义的\",{\"1\":{\"216\":1}}],[\"是10个\",{\"1\":{\"216\":1}}],[\"是为了和重量级锁区分开来\",{\"1\":{\"216\":1}}],[\"是为了用户体验\",{\"1\":{\"216\":1}}],[\"是为了告诉发送端\",{\"1\":{\"17\":1}}],[\"是如何保活的呢\",{\"1\":{\"216\":1}}],[\"是小的在上\",{\"1\":{\"216\":1}}],[\"是数据进行大小比较后\",{\"1\":{\"216\":1}}],[\"是不需要\",{\"1\":{\"216\":1}}],[\"是不能对外提供服务的\",{\"1\":{\"216\":1}}],[\"是不能自动唤醒的\",{\"1\":{\"64\":1}}],[\"是不是同一个目录下\",{\"0\":{\"140\":1}}],[\"是原理\",{\"0\":{\"114\":1}}],[\"是由\",{\"1\":{\"83\":1}}],[\"是由基本类型组成的\",{\"1\":{\"64\":1}}],[\"是2的\",{\"1\":{\"79\":1}}],[\"是线程安全的\",{\"1\":{\"73\":1}}],[\"是非线程安全的\",{\"1\":{\"73\":1}}],[\"是哪个位置照成性能瓶颈\",{\"1\":{\"64\":2}}],[\"是具有一定独立功能的程序\",{\"1\":{\"64\":1}}],[\"是指采用了关系模型\",{\"1\":{\"64\":1}}],[\"是指两个或者多个事件在同一时刻发生\",{\"1\":{\"64\":1}}],[\"是指两个或多个事件在同一时间间隔发生\",{\"1\":{\"64\":1}}],[\"是指中国的中文字符\",{\"1\":{\"64\":1}}],[\"是指并不针对某一个特定的网络应用\",{\"1\":{\"9\":1}}],[\"是时间与空间一个平衡值\",{\"1\":{\"64\":1}}],[\"是支持事务消息的\",{\"1\":{\"64\":1}}],[\"是悲观锁的不同的实现\",{\"1\":{\"64\":1}}],[\"是你正确的选择\",{\"1\":{\"64\":1}}],[\"是你的正确的选择\",{\"1\":{\"64\":1}}],[\"是一个用于定义和运行多容器的docker应用的工具\",{\"1\":{\"219\":1}}],[\"是一个开源的商业产品\",{\"1\":{\"217\":1}}],[\"是一个servlet容器\",{\"1\":{\"216\":1}}],[\"是一个空方法\",{\"1\":{\"216\":1}}],[\"是一个\",{\"1\":{\"169\":1}}],[\"是一个链表结构的元素\",{\"1\":{\"83\":1}}],[\"是一个根据其\",{\"1\":{\"64\":1}}],[\"是一个有序容器\",{\"1\":{\"64\":2}}],[\"是一种数组和链表结构\",{\"1\":{\"83\":1}}],[\"是一种可重入锁\",{\"1\":{\"83\":1}}],[\"是一种不保存状态\",{\"1\":{\"31\":1}}],[\"是一种拥塞控制算法\",{\"1\":{\"26\":1}}],[\"是清理整个堆空间\",{\"1\":{\"64\":1}}],[\"是单线程运行\",{\"1\":{\"57\":1}}],[\"是否可以适当增加资源\",{\"1\":{\"216\":1}}],[\"是否太低\",{\"1\":{\"216\":1}}],[\"是否太耗时间\",{\"1\":{\"43\":1}}],[\"是否应该进行分库分表了\",{\"1\":{\"216\":1}}],[\"是否查询了过多字段\",{\"1\":{\"216\":1}}],[\"是否是最优索引\",{\"1\":{\"216\":1}}],[\"是否这些依赖都是必须的\",{\"1\":{\"216\":1}}],[\"是否出现了死锁\",{\"1\":{\"216\":1}}],[\"是否支持回调等功能了\",{\"1\":{\"216\":1}}],[\"是否支持快速随机访问\",{\"1\":{\"68\":1}}],[\"是否相同\",{\"1\":{\"77\":1}}],[\"是否\",{\"1\":{\"69\":1}}],[\"是否保证线程安全\",{\"1\":{\"68\":1}}],[\"是否线程安全\",{\"1\":{\"64\":1}}],[\"是否使用\",{\"1\":{\"48\":1}}],[\"是统一资源定位符\",{\"1\":{\"34\":1}}],[\"是统一资源标志符\",{\"1\":{\"34\":1}}],[\"是基于tcp\",{\"1\":{\"33\":1}}],[\"是个端到端的问题\",{\"1\":{\"26\":1}}],[\"是osi模型中数据链路层和传输层的错误纠正协议之一\",{\"1\":{\"22\":1}}],[\"是\",{\"1\":{\"17\":1,\"64\":1,\"74\":1,\"94\":1}}],[\"是运输层把收到的信息分别交付上面应用层中的相应进程\",{\"1\":{\"9\":1}}],[\"是互联网上应用最为广泛的一种网络协议\",{\"1\":{\"8\":1}}],[\"是因特网的一项核心服务\",{\"1\":{\"8\":1}}],[\"hi\",{\"1\":{\"242\":1}}],[\"hibernate对象的三种状态转换\",{\"1\":{\"64\":1}}],[\"hibernate的原理体系架构\",{\"1\":{\"64\":1}}],[\"hibernate中的1级和2级缓存的使用方式以及区别原理\",{\"1\":{\"64\":1}}],[\"hibernate和ibatis的区别\",{\"1\":{\"64\":1}}],[\"h=服务器外网ip\",{\"1\":{\"228\":1}}],[\"h1>\",{\"1\":{\"218\":1}}],[\"hub的账户名\",{\"1\":{\"218\":1}}],[\"hub下载镜像并启动一个\",{\"1\":{\"217\":1}}],[\"hub中的\",{\"1\":{\"217\":1}}],[\"hub中的镜像\",{\"1\":{\"217\":1}}],[\"hub中搜索含有\",{\"1\":{\"217\":1}}],[\"hub上存放着⼤量优秀的镜像\",{\"1\":{\"217\":1}}],[\"hub\",{\"1\":{\"217\":1,\"218\":1,\"231\":1}}],[\"hubei\",{\"1\":{\"169\":1}}],[\"hset\",{\"1\":{\"169\":1}}],[\"hgetall\",{\"1\":{\"169\":1}}],[\"hget\",{\"1\":{\"169\":1}}],[\"hgc0907\",{\"1\":{\"64\":1}}],[\"h\",{\"1\":{\"77\":10,\"225\":2}}],[\"home=$homesh\",{\"1\":{\"246\":1}}],[\"home=\",{\"1\":{\"219\":1}}],[\"home\",{\"1\":{\"219\":5}}],[\"host=host\",{\"1\":{\"230\":1}}],[\"hostport\",{\"1\":{\"217\":2}}],[\"host\",{\"1\":{\"217\":1,\"219\":5,\"230\":4}}],[\"hosts=http\",{\"1\":{\"219\":1}}],[\"hosts\",{\"1\":{\"44\":1,\"230\":1}}],[\"hook\",{\"1\":{\"216\":1}}],[\"hoffman\",{\"1\":{\"64\":1}}],[\"hotspot\",{\"1\":{\"64\":1}}],[\"hy\",{\"1\":{\"231\":1}}],[\"hystrix会找有这个注解的方法\",{\"1\":{\"64\":1}}],[\"hystrix会监控微服务间调用的状况\",{\"1\":{\"64\":1}}],[\"hystrixcommand仅当类的注解为\",{\"1\":{\"64\":1}}],[\"hystrixcommand\",{\"1\":{\"64\":1}}],[\"hypertext\",{\"1\":{\"8\":1}}],[\"hangzhou\",{\"1\":{\"223\":2}}],[\"handleradapter\",{\"1\":{\"216\":1}}],[\"handlermapping\",{\"1\":{\"216\":1}}],[\"handler所指定的策略来处理此任务\",{\"1\":{\"216\":1}}],[\"handler\",{\"1\":{\"64\":1}}],[\"hadoop\",{\"1\":{\"217\":1}}],[\"halfmsg\",{\"1\":{\"216\":2}}],[\"half消息对消费者而言是不可见的\",{\"1\":{\"216\":2}}],[\"has\",{\"1\":{\"216\":1}}],[\"hashentry\",{\"1\":{\"83\":5}}],[\"hash方法\",{\"1\":{\"77\":1}}],[\"hashcodes\",{\"1\":{\"77\":1}}],[\"hashcode\",{\"1\":{\"75\":2,\"77\":4}}],[\"hash算法及常用的hash算法\",{\"1\":{\"64\":1}}],[\"hashing\",{\"1\":{\"64\":1}}],[\"hashset就不会让加入操作成功\",{\"1\":{\"75\":1}}],[\"hashset会假设对象没有重复出现\",{\"1\":{\"75\":1}}],[\"hashset会先计算对象的hashcode值来判断对象加入的位置\",{\"1\":{\"75\":1}}],[\"hashset如何检查重复\",{\"0\":{\"75\":1}}],[\"hashset使用成员对象来计算hashcode值\",{\"1\":{\"74\":1}}],[\"hashset区别\",{\"0\":{\"74\":1}}],[\"hashset\",{\"1\":{\"64\":3,\"74\":5,\"89\":2}}],[\"hashtable中hash数组的默认大小是11\",{\"1\":{\"64\":1}}],[\"hashtable使用enumeration\",{\"1\":{\"64\":1}}],[\"hashtable不允许<键\",{\"1\":{\"64\":1}}],[\"hashtable线程同步\",{\"1\":{\"64\":1}}],[\"hashtable\",{\"0\":{\"73\":1,\"81\":1},\"1\":{\"64\":4,\"73\":8,\"81\":4,\"90\":1}}],[\"hashtable等\",{\"1\":{\"64\":2}}],[\"hashmap和hashset\",{\"0\":{\"97\":1}}],[\"hashmap使用键\",{\"1\":{\"74\":1}}],[\"hashmap使用iterator\",{\"1\":{\"64\":1}}],[\"hashmap的扩容机制原理\",{\"1\":{\"216\":1}}],[\"hashmap的扩容因子\",{\"1\":{\"64\":1}}],[\"hashmap的底层实现\",{\"0\":{\"76\":1}}],[\"hashmap的数据结构\",{\"1\":{\"64\":1}}],[\"hashmap的死循环\",{\"1\":{\"64\":2}}],[\"hashmap中hash数组的默认大小是16\",{\"1\":{\"64\":1}}],[\"hashmap允许<键\",{\"1\":{\"64\":1}}],[\"hashmap非线程同步\",{\"1\":{\"64\":1}}],[\"hashmap\",{\"0\":{\"73\":1,\"74\":1,\"79\":1,\"80\":1},\"1\":{\"64\":8,\"73\":12,\"74\":3,\"77\":5,\"79\":3,\"80\":2,\"81\":3,\"89\":3,\"90\":3}}],[\"hashmap内部结构\",{\"1\":{\"64\":1}}],[\"hashmap内部的数据结构是什么\",{\"1\":{\"64\":2}}],[\"hash\",{\"0\":{\"169\":1},\"1\":{\"48\":1,\"64\":5,\"77\":12,\"79\":3,\"169\":4}}],[\"have\",{\"1\":{\"77\":1,\"216\":1}}],[\"hessian等序列化机制\",{\"1\":{\"216\":1}}],[\"health\",{\"1\":{\"219\":1}}],[\"heapdumppath=\",{\"1\":{\"216\":1}}],[\"head各个特点和区别\",{\"1\":{\"64\":1}}],[\"head\",{\"1\":{\"50\":1,\"70\":1,\"75\":1}}],[\"hees\",{\"1\":{\"216\":1}}],[\"heterogeneous\",{\"1\":{\"10\":1}}],[\"html静态化\",{\"1\":{\"64\":1}}],[\"html5风格的java帮助文档\",{\"1\":{\"64\":1}}],[\"html\",{\"0\":{\"197\":1},\"1\":{\"8\":1,\"50\":1,\"56\":1,\"57\":5,\"64\":13,\"80\":1,\"81\":1,\"218\":2}}],[\"http等调用协议\",{\"1\":{\"216\":1}}],[\"httprequestwrapper\",{\"1\":{\"216\":1}}],[\"http和https以及tcp\",{\"0\":{\"110\":1}}],[\"http会话的四个过程\",{\"1\":{\"64\":1}}],[\"http请求报文和http响应报文\",{\"1\":{\"64\":1}}],[\"http报文内容\",{\"1\":{\"64\":1}}],[\"http中\",{\"1\":{\"64\":1}}],[\"http的请求方式有哪些\",{\"1\":{\"64\":1}}],[\"http的url由\",{\"1\":{\"35\":1}}],[\"http是无状态通信\",{\"1\":{\"64\":1}}],[\"http是不保存状态的协议\",{\"0\":{\"31\":1}}],[\"http1\",{\"1\":{\"33\":4}}],[\"http长连接\",{\"0\":{\"30\":1},\"1\":{\"30\":1}}],[\"https处理的一个过程\",{\"1\":{\"64\":1}}],[\"https协议\",{\"1\":{\"64\":2}}],[\"https除了信息安全和身份认证还有什么优点\",{\"0\":{\"60\":1}}],[\"https高\",{\"1\":{\"35\":1}}],[\"https是运行在ssl\",{\"1\":{\"35\":1}}],[\"https\",{\"0\":{\"35\":1,\"47\":1,\"48\":1,\"197\":1},\"1\":{\"13\":1,\"19\":1,\"27\":1,\"33\":1,\"35\":2,\"37\":4,\"47\":2,\"48\":3,\"49\":1,\"64\":19,\"70\":1,\"78\":1,\"80\":1,\"92\":1,\"216\":2,\"217\":2,\"218\":1,\"219\":2}}],[\"http\",{\"0\":{\"33\":1,\"35\":1,\"49\":1,\"53\":1},\"1\":{\"8\":2,\"31\":3,\"32\":1,\"33\":3,\"35\":2,\"39\":2,\"46\":2,\"47\":8,\"48\":1,\"49\":5,\"50\":2,\"51\":4,\"53\":4,\"54\":1,\"64\":14,\"81\":1,\"217\":2,\"218\":1,\"219\":5,\"231\":2}}],[\"http协议运行在tcp之上\",{\"1\":{\"35\":1}}],[\"http协议的长连接和短连接\",{\"1\":{\"30\":1}}],[\"http协议\",{\"1\":{\"8\":2,\"64\":1}}],[\"等效于执行\",{\"1\":{\"231\":1}}],[\"等开发编译工具\",{\"1\":{\"231\":1}}],[\"等信息\",{\"1\":{\"172\":1}}],[\"等价于通过\",{\"1\":{\"96\":1}}],[\"等公共方法\",{\"1\":{\"94\":1}}],[\"等会出现问题\",{\"1\":{\"64\":1}}],[\"等工厂方法来创建不可变集合\",{\"1\":{\"64\":1}}],[\"等确定下来之后\",{\"1\":{\"57\":1}}],[\"等到渲染树构建完成后\",{\"1\":{\"57\":1}}],[\"等等\",{\"1\":{\"53\":1,\"64\":1}}],[\"等方法时\",{\"1\":{\"52\":1}}],[\"等字段\",{\"1\":{\"51\":1}}],[\"等待进一步处理\",{\"1\":{\"216\":2}}],[\"等待线程终止或者超时\",{\"1\":{\"64\":1}}],[\"等待池\",{\"1\":{\"64\":1}}],[\"等待阻塞\",{\"1\":{\"64\":1}}],[\"等待时间长\",{\"1\":{\"23\":1}}],[\"等待目的端确认收到这个报文段\",{\"1\":{\"21\":1}}],[\"等待对方确认\",{\"1\":{\"21\":1,\"23\":1}}],[\"等\",{\"1\":{\"8\":1,\"48\":1,\"51\":1,\"57\":1,\"168\":1,\"169\":1,\"171\":1}}],[\"c=$country\",{\"1\":{\"223\":1}}],[\"c=4\",{\"1\":{\"216\":1}}],[\"curator\",{\"1\":{\"219\":1}}],[\"curl\",{\"1\":{\"51\":1,\"231\":1}}],[\"city=\",{\"1\":{\"223\":1}}],[\"ci\",{\"1\":{\"219\":1}}],[\"cisco\",{\"1\":{\"8\":1}}],[\"cisco公司的域名是\",{\"1\":{\"8\":1}}],[\"ctrl\",{\"1\":{\"218\":1}}],[\"cmd和entrypoint的基本使用格式分为两种\",{\"1\":{\"231\":1}}],[\"cmd和entrypoint指令都是容器运行的命令入口\",{\"1\":{\"231\":1}}],[\"cmd命令则是在容器启动后执行\",{\"1\":{\"218\":1}}],[\"cmd以及\",{\"1\":{\"218\":1}}],[\"cmd指令的目的一样\",{\"1\":{\"218\":1}}],[\"cmd\",{\"1\":{\"218\":1,\"231\":2,\"248\":1,\"253\":1}}],[\"cms优缺点\",{\"0\":{\"180\":1}}],[\"cmsfullgcsbeforecompaction\",{\"1\":{\"64\":1}}],[\"cmsfullgcsbeforecompaction=5\",{\"1\":{\"64\":1}}],[\"cms收集器\",{\"1\":{\"64\":1}}],[\"cms\",{\"0\":{\"177\":2},\"1\":{\"64\":5}}],[\"cms的concurrent\",{\"1\":{\"64\":1}}],[\"cp\",{\"1\":{\"217\":3,\"223\":2}}],[\"cpu负载很高一般是什么原因\",{\"0\":{\"204\":1}}],[\"cpu\",{\"1\":{\"64\":1,\"218\":2,\"233\":1}}],[\"cpu热点\",{\"1\":{\"64\":1}}],[\"cpu数目\",{\"1\":{\"64\":1}}],[\"cpu密集型\",{\"1\":{\"64\":3}}],[\"cd\",{\"1\":{\"217\":1,\"218\":1,\"222\":1,\"223\":1,\"231\":1}}],[\"cdn\",{\"1\":{\"45\":3}}],[\"cert\",{\"1\":{\"223\":2,\"225\":1}}],[\"centosplus\",{\"1\":{\"231\":2}}],[\"centos7\",{\"1\":{\"231\":3}}],[\"centos系统\",{\"1\":{\"231\":1}}],[\"centos\",{\"1\":{\"217\":3,\"231\":23}}],[\"ce\",{\"1\":{\"217\":6}}],[\"c三个字段从左往右去比较大小进行排序的\",{\"1\":{\"216\":1}}],[\"c三个字段的联合索引时\",{\"1\":{\"216\":1}}],[\"c三个字段建立了一个联合索引\",{\"1\":{\"216\":1}}],[\"c令牌桶算法\",{\"1\":{\"216\":1}}],[\"c并且生产者订单系统还可以提供broker回调接口\",{\"1\":{\"216\":2}}],[\"c州免防r\",{\"1\":{\"216\":1}}],[\"c如果该位置下的元素个数没有超过6\",{\"1\":{\"216\":1}}],[\"c\",{\"1\":{\"216\":40,\"218\":1,\"219\":1,\"223\":4,\"231\":8,\"246\":1}}],[\"cr\",{\"1\":{\"217\":1}}],[\"created\",{\"1\":{\"217\":2}}],[\"create\",{\"1\":{\"216\":7,\"219\":1}}],[\"crc16\",{\"1\":{\"64\":1}}],[\"crlf\",{\"1\":{\"50\":1}}],[\"cglib远胜jdk代理啊\",{\"1\":{\"64\":1}}],[\"cglib\",{\"1\":{\"64\":3}}],[\"cglib动态代理需要依赖asm包\",{\"1\":{\"64\":1}}],[\"cyclicbarrier\",{\"1\":{\"64\":1}}],[\"c下的常见类的使用\",{\"1\":{\"64\":1}}],[\"cf57726e77f2\",{\"1\":{\"64\":1}}],[\"cn=client\",{\"1\":{\"223\":1}}],[\"cn=$server\",{\"1\":{\"223\":2}}],[\"cnf\",{\"1\":{\"223\":5}}],[\"cn\",{\"1\":{\"64\":8,\"80\":1,\"223\":2}}],[\"cnblogs\",{\"1\":{\"64\":3,\"81\":1}}],[\"can\",{\"1\":{\"231\":1}}],[\"cancel\",{\"1\":{\"64\":1}}],[\"cacreateserial\",{\"1\":{\"223\":2}}],[\"cache是常用的缓存接口\",{\"1\":{\"64\":1}}],[\"cache\",{\"1\":{\"51\":1,\"216\":1,\"219\":2}}],[\"cakey\",{\"1\":{\"223\":2}}],[\"ca\",{\"1\":{\"222\":2,\"223\":12,\"224\":1,\"225\":5,\"231\":2}}],[\"cart\",{\"1\":{\"219\":2}}],[\"cap理论指出在目前的硬件条件下\",{\"1\":{\"216\":1}}],[\"cap理论是分布式领域中非常重要的一个指导理论\",{\"1\":{\"216\":1}}],[\"cap\",{\"1\":{\"73\":2,\"218\":2,\"219\":10}}],[\"capacity\",{\"1\":{\"73\":6,\"94\":2}}],[\"cap定理\",{\"1\":{\"64\":1}}],[\"cap原则\",{\"1\":{\"64\":1}}],[\"cap原理和base理论\",{\"1\":{\"64\":1}}],[\"catch\",{\"1\":{\"64\":3}}],[\"cadd53f063b9\",{\"1\":{\"64\":1}}],[\"cas和原子类的广泛使用\",{\"1\":{\"216\":1}}],[\"cas和volatile关键字\",{\"1\":{\"64\":1}}],[\"cas\",{\"1\":{\"64\":2,\"81\":1}}],[\"cli命令来启停\",{\"1\":{\"217\":1}}],[\"client\",{\"1\":{\"16\":3,\"216\":5,\"217\":1,\"219\":1,\"223\":5,\"231\":2}}],[\"close\",{\"1\":{\"231\":1}}],[\"clone\",{\"1\":{\"74\":1}}],[\"cloud电商项目微服务\",{\"1\":{\"219\":1}}],[\"cloud和dubbo并不是对立的\",{\"1\":{\"216\":1}}],[\"cloud和dubbo有哪些区别\",{\"1\":{\"216\":1}}],[\"cloud高\",{\"1\":{\"216\":1}}],[\"cloud全面\",{\"1\":{\"216\":1}}],[\"cloud是一个大而全的框架\",{\"1\":{\"216\":1}}],[\"cloud是一个微服务框架\",{\"1\":{\"216\":1}}],[\"cloud有哪些常用组件\",{\"1\":{\"216\":1}}],[\"cloud抛弃了dubbo的rpc通信\",{\"1\":{\"64\":1}}],[\"cloud的目的是微服务架构下的一站式解决方案\",{\"1\":{\"64\":1}}],[\"cloud框架里\",{\"1\":{\"64\":1}}],[\"cloud\",{\"1\":{\"64\":3,\"216\":3,\"219\":2}}],[\"cloud对比下dubbo\",{\"1\":{\"64\":2}}],[\"cloud熔断机制介绍\",{\"1\":{\"64\":2}}],[\"cluster主从模式\",{\"1\":{\"64\":1}}],[\"cluster哈希槽的算法\",{\"1\":{\"64\":1}}],[\"cluster\",{\"1\":{\"64\":2,\"216\":6,\"219\":1}}],[\"cluster把所有的物理节点映射到\",{\"1\":{\"64\":1}}],[\"clh同步队列\",{\"1\":{\"64\":1}}],[\"clh队列\",{\"1\":{\"64\":1}}],[\"classpath\",{\"1\":{\"219\":2}}],[\"classload\",{\"1\":{\"64\":1}}],[\"classcla\",{\"1\":{\"64\":3}}],[\"class\",{\"1\":{\"64\":5,\"83\":1,\"87\":1,\"94\":1,\"96\":1}}],[\"class类不会被加载\",{\"1\":{\"64\":1}}],[\"class文件结构是如何解析的\",{\"1\":{\"64\":3}}],[\"channeladminservice\",{\"1\":{\"248\":1}}],[\"channel\",{\"1\":{\"216\":1}}],[\"characterencoding=utf\",{\"1\":{\"219\":1}}],[\"characters\",{\"1\":{\"94\":1}}],[\"character\",{\"1\":{\"94\":1,\"219\":1}}],[\"charsequence\",{\"1\":{\"94\":1}}],[\"charsets\",{\"1\":{\"64\":1}}],[\"charset\",{\"1\":{\"51\":1}}],[\"char\",{\"1\":{\"94\":3}}],[\"checkback\",{\"1\":{\"216\":2}}],[\"checkthestateoflocal\",{\"1\":{\"216\":2}}],[\"chengxiao\",{\"1\":{\"81\":1}}],[\"cherish010\",{\"1\":{\"64\":1}}],[\"chrome\",{\"1\":{\"44\":3,\"51\":1,\"59\":1}}],[\"csr\",{\"1\":{\"223\":6}}],[\"css\",{\"1\":{\"56\":1,\"57\":4,\"219\":1}}],[\"css文件等\",{\"1\":{\"30\":1}}],[\"csdn\",{\"1\":{\"13\":1,\"19\":1,\"37\":3,\"64\":12}}],[\"cwnd加倍\",{\"1\":{\"26\":1}}],[\"cwnd初始值为1\",{\"1\":{\"26\":1}}],[\"cwnd\",{\"1\":{\"26\":1}}],[\"cow全称copy\",{\"1\":{\"218\":1}}],[\"cow\",{\"1\":{\"218\":2}}],[\"copy\",{\"1\":{\"218\":2,\"231\":2}}],[\"copyonwritearraylist的底层原理是怎样的\",{\"1\":{\"216\":1}}],[\"country=\",{\"1\":{\"223\":1}}],[\"count\",{\"1\":{\"94\":2}}],[\"countdownlatch表示计数器\",{\"1\":{\"216\":1}}],[\"countdownlatch和semaphore的区别和底层原理\",{\"1\":{\"216\":1}}],[\"countdownlatch\",{\"1\":{\"64\":1}}],[\"coolshell\",{\"1\":{\"80\":1}}],[\"cookie的作用是什么\",{\"0\":{\"32\":1}}],[\"cookie\",{\"1\":{\"31\":2,\"32\":9,\"51\":2}}],[\"collector\",{\"1\":{\"219\":10}}],[\"collection\",{\"0\":{\"89\":1}}],[\"collections\",{\"1\":{\"64\":1,\"69\":2,\"85\":1,\"86\":7}}],[\"collation\",{\"1\":{\"219\":1}}],[\"collation字段的结果为d\",{\"1\":{\"216\":1}}],[\"collation字段的结果为a\",{\"1\":{\"216\":1}}],[\"collisions\",{\"1\":{\"77\":1}}],[\"core\",{\"1\":{\"64\":5}}],[\"corepoolsize时\",{\"1\":{\"216\":1}}],[\"corepoolsize\",{\"1\":{\"64\":3}}],[\"codec\",{\"1\":{\"216\":1}}],[\"code\",{\"1\":{\"54\":1}}],[\"connecting\",{\"1\":{\"231\":1}}],[\"connectiontimeoutms\",{\"1\":{\"219\":1}}],[\"connection的三个方法与事务有关\",{\"1\":{\"64\":1}}],[\"connection\",{\"1\":{\"30\":1,\"51\":2,\"55\":1}}],[\"connecturl\",{\"1\":{\"219\":1}}],[\"conditionalonbean等等\",{\"1\":{\"216\":1}}],[\"conditionalonclass技术来判断当前classpath中是否存在tomcat依赖\",{\"1\":{\"216\":1}}],[\"conditionalonclass\",{\"1\":{\"216\":1}}],[\"conditional注解扩展了很多其他的条件注解\",{\"1\":{\"216\":1}}],[\"con\",{\"1\":{\"64\":4}}],[\"conf文件内容如下\",{\"1\":{\"219\":1}}],[\"conf配置文件\",{\"1\":{\"219\":1}}],[\"conf\",{\"1\":{\"217\":1,\"219\":12}}],[\"confrmationisnotreceived\",{\"1\":{\"216\":2}}],[\"configs\",{\"1\":{\"219\":2}}],[\"config\",{\"1\":{\"216\":1,\"217\":2,\"219\":2}}],[\"configuration注解类上的\",{\"1\":{\"216\":1}}],[\"configuration\",{\"1\":{\"64\":4,\"216\":2}}],[\"confirm\",{\"1\":{\"64\":3}}],[\"conflict\",{\"1\":{\"33\":1}}],[\"concurrency\",{\"1\":{\"64\":1}}],[\"concurrentlinkedqueue\",{\"1\":{\"64\":1}}],[\"concurrentmodificationexception\",{\"1\":{\"64\":1}}],[\"concurrenthashmap取消了segment分段锁\",{\"1\":{\"84\":1}}],[\"concurrenthashmap线程安全的具体实现方式\",{\"0\":{\"82\":1}}],[\"concurrenthashmap\",{\"0\":{\"81\":1},\"1\":{\"64\":1,\"73\":1,\"80\":1,\"81\":3,\"83\":2}}],[\"concurrenthashmap的扩容机制\",{\"1\":{\"216\":1}}],[\"concurrenthashmap的红黑树实现分析\",{\"1\":{\"64\":2}}],[\"concurrenthashmap的原理与区别\",{\"1\":{\"64\":1}}],[\"concurrenthashmap在jdk1\",{\"1\":{\"64\":1}}],[\"concurrent\",{\"1\":{\"64\":2}}],[\"constant\",{\"1\":{\"77\":1}}],[\"consumer\",{\"1\":{\"64\":1,\"216\":2}}],[\"consistent\",{\"1\":{\"64\":1,\"216\":1}}],[\"consistenthash\",{\"1\":{\"64\":1}}],[\"consistency\",{\"1\":{\"64\":1,\"216\":1}}],[\"console\",{\"1\":{\"64\":1,\"217\":1,\"219\":3}}],[\"context\",{\"1\":{\"219\":1}}],[\"content\",{\"1\":{\"33\":1,\"45\":1,\"51\":1,\"52\":1}}],[\"containers\",{\"1\":{\"218\":1}}],[\"containerport\",{\"1\":{\"217\":4}}],[\"container\",{\"1\":{\"217\":3,\"218\":3,\"219\":30}}],[\"controller\",{\"1\":{\"64\":1,\"216\":3}}],[\"control\",{\"1\":{\"9\":1,\"51\":1,\"64\":2}}],[\"common\",{\"1\":{\"219\":3}}],[\"command\",{\"1\":{\"217\":1,\"219\":7,\"231\":3}}],[\"community\",{\"1\":{\"217\":1}}],[\"commitorrollback\",{\"1\":{\"216\":4}}],[\"commit\",{\"1\":{\"64\":3,\"216\":2}}],[\"commited\",{\"1\":{\"64\":1}}],[\"com过程\",{\"1\":{\"64\":1}}],[\"compose主要用在单物理机内扩容的情况\",{\"1\":{\"219\":1}}],[\"compose里的服务名\",{\"1\":{\"219\":1}}],[\"compose命令\",{\"1\":{\"219\":1}}],[\"compose来统一编排电商项目的五个微服务\",{\"1\":{\"219\":1}}],[\"compose来统一编排\",{\"1\":{\"219\":1}}],[\"compose来轻松\",{\"1\":{\"219\":1}}],[\"compose编排spring\",{\"1\":{\"219\":1}}],[\"compose会尝试pull下来\",{\"1\":{\"219\":1}}],[\"compose内部的容器之间可以用服务名相互访问\",{\"1\":{\"219\":1}}],[\"compose内的所有容器都会加入此网络\",{\"1\":{\"219\":1}}],[\"compose运行目录下的所有文件\",{\"1\":{\"219\":1}}],[\"compose将所管理的容器分为三层\",{\"1\":{\"219\":1}}],[\"compose管理容器的结构\",{\"1\":{\"219\":1}}],[\"compose启动会做几件事\",{\"1\":{\"219\":1}}],[\"compose的使用非常简单\",{\"1\":{\"219\":1}}],[\"compose的安装有多种方式\",{\"1\":{\"219\":1}}],[\"compose的安装\",{\"1\":{\"219\":1}}],[\"compose入门示例\",{\"1\":{\"219\":1}}],[\"compose安装步骤\",{\"1\":{\"219\":1}}],[\"compose\",{\"1\":{\"219\":59,\"230\":1,\"240\":1}}],[\"compose简称为\",{\"1\":{\"219\":1}}],[\"compose介绍\",{\"1\":{\"219\":1}}],[\"compose项目部署\",{\"0\":{\"219\":1}}],[\"componentscan\",{\"1\":{\"216\":1}}],[\"component时才会发挥作用\",{\"1\":{\"64\":1}}],[\"compute\",{\"1\":{\"216\":1}}],[\"computeencode\",{\"1\":{\"216\":1}}],[\"completed\",{\"1\":{\"216\":1}}],[\"comparable接口实际上是出自java\",{\"1\":{\"85\":1}}],[\"comparable<person>\",{\"1\":{\"87\":1}}],[\"comparable<\",{\"1\":{\"69\":1}}],[\"comparable\",{\"0\":{\"85\":1},\"1\":{\"64\":2}}],[\"comparator<integer>\",{\"1\":{\"86\":1}}],[\"comparator定制排序\",{\"0\":{\"86\":1}}],[\"comparator接口实际上是出自\",{\"1\":{\"85\":1}}],[\"comparator的区别\",{\"0\":{\"85\":1}}],[\"comparator\",{\"1\":{\"64\":3}}],[\"compareto\",{\"1\":{\"64\":1,\"85\":1,\"86\":1,\"87\":1}}],[\"compare\",{\"1\":{\"64\":2,\"86\":1}}],[\"compact\",{\"1\":{\"64\":1}}],[\"com\",{\"0\":{\"197\":1},\"1\":{\"8\":3,\"27\":1,\"33\":1,\"37\":1,\"41\":1,\"42\":9,\"64\":21,\"78\":1,\"81\":1,\"216\":2,\"217\":3,\"218\":1,\"219\":6,\"231\":12}}],[\"other\",{\"1\":{\"231\":1}}],[\"ou=$organizational\",{\"1\":{\"223\":1}}],[\"output\",{\"1\":{\"86\":1,\"87\":1}}],[\"outputstream\",{\"1\":{\"64\":1}}],[\"out\",{\"1\":{\"64\":3,\"86\":8,\"87\":1,\"96\":4,\"223\":8,\"231\":1}}],[\"o=$organization\",{\"1\":{\"223\":1}}],[\"os\",{\"1\":{\"218\":2,\"231\":1}}],[\"osi七层协议模型和tcp\",{\"1\":{\"64\":1}}],[\"osi七层模型\",{\"1\":{\"64\":1}}],[\"osi\",{\"1\":{\"7\":1}}],[\"osi与tcp\",{\"0\":{\"7\":1}}],[\"o相关的操作\",{\"1\":{\"216\":1}}],[\"openjdk\",{\"1\":{\"248\":1}}],[\"openssl\",{\"1\":{\"223\":8}}],[\"openfeign\",{\"1\":{\"216\":1}}],[\"opt\",{\"1\":{\"219\":3}}],[\"opts=\",{\"1\":{\"218\":1,\"219\":2}}],[\"opts\",{\"1\":{\"218\":1}}],[\"options=\",{\"1\":{\"219\":10}}],[\"options\",{\"1\":{\"50\":1}}],[\"observer节点收到leader发过来的写请求后直接执行更新本地内存数据\",{\"1\":{\"216\":1}}],[\"obj2\",{\"1\":{\"85\":1}}],[\"obj1\",{\"1\":{\"85\":1}}],[\"obj\",{\"1\":{\"85\":1}}],[\"objectoutput\",{\"1\":{\"216\":1}}],[\"objectinput\",{\"1\":{\"216\":1}}],[\"object数组\",{\"1\":{\"89\":2}}],[\"object\",{\"1\":{\"64\":1,\"68\":1,\"77\":1,\"85\":3,\"96\":1}}],[\"o苏\",{\"1\":{\"216\":1}}],[\"oom的排查思路\",{\"0\":{\"179\":1}}],[\"oop\",{\"1\":{\"64\":3}}],[\"o2\",{\"1\":{\"86\":2}}],[\"o1\",{\"1\":{\"86\":2}}],[\"overlayfs在linux主机上只有两层\",{\"1\":{\"218\":1}}],[\"overlay2的架构图如下\",{\"1\":{\"218\":1}}],[\"overlay\",{\"1\":{\"218\":1}}],[\"overflow场景\",{\"0\":{\"183\":1}}],[\"override\",{\"1\":{\"86\":1,\"87\":1}}],[\"overcommit\",{\"1\":{\"64\":1}}],[\"onrefresho\",{\"1\":{\"216\":1}}],[\"on\",{\"1\":{\"216\":6,\"218\":3,\"219\":7}}],[\"only\",{\"1\":{\"77\":1}}],[\"one\",{\"1\":{\"64\":1}}],[\"once\",{\"1\":{\"64\":9}}],[\"o处理完毕时\",{\"1\":{\"64\":1}}],[\"o请求时\",{\"1\":{\"64\":1}}],[\"off是什么意思\",{\"1\":{\"253\":1}}],[\"off\",{\"1\":{\"253\":1}}],[\"offical\",{\"1\":{\"217\":1}}],[\"offer的区别\",{\"1\":{\"64\":1}}],[\"ofentries\",{\"1\":{\"64\":1}}],[\"of\",{\"1\":{\"64\":4,\"73\":1,\"77\":1,\"94\":1,\"231\":3}}],[\"o\",{\"1\":{\"64\":35,\"68\":2,\"69\":2,\"87\":3,\"218\":4,\"231\":1}}],[\"o多路复用\",{\"1\":{\"64\":1}}],[\"old\",{\"1\":{\"231\":2}}],[\"old收集器\",{\"1\":{\"64\":1}}],[\"oldgen区内存不足\",{\"1\":{\"64\":1}}],[\"orm\",{\"1\":{\"216\":1}}],[\"order=1\",{\"1\":{\"219\":1}}],[\"order=2\",{\"1\":{\"219\":1}}],[\"order\",{\"1\":{\"219\":21}}],[\"orderservice对象\",{\"1\":{\"216\":1}}],[\"orderservice\",{\"1\":{\"216\":1}}],[\"order2\",{\"1\":{\"64\":6}}],[\"order1\",{\"1\":{\"64\":6}}],[\"organizational\",{\"1\":{\"223\":1}}],[\"organization=\",{\"1\":{\"223\":1}}],[\"org\",{\"1\":{\"64\":8,\"231\":3}}],[\"orient\",{\"1\":{\"64\":1}}],[\"or\",{\"1\":{\"47\":1,\"217\":1,\"219\":1}}],[\"oracle\",{\"1\":{\"8\":2,\"64\":1}}],[\"公平锁加锁\",{\"1\":{\"216\":1}}],[\"公钥加密需要私钥解密\",{\"1\":{\"35\":1}}],[\"公司的域名是\",{\"1\":{\"8\":2}}],[\"公众号后台回复\",{\"1\":{\"6\":1,\"66\":1,\"75\":1}}],[\"公众号同名\",{\"1\":{\"6\":1,\"66\":1,\"75\":1}}],[\"而真正运行我们的\",{\"1\":{\"249\":1}}],[\"而底层镜像只需要拉取一次\",{\"1\":{\"245\":1}}],[\"而底层则通过构造http请求来调用远端的方法\",{\"1\":{\"216\":1}}],[\"而使用cmd设置的命令则可以被docker\",{\"1\":{\"231\":1}}],[\"而使用\",{\"1\":{\"231\":1}}],[\"而使用spring\",{\"1\":{\"216\":1}}],[\"而可能经常发生改变的指令放在\",{\"1\":{\"231\":1}}],[\"而docker\",{\"1\":{\"219\":1}}],[\"而docker由于直接利用宿主机的操作系统\",{\"1\":{\"218\":1}}],[\"而镜像标签则可理解为jar包的版本号\",{\"1\":{\"217\":1}}],[\"而b+树通过对数据进行排序所以是可以提高查询速度的\",{\"1\":{\"216\":1}}],[\"而缓存击穿是指某一个热点key突然失效\",{\"1\":{\"216\":1}}],[\"而netty封装的是底层io模型\",{\"1\":{\"216\":1}}],[\"而直接实现转移\",{\"1\":{\"216\":1}}],[\"而导致系统对外出现异常\",{\"1\":{\"216\":1}}],[\"而我们通过构造方法注入时\",{\"1\":{\"216\":1}}],[\"而一旦后续不用spring了\",{\"1\":{\"216\":1}}],[\"而一个进程可以有多个线程\",{\"1\":{\"64\":1}}],[\"而applicationcontext继承了beanfactory\",{\"1\":{\"216\":1}}],[\"而a并不知道\",{\"1\":{\"23\":1}}],[\"而这其实就是第二个问题的答案\",{\"1\":{\"216\":1}}],[\"而这些线程并发执行遇到资源竞争时\",{\"1\":{\"216\":1}}],[\"而这些线程可能会同时运行这段代码\",{\"1\":{\"64\":1}}],[\"而这些\",{\"1\":{\"216\":1}}],[\"而这些集群环境有一个统一的特点\",{\"1\":{\"216\":1}}],[\"而在其它层都以\",{\"1\":{\"216\":1}}],[\"而在分布式架构中\",{\"1\":{\"216\":1}}],[\"而在这个前提下\",{\"1\":{\"216\":1}}],[\"而在tomcat中\",{\"1\":{\"216\":1}}],[\"而在mysql8中则真正从底层支持了降序索引\",{\"1\":{\"216\":1}}],[\"而每个应用中都存在很多类\",{\"1\":{\"216\":1}}],[\"而没有体现在线程被唤醒阶段\",{\"1\":{\"216\":1}}],[\"而线程对象是通过强引用指向threadlocalmap\",{\"1\":{\"216\":1}}],[\"而接口级注册\",{\"1\":{\"216\":1}}],[\"而如果过半机制的条件是set\",{\"1\":{\"216\":1}}],[\"而如果我们现在对t1创建一个索引\",{\"1\":{\"216\":1}}],[\"而如果我们利用排好序之后的存储方式\",{\"1\":{\"216\":1}}],[\"而如果我们将上面的数据按照a字段的大小来进行排序\",{\"1\":{\"216\":1}}],[\"而如果我们基于上面的这种存储方式\",{\"1\":{\"216\":1}}],[\"而tomcat把线程数设置为200\",{\"1\":{\"216\":1}}],[\"而cmd指令只能单独使用\",{\"1\":{\"231\":1}}],[\"而cow技术可以让所有的容器共享image的文件系统\",{\"1\":{\"218\":1}}],[\"而c字段是按升序排的\",{\"1\":{\"216\":1}}],[\"而cglib更新频率相对来说比较低了\",{\"1\":{\"64\":1}}],[\"而降序就是大的在上\",{\"1\":{\"216\":1}}],[\"而大家应该都知道\",{\"1\":{\"216\":1}}],[\"而排好序之后的数据是能够提高查询速度\",{\"1\":{\"216\":1}}],[\"而2222b中的b\",{\"1\":{\"216\":1}}],[\"而对于一次下单\",{\"1\":{\"216\":1}}],[\"而对于我们的项目而言\",{\"1\":{\"216\":1}}],[\"而对于应用级注册\",{\"1\":{\"216\":1}}],[\"而对降序索引比较陌生\",{\"1\":{\"216\":1}}],[\"而对象的行为\",{\"1\":{\"64\":1}}],[\"而linkedlist的空间花费则体现在它的每一个元素都需要消耗比arraylist更多的空间\",{\"1\":{\"68\":1}}],[\"而linkedlist内部使用双向链表\",{\"1\":{\"64\":1}}],[\"而后通过异常陷入内核分配真正的物理内存\",{\"1\":{\"64\":1}}],[\"而另一个则是第三方的开源库\",{\"1\":{\"64\":1}}],[\"而年老代仍旧使用串行收集\",{\"1\":{\"64\":1}}],[\"而更接近于自然方式的思考\",{\"1\":{\"64\":1}}],[\"而堆是为栈进行数据存储服务\",{\"1\":{\"64\":1}}],[\"而堆是存储的单位\",{\"1\":{\"64\":1}}],[\"而堆不同\",{\"1\":{\"64\":1}}],[\"而堆代表了数据\",{\"1\":{\"64\":1}}],[\"而堆只负责存储对象信息\",{\"1\":{\"64\":1}}],[\"而堆则是所有线程共享的\",{\"1\":{\"64\":1}}],[\"而无写操作\",{\"1\":{\"64\":1}}],[\"而由不使用资源的第三方管理\",{\"1\":{\"64\":1}}],[\"而vector则是100\",{\"1\":{\"64\":2}}],[\"而\",{\"1\":{\"64\":1,\"68\":1,\"69\":2,\"70\":1,\"73\":1,\"94\":1,\"96\":1,\"216\":1}}],[\"而parallel几乎没有在应用线程上做任何事情\",{\"1\":{\"64\":1}}],[\"而非是整个jdk框架了\",{\"1\":{\"64\":1}}],[\"而触发minorgc\",{\"1\":{\"64\":1}}],[\"而springboot的starter机制就是帮我们更便捷的添加相关的bean\",{\"1\":{\"216\":1}}],[\"而spring\",{\"1\":{\"64\":1}}],[\"而synchronized则可以保证变量的修改可见性和原子性\",{\"1\":{\"64\":1}}],[\"而session存储在服务器上\",{\"1\":{\"32\":1}}],[\"而https的url由\",{\"1\":{\"35\":1}}],[\"而http1\",{\"1\":{\"33\":1}}],[\"而服务器却将整个对象送过来了\",{\"1\":{\"33\":1}}],[\"而从http\",{\"1\":{\"30\":1}}],[\"而只好把后三个全部重传一次\",{\"1\":{\"24\":1}}],[\"而不应该写成这样\",{\"1\":{\"231\":1}}],[\"而不暴露给宿主机\",{\"1\":{\"219\":1}}],[\"而不需要guest\",{\"1\":{\"218\":1}}],[\"而不需要等待对方确认\",{\"1\":{\"23\":1,\"24\":1}}],[\"而不关心具体的协议\",{\"1\":{\"216\":1}}],[\"而不会被其他对象引用\",{\"1\":{\"216\":1}}],[\"而不会出现的原因就跟过半机制有关\",{\"1\":{\"216\":1}}],[\"而不用访问mysql\",{\"1\":{\"216\":1}}],[\"而不用关心接口在哪个应用\",{\"1\":{\"216\":1}}],[\"而不用创建线程\",{\"1\":{\"216\":1}}],[\"而不用去记住能够被机器直接读取的ip数串\",{\"1\":{\"8\":1}}],[\"而不是大于等于\",{\"1\":{\"216\":1}}],[\"而不是大于等于呢\",{\"1\":{\"216\":1}}],[\"而不是20\",{\"1\":{\"216\":1}}],[\"而不是300\",{\"1\":{\"216\":1}}],[\"而不是生成新的对象并改变对象引用\",{\"1\":{\"94\":1}}],[\"而不是引用本身\",{\"1\":{\"64\":1}}],[\"而不是\",{\"1\":{\"64\":1}}],[\"而不是spring\",{\"1\":{\"64\":1}}],[\"而不能对类创建动态代理\",{\"1\":{\"64\":1}}],[\"而且使用copy指令可以更好地利用构建缓存\",{\"1\":{\"231\":1}}],[\"而且可以避免镜像体积过大\",{\"1\":{\"231\":1}}],[\"而且仍然会出现数据不一致的问题\",{\"1\":{\"216\":1}}],[\"而且代码会更复杂\",{\"1\":{\"216\":1}}],[\"而且\",{\"1\":{\"216\":1}}],[\"而且如果我们的order\",{\"1\":{\"216\":1}}],[\"而且对于order\",{\"1\":{\"216\":1}}],[\"而且排好序之后的数据不仅可以提高查询速度\",{\"1\":{\"216\":1}}],[\"而且这样还有一个好处就是\",{\"1\":{\"216\":1}}],[\"而且a字段是主键\",{\"1\":{\"216\":1}}],[\"而且长度没有限制\",{\"1\":{\"64\":1}}],[\"而且也简化的c中复杂性\",{\"1\":{\"64\":1}}],[\"而且都是几个字节的一个数\",{\"1\":{\"64\":2}}],[\"而且因为是基本类型\",{\"1\":{\"64\":2}}],[\"而且其他的变量的值也和预期的是一样的\",{\"1\":{\"64\":1}}],[\"而且不会出现某些特定情况下的存储过程\",{\"1\":{\"64\":1}}],[\"而且rest相比rpc更为灵活\",{\"1\":{\"64\":1}}],[\"而且按概率使用权重后也比较均匀\",{\"1\":{\"64\":1}}],[\"而且还有可能在未来的jdk版本中不断优化性能\",{\"1\":{\"64\":1}}],[\"而且还提供了额外的特性比如\",{\"1\":{\"64\":1}}],[\"而且还提供了定位该资源的信息\",{\"1\":{\"34\":1}}],[\"而且还指明了如何\",{\"1\":{\"34\":1}}],[\"而且还要纠错\",{\"1\":{\"11\":1}}],[\"而且在数据传递时\",{\"1\":{\"20\":1}}],[\"而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的\",{\"1\":{\"16\":1}}],[\"而往往表示互联网所使用的整个tcp\",{\"1\":{\"12\":1}}],[\"而是当有新文件写入时\",{\"1\":{\"218\":1}}],[\"而是通过一个版本号来实现的\",{\"1\":{\"216\":1}}],[\"而是一个独立的节点\",{\"1\":{\"216\":1}}],[\"而是直接竞争锁\",{\"1\":{\"216\":1}}],[\"而是直接用\",{\"1\":{\"81\":1}}],[\"而是由消费者自己保存offset\",{\"1\":{\"64\":1}}],[\"而是把这个请求委托给父类的加载器去执行\",{\"1\":{\"64\":1}}],[\"而是指计算机网络体系结构模型中第三层的名称\",{\"1\":{\"10\":1}}],[\"而是多种应用可以使用同一个运输层服务\",{\"1\":{\"9\":1}}],[\"而域名就相当于其门牌地址\",{\"1\":{\"8\":1}}],[\"wget\",{\"1\":{\"231\":1}}],[\"write\",{\"1\":{\"218\":2}}],[\"writeobject\",{\"1\":{\"74\":1}}],[\"whenthefourth\",{\"1\":{\"216\":2}}],[\"while\",{\"1\":{\"4\":1}}],[\"will\",{\"1\":{\"216\":1}}],[\"wiki\",{\"1\":{\"64\":1}}],[\"wikipedia\",{\"1\":{\"64\":1}}],[\"work\",{\"1\":{\"231\":3}}],[\"workdir\",{\"1\":{\"218\":1,\"231\":2}}],[\"workergroup负责处理i\",{\"1\":{\"216\":1}}],[\"worker\",{\"1\":{\"216\":1}}],[\"workercount\",{\"1\":{\"216\":1}}],[\"workqueue\",{\"1\":{\"64\":4}}],[\"w55\",{\"1\":{\"216\":1}}],[\"wuhan\",{\"1\":{\"169\":1}}],[\"wait\",{\"1\":{\"219\":1}}],[\"wait和notify的理解与使用\",{\"1\":{\"64\":1}}],[\"wait和notify\",{\"1\":{\"64\":1}}],[\"watch机制来实现的\",{\"1\":{\"216\":1}}],[\"wa\",{\"1\":{\"216\":1}}],[\"wangwu\",{\"1\":{\"87\":1}}],[\"wyq178\",{\"1\":{\"64\":1}}],[\"weixin\",{\"1\":{\"33\":1,\"37\":1}}],[\"web大规模高并发请求和抢购的解决方案\",{\"1\":{\"64\":1}}],[\"web开发的增强\",{\"1\":{\"64\":1}}],[\"web开发增强\",{\"1\":{\"64\":1}}],[\"webmvc\",{\"1\":{\"64\":1}}],[\"webkit\",{\"1\":{\"57\":1}}],[\"web\",{\"0\":{\"58\":1},\"1\":{\"8\":1,\"39\":1,\"52\":1,\"53\":2,\"58\":3,\"59\":3,\"217\":1,\"219\":4}}],[\"www\",{\"1\":{\"8\":4,\"41\":1,\"42\":4,\"64\":10,\"81\":1,\"216\":2}}],[\"例如我们编译\",{\"1\":{\"249\":1}}],[\"例如我们要在\",{\"1\":{\"231\":1}}],[\"例如你想要在容器中安装\",{\"1\":{\"231\":1}}],[\"例如阿里\",{\"1\":{\"231\":1}}],[\"例如编译应用程序\",{\"1\":{\"231\":1}}],[\"例如安装软件包\",{\"1\":{\"231\":1}}],[\"例如add和copy\",{\"1\":{\"231\":1}}],[\"例如一个java类型的应用运行时只需要jre\",{\"1\":{\"231\":1}}],[\"例如通过shell安装\",{\"1\":{\"219\":1}}],[\"例如concurrenthashmap的源码理解以及内部实现原理\",{\"1\":{\"64\":1}}],[\"例如同一个类不同方法都有synchronized锁\",{\"1\":{\"64\":1}}],[\"例如spring\",{\"1\":{\"64\":1}}],[\"例如总公司的一个中心服务器需要收集全国便利店各个收银机的交易信息\",{\"1\":{\"64\":1}}],[\"例如可以根据每台机器的负载量\",{\"1\":{\"45\":1}}],[\"例如客户端只是需要某个对象的一部分\",{\"1\":{\"33\":1}}],[\"例如上面提到的微软公司的域名\",{\"1\":{\"8\":1}}],[\"例如\",{\"1\":{\"8\":1,\"41\":1,\"52\":1,\"216\":1,\"217\":1,\"219\":2,\"231\":4}}],[\"druid\",{\"1\":{\"219\":4}}],[\"drocketmq\",{\"1\":{\"219\":1}}],[\"dlogging\",{\"1\":{\"219\":1}}],[\"dcom\",{\"1\":{\"219\":1}}],[\"dc2\",{\"1\":{\"219\":1}}],[\"dc1\",{\"1\":{\"219\":1}}],[\"d可以后台启动\",{\"1\":{\"219\":1}}],[\"d可在后台启动\",{\"1\":{\"218\":1}}],[\"d选项\",{\"1\":{\"217\":1}}],[\"days\",{\"1\":{\"223\":3}}],[\"dao\",{\"1\":{\"219\":1}}],[\"daemon会检查镜像中的镜像层与宿主机文件系统中的镜像层进行对比\",{\"1\":{\"218\":1}}],[\"daemon通信\",{\"1\":{\"217\":1}}],[\"daemon是一个运行在宿主机\",{\"1\":{\"217\":1}}],[\"daemon\",{\"1\":{\"217\":4,\"226\":1,\"253\":1}}],[\"datasource\",{\"1\":{\"219\":2}}],[\"dataids\",{\"1\":{\"219\":1}}],[\"datavolume\",{\"1\":{\"219\":1}}],[\"database\",{\"1\":{\"219\":1}}],[\"data\",{\"1\":{\"11\":1,\"218\":1,\"219\":11}}],[\"datagram\",{\"1\":{\"9\":1}}],[\"d漏桶算法\",{\"1\":{\"216\":1}}],[\"dsw\",{\"1\":{\"219\":20}}],[\"ds\",{\"1\":{\"216\":1}}],[\"dsa等\",{\"1\":{\"35\":1}}],[\"d一旦half消息commit了\",{\"1\":{\"216\":2}}],[\"d排好序了\",{\"1\":{\"216\":1}}],[\"d的升序索引了\",{\"1\":{\"216\":1}}],[\"d的升序索引\",{\"1\":{\"216\":2}}],[\"d=4的数据也是能查询更快的\",{\"1\":{\"216\":1}}],[\"d三个字段的值是222\",{\"1\":{\"216\":1}}],[\"d三个字段的值是111\",{\"1\":{\"216\":1}}],[\"d三个字段的排序方式是desc\",{\"1\":{\"216\":2}}],[\"d三个字段的排序方式是asc\",{\"1\":{\"216\":1}}],[\"d三个字段来对数据行就行排序的\",{\"1\":{\"216\":1}}],[\"d三个字段进行排序\",{\"1\":{\"216\":1}}],[\"d三个字段创建一个联合索引\",{\"1\":{\"216\":1}}],[\"discovery\",{\"1\":{\"219\":2}}],[\"dispatcherservlet\",{\"1\":{\"216\":2}}],[\"dir\",{\"1\":{\"219\":2}}],[\"directory\",{\"1\":{\"64\":1,\"216\":1}}],[\"differ\",{\"1\":{\"77\":1}}],[\"d\",{\"1\":{\"64\":3,\"216\":20,\"217\":3,\"218\":4,\"219\":6,\"231\":1}}],[\"dfs\",{\"1\":{\"64\":1}}],[\"db\",{\"1\":{\"219\":18}}],[\"dbio\",{\"1\":{\"64\":2}}],[\"db设计\",{\"1\":{\"64\":2}}],[\"du\",{\"1\":{\"218\":2}}],[\"durability\",{\"1\":{\"64\":1}}],[\"dump线程详细信息\",{\"1\":{\"64\":1}}],[\"dubbo则更侧重于服务调用\",{\"1\":{\"216\":1}}],[\"dubbo一开始是一个rpc调用框架\",{\"1\":{\"216\":1}}],[\"dubbo中的架构设计是非常优秀的\",{\"1\":{\"216\":1}}],[\"dubbo的架构设计是怎样的\",{\"1\":{\"216\":1}}],[\"dubbo的定位始终是一款rpc框架\",{\"1\":{\"64\":1}}],[\"dubbo会将注解和服务的信息解析出来\",{\"1\":{\"216\":1}}],[\"dubbo是如何完成服务引入的\",{\"1\":{\"216\":1}}],[\"dubbo是如何完成服务导出的\",{\"1\":{\"216\":1}}],[\"dubboservice注解或\",{\"1\":{\"216\":1}}],[\"dubbo支持哪些负载均衡策略\",{\"1\":{\"216\":1}}],[\"dubbo支持几种负载均衡策略\",{\"1\":{\"64\":2}}],[\"dubbo3\",{\"1\":{\"216\":1}}],[\"dubbo再往深处\",{\"0\":{\"149\":1}}],[\"dubbo和zk连接流程\",{\"0\":{\"148\":1}}],[\"dubbo和springcloud的区别\",{\"0\":{\"147\":1}}],[\"dubbo和dubbox之间的区别\",{\"1\":{\"64\":1}}],[\"dubbo超时机制导致的雪崩连接\",{\"1\":{\"64\":1}}],[\"dubbo重试雪崩\",{\"1\":{\"64\":1}}],[\"dubbox是当当网基于dubbo上做了一些扩展\",{\"1\":{\"64\":1}}],[\"dubbo集群容错怎么做\",{\"1\":{\"64\":1}}],[\"dubbo推荐用什么协议\",{\"1\":{\"64\":1}}],[\"dubbo启动的时候支持几种配置方式\",{\"1\":{\"64\":2}}],[\"dubbo\",{\"1\":{\"64\":21,\"216\":2}}],[\"dubbo完整的一次调用链路介绍\",{\"1\":{\"64\":2}}],[\"do\",{\"1\":{\"231\":1}}],[\"does\",{\"1\":{\"231\":1}}],[\"down\",{\"1\":{\"219\":1}}],[\"dockerignore的本质是文本文件\",{\"1\":{\"231\":1}}],[\"dockerignore的定义类似于\",{\"1\":{\"231\":1}}],[\"dockerignore文件允许我们在构建时\",{\"1\":{\"231\":1}}],[\"dockerignore\",{\"1\":{\"231\":2}}],[\"dockerd\",{\"1\":{\"225\":1}}],[\"docker对单个文件的挂载需要先在宿主机建好对应文件才能挂载成功\",{\"1\":{\"219\":1}}],[\"docker同时重启容器\",{\"1\":{\"219\":1}}],[\"docker底层用了lvs等技术帮我们实现这个负载均衡\",{\"1\":{\"219\":1}}],[\"docker使用共享技术减少镜像存储空间\",{\"1\":{\"218\":1}}],[\"docker中的镜像分层技术的原理是什么呢\",{\"1\":{\"218\":1}}],[\"docker是如何将机器的资源进行隔离的\",{\"1\":{\"218\":1}}],[\"docker是一个开源的容器引擎\",{\"1\":{\"217\":1}}],[\"docker不需要和虚拟机一样重新加载一个操作系统内核\",{\"1\":{\"218\":1}}],[\"docker利用的是宿主机的内核\",{\"1\":{\"218\":1}}],[\"docker虚拟化原理\",{\"1\":{\"218\":1}}],[\"dockerfile中的env是否也是每局一层呢\",{\"1\":{\"242\":1}}],[\"dockerfile中使用该指令\",{\"1\":{\"218\":1}}],[\"dockerfile的相对位置\",{\"1\":{\"218\":1}}],[\"dockerfile的指令\",{\"1\":{\"218\":1}}],[\"dockerfile\",{\"0\":{\"231\":1},\"1\":{\"218\":1,\"219\":2,\"231\":35,\"252\":2}}],[\"dockerfile所在目录的相对路径\",{\"1\":{\"218\":1}}],[\"dockerfile常用指令\",{\"1\":{\"218\":1}}],[\"dockerfile是一个文本文件\",{\"1\":{\"218\":1}}],[\"docker自动生成\",{\"1\":{\"217\":1}}],[\"docker容器启动时执行的命令\",{\"1\":{\"218\":1}}],[\"docker容器\",{\"1\":{\"217\":1,\"218\":1}}],[\"docker容器的说明\",{\"1\":{\"217\":1}}],[\"docker就会自动从\",{\"1\":{\"217\":1}}],[\"docker就会在docker\",{\"1\":{\"217\":1}}],[\"docker宿主机ip\",{\"1\":{\"218\":2}}],[\"docker宿主机\",{\"1\":{\"217\":1}}],[\"docker让新建的容器使用已有容器的网络配置\",{\"1\":{\"217\":1}}],[\"docker会从\",{\"1\":{\"217\":1}}],[\"docker常用命令\",{\"1\":{\"217\":1}}],[\"docker仓库就可理解为某jar包的路径\",{\"1\":{\"217\":1}}],[\"docker仓库\",{\"1\":{\"217\":1}}],[\"docker镜像后\",{\"1\":{\"217\":1}}],[\"docker镜像中的程序\",{\"1\":{\"217\":1}}],[\"docker镜像是一个只读模板\",{\"1\":{\"217\":1}}],[\"docker镜像\",{\"1\":{\"217\":2}}],[\"docker客户端是\",{\"1\":{\"217\":1}}],[\"docker客户端\",{\"1\":{\"217\":1}}],[\"docker客户端与之通信\",{\"1\":{\"217\":1}}],[\"docker守护进程\",{\"1\":{\"217\":1}}],[\"docker的相关命令\",{\"1\":{\"217\":1}}],[\"docker的用户界面\",{\"1\":{\"217\":1}}],[\"docker的架构\",{\"1\":{\"217\":1}}],[\"docker的最大优势\",{\"1\":{\"217\":1}}],[\"docker的优点如下\",{\"1\":{\"217\":1}}],[\"docker改变了虚拟化的方式\",{\"1\":{\"217\":1}}],[\"docker可更快地打包\",{\"1\":{\"217\":1}}],[\"docker可将应用程序和基础设施层隔离\",{\"1\":{\"217\":1}}],[\"docker简介\",{\"1\":{\"217\":1}}],[\"docker\",{\"0\":{\"219\":1},\"1\":{\"217\":78,\"218\":20,\"219\":52,\"223\":2,\"225\":3,\"226\":1,\"228\":1,\"230\":7,\"231\":8,\"240\":1}}],[\"docker详解与部署微服务实战\",{\"0\":{\"217\":1}}],[\"docs\",{\"1\":{\"64\":8,\"219\":2}}],[\"don\",{\"1\":{\"216\":3}}],[\"dom\",{\"1\":{\"57\":3}}],[\"domain\",{\"1\":{\"8\":2}}],[\"dhc\",{\"1\":{\"59\":1}}],[\"deploy\",{\"1\":{\"219\":1}}],[\"depends\",{\"1\":{\"219\":6}}],[\"demand\",{\"1\":{\"218\":1}}],[\"demo\",{\"1\":{\"218\":2}}],[\"demos\",{\"1\":{\"64\":2}}],[\"description\",{\"1\":{\"217\":1}}],[\"desc所表达的意思就是b字段数据大者在上\",{\"1\":{\"216\":1}}],[\"desc来排序\",{\"1\":{\"216\":2}}],[\"desc排序呢\",{\"1\":{\"216\":1}}],[\"desc排序就是\",{\"1\":{\"216\":1}}],[\"desc进行排序就是\",{\"1\":{\"216\":1}}],[\"desc呢\",{\"1\":{\"216\":1}}],[\"desc就从下往上遍历即可\",{\"1\":{\"216\":1}}],[\"desc\",{\"1\":{\"216\":21}}],[\"design\",{\"1\":{\"64\":1}}],[\"dead\",{\"1\":{\"64\":1}}],[\"decodecompute\",{\"1\":{\"216\":1}}],[\"decode\",{\"1\":{\"216\":2}}],[\"decr\",{\"1\":{\"168\":1}}],[\"decrby\",{\"1\":{\"64\":1}}],[\"decision\",{\"1\":{\"64\":1}}],[\"defined\",{\"1\":{\"64\":1}}],[\"defaultadvisorchainfactory\",{\"1\":{\"216\":1}}],[\"defaultbeannamegenerator\",{\"1\":{\"216\":1}}],[\"default\",{\"1\":{\"64\":1,\"73\":1,\"77\":1,\"219\":2}}],[\"development\",{\"1\":{\"219\":1}}],[\"developerworks\",{\"1\":{\"64\":1}}],[\"devicemapper\",{\"1\":{\"218\":1}}],[\"dev\",{\"1\":{\"64\":1,\"219\":2,\"223\":1}}],[\"delayqueue\",{\"1\":{\"64\":1}}],[\"deletewhen\",{\"1\":{\"219\":1}}],[\"delete\",{\"1\":{\"50\":1}}],[\"delivery\",{\"1\":{\"45\":1}}],[\"details\",{\"1\":{\"13\":1,\"19\":1,\"37\":3,\"64\":12,\"219\":1}}],[\"dns域名解析的过程\",{\"1\":{\"64\":1}}],[\"dns解析过程\",{\"1\":{\"64\":1}}],[\"dns解析\",{\"1\":{\"27\":1}}],[\"dns\",{\"0\":{\"41\":1,\"43\":1,\"44\":1,\"45\":1},\"1\":{\"8\":1,\"39\":1,\"41\":2,\"42\":2,\"43\":2,\"44\":3,\"45\":6,\"58\":1,\"219\":6}}],[\"支持protobuf等高性能序列化协议\",{\"1\":{\"216\":1}}],[\"支持json\",{\"1\":{\"216\":1}}],[\"支持jdk动态代理\",{\"1\":{\"216\":1}}],[\"支持netty\",{\"1\":{\"216\":1}}],[\"支持dubbo\",{\"1\":{\"216\":1}}],[\"支持zookeeper\",{\"1\":{\"216\":1}}],[\"支持at\",{\"1\":{\"216\":1}}],[\"支持对象关系组件维护\",{\"1\":{\"216\":1}}],[\"支持对象与数据库的\",{\"1\":{\"216\":1}}],[\"支持的数据库mybatis\",{\"1\":{\"216\":1}}],[\"支持\",{\"1\":{\"68\":1}}],[\"支持所有国家的语言\",{\"1\":{\"64\":1}}],[\"支持iterator\",{\"1\":{\"64\":1}}],[\"支持当前事务\",{\"1\":{\"64\":3}}],[\"支持电子邮件的\",{\"1\":{\"8\":1}}],[\"支持万维网应用的\",{\"1\":{\"8\":1}}],[\"的蜗牛\",{\"0\":{\"238\":1}}],[\"的书写原则和一些重要指令有了较深的认识\",{\"1\":{\"231\":1}}],[\"的书写原则后\",{\"1\":{\"231\":1}}],[\"的exec实现的\",{\"1\":{\"231\":1}}],[\"的人来说会非常容易出错\",{\"1\":{\"231\":1}}],[\"的内容即可很明确地查看镜像的完整构建过程\",{\"1\":{\"231\":1}}],[\"的每一行指令代表一个镜像层\",{\"1\":{\"231\":1}}],[\"的每个方法\",{\"1\":{\"64\":2}}],[\"的方式执行命令\",{\"1\":{\"231\":1}}],[\"的方式构建镜像\",{\"1\":{\"231\":1}}],[\"的方法很多\",{\"1\":{\"31\":1}}],[\"的容器\",{\"1\":{\"219\":1}}],[\"的使用情况\",{\"1\":{\"218\":1}}],[\"的镜像均由各软件的官方项目组创建和维护\",{\"1\":{\"217\":1}}],[\"的包索引\",{\"1\":{\"217\":1}}],[\"的安装请参考官方文档\",{\"1\":{\"217\":1}}],[\"的安装\",{\"1\":{\"217\":1}}],[\"的后台进程\",{\"1\":{\"217\":1}}],[\"的抽象\",{\"1\":{\"216\":1}}],[\"的目的是将多个\",{\"1\":{\"216\":1}}],[\"的原因是\",{\"1\":{\"216\":1}}],[\"的引用路径找到正常对象\",{\"1\":{\"216\":1}}],[\"的老六具\",{\"1\":{\"216\":1}}],[\"的应用场景非常多\",{\"1\":{\"170\":1}}],[\"的映射表\",{\"1\":{\"169\":1}}],[\"的生命周期是\",{\"0\":{\"132\":1}}],[\"的公共父类\",{\"1\":{\"94\":1}}],[\"的构造方法都是调用父类构造方法也就是\",{\"1\":{\"94\":1}}],[\"的结构和hashmap类似\",{\"1\":{\"83\":1}}],[\"的时候已经摒弃了segment的概念\",{\"1\":{\"81\":1}}],[\"的时候会自动加上\",{\"1\":{\"42\":1}}],[\"的主过程上\",{\"1\":{\"216\":1}}],[\"的主体\",{\"1\":{\"81\":1,\"90\":1}}],[\"的主要作用就是通过服务端记录用户的状态\",{\"1\":{\"31\":1,\"32\":1}}],[\"的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务\",{\"1\":{\"9\":1}}],[\"的形式\",{\"1\":{\"81\":1,\"219\":1,\"243\":1}}],[\"的底层数据结构类似都是采用\",{\"1\":{\"81\":1}}],[\"的前提是\",{\"1\":{\"79\":1}}],[\"的长度为什么是2的幂次方\",{\"0\":{\"79\":1},\"1\":{\"79\":2}}],[\"的默认行为是对堆上的对象产生独特值\",{\"1\":{\"75\":1}}],[\"的相关规定\",{\"1\":{\"75\":1}}],[\"的源码非常非常少\",{\"1\":{\"74\":1}}],[\"的扩容机制吧\",{\"0\":{\"72\":1}}],[\"的prev指向最后一个节点\",{\"1\":{\"70\":1}}],[\"的遍历方式选择\",{\"1\":{\"69\":1}}],[\"的实现为一个双向链表\",{\"1\":{\"170\":1}}],[\"的实现类都遵循了统一约束比如唯一性\",{\"1\":{\"64\":1}}],[\"的实现类\",{\"1\":{\"64\":1}}],[\"的实现类比如\",{\"1\":{\"64\":1}}],[\"的实例\",{\"1\":{\"69\":1}}],[\"的存储分配到对应的master上\",{\"1\":{\"64\":1}}],[\"的理解\",{\"1\":{\"64\":1}}],[\"的传值调用\",{\"1\":{\"64\":1}}],[\"的数据结构\",{\"1\":{\"81\":1}}],[\"的数据产生不利的影响\",{\"1\":{\"64\":1}}],[\"的数据导致多次查询结果不一致\",{\"1\":{\"64\":2}}],[\"的效率高\",{\"1\":{\"64\":1}}],[\"的行锁是在有索引的情况下\",{\"1\":{\"64\":1}}],[\"的定义进行排序的有序容器\",{\"1\":{\"64\":1}}],[\"的次数\",{\"1\":{\"58\":1}}],[\"的渲染过程\",{\"1\":{\"57\":1}}],[\"的执行机制就可以看做是一个主线程加上一个任务队列\",{\"1\":{\"57\":1}}],[\"的解析是由浏览器中的\",{\"1\":{\"57\":1}}],[\"的重定向技术\",{\"1\":{\"45\":1}}],[\"的过程\",{\"1\":{\"43\":1}}],[\"的\",{\"1\":{\"42\":2,\"43\":1,\"64\":4,\"77\":7,\"96\":2,\"216\":2,\"231\":1}}],[\"的区别是什么\",{\"1\":{\"216\":1}}],[\"的区别主要体现在实现线程安全的方式上不同\",{\"1\":{\"81\":1}}],[\"的区别\",{\"0\":{\"35\":1,\"73\":1,\"81\":1,\"133\":1}}],[\"的一些内容\",{\"1\":{\"33\":1}}],[\"的状态变量\",{\"1\":{\"26\":1}}],[\"的接收端会丢弃重复的数据\",{\"1\":{\"21\":1}}],[\"的作用是实现相邻计算机节点之间比特流的透明传送\",{\"1\":{\"12\":1}}],[\"的对比见问题三\",{\"1\":{\"9\":1}}],[\"的任务是通过应用进程间的交互来完成特定网络应用\",{\"1\":{\"8\":1}}],[\"的优点\",{\"1\":{\"7\":1}}],[\"a参数\",{\"1\":{\"217\":1}}],[\"aio分别是什么\",{\"1\":{\"216\":1}}],[\"aio和nio\",{\"1\":{\"64\":1}}],[\"a固定窗口\",{\"1\":{\"216\":1}}],[\"a生产者订单系统先发送一条half消息到broker\",{\"1\":{\"216\":2}}],[\"available\",{\"1\":{\"216\":1}}],[\"availability\",{\"1\":{\"216\":1}}],[\"average高但是cpu使用率不高是什么原因\",{\"0\":{\"207\":1}}],[\"average的区别\",{\"0\":{\"206\":1}}],[\"admin的监控\",{\"1\":{\"219\":1}}],[\"advisedsupportlistener\",{\"1\":{\"216\":1}}],[\"advisoradapter\",{\"1\":{\"216\":1}}],[\"add则支持更多文件来源类型\",{\"1\":{\"231\":1}}],[\"add和copy指令功能类似\",{\"1\":{\"231\":1}}],[\"additional\",{\"1\":{\"231\":2}}],[\"address\",{\"1\":{\"231\":1}}],[\"addr\",{\"1\":{\"219\":3}}],[\"addr=rocketmq\",{\"1\":{\"219\":1}}],[\"add=sys\",{\"1\":{\"218\":2}}],[\"add\",{\"1\":{\"68\":2,\"74\":1,\"86\":8,\"217\":1,\"218\":2,\"219\":12,\"230\":1,\"231\":2}}],[\"a类里有一个属性c\",{\"1\":{\"216\":1}}],[\"a统计每个下标位置的元素个数\",{\"1\":{\"216\":1}}],[\"aes256\",{\"1\":{\"223\":1}}],[\"aes等\",{\"1\":{\"35\":1}}],[\"aeqb\",{\"1\":{\"96\":1}}],[\"a==b\",{\"1\":{\"96\":1}}],[\"aa==bb\",{\"1\":{\"96\":1}}],[\"aa\",{\"1\":{\"96\":2}}],[\"absolute\",{\"1\":{\"219\":1}}],[\"abstractapplicationcontext\",{\"1\":{\"216\":1}}],[\"abstract\",{\"1\":{\"94\":1}}],[\"abstractstringbuilder\",{\"1\":{\"94\":7}}],[\"abc\",{\"1\":{\"216\":2}}],[\"ab\",{\"1\":{\"96\":4}}],[\"age\",{\"1\":{\"87\":11,\"169\":1}}],[\"agent\",{\"1\":{\"51\":1,\"219\":40}}],[\"at\",{\"1\":{\"64\":3,\"77\":2}}],[\"atomicinteger和volatile等线程安全操作的关键字的理解和使用\",{\"1\":{\"64\":1}}],[\"atomicity\",{\"1\":{\"64\":1}}],[\"aqs\",{\"0\":{\"114\":1},\"1\":{\"64\":1}}],[\"aqm\",{\"1\":{\"26\":1}}],[\"after拼接起来以在链表中删除掉自己\",{\"1\":{\"64\":1}}],[\"after指针\",{\"1\":{\"64\":1}}],[\"an\",{\"1\":{\"219\":1}}],[\"annotationawareordercomparator\",{\"1\":{\"216\":1}}],[\"annotation\",{\"1\":{\"64\":1}}],[\"and\",{\"1\":{\"26\":1,\"64\":2,\"216\":4,\"219\":1,\"231\":2}}],[\"asia\",{\"1\":{\"231\":3}}],[\"async\",{\"1\":{\"219\":2}}],[\"asynchronous\",{\"1\":{\"57\":1}}],[\"aspecu注解的bean中所定义的advisor\",{\"1\":{\"216\":1}}],[\"aspectj的底层技术是静态代理\",{\"1\":{\"64\":1}}],[\"aspectj的底层技术\",{\"1\":{\"64\":1}}],[\"aspect\",{\"1\":{\"64\":1}}],[\"asc就从上往下遍历即可\",{\"1\":{\"216\":1}}],[\"asc表示的是升序\",{\"1\":{\"216\":1}}],[\"asc\",{\"1\":{\"216\":14}}],[\"as\",{\"1\":{\"64\":1,\"231\":1}}],[\"alpinecopy\",{\"1\":{\"248\":1}}],[\"alpine\",{\"1\":{\"245\":1}}],[\"always\",{\"1\":{\"219\":5}}],[\"alternate\",{\"1\":{\"219\":1}}],[\"alias\",{\"1\":{\"219\":1}}],[\"aliyuncs\",{\"1\":{\"217\":1}}],[\"aliyun\",{\"1\":{\"217\":2}}],[\"alive不会永久保持连接\",{\"1\":{\"30\":1}}],[\"alive\",{\"1\":{\"30\":1,\"33\":1,\"51\":1,\"64\":1}}],[\"allocate\",{\"1\":{\"218\":1}}],[\"allocation\",{\"1\":{\"64\":1}}],[\"all\",{\"1\":{\"216\":1}}],[\"allkeys\",{\"1\":{\"64\":2}}],[\"aop的原理\",{\"1\":{\"64\":1}}],[\"aop的实现原理和场景\",{\"1\":{\"64\":2}}],[\"aop编程及性能监控\",{\"1\":{\"64\":1}}],[\"aop基于注解配置的情况下\",{\"1\":{\"64\":1}}],[\"aop提供了对jdk动态代理的支持以及cglib的支持\",{\"1\":{\"64\":1}}],[\"aop采用的是动态代理\",{\"1\":{\"64\":1}}],[\"aop和aspectj\",{\"1\":{\"64\":1}}],[\"aop\",{\"1\":{\"64\":6,\"216\":2}}],[\"aop原理\",{\"1\":{\"64\":2}}],[\"apt\",{\"1\":{\"217\":4}}],[\"apr这种相比于bio更加高效的io模型\",{\"1\":{\"216\":1}}],[\"apps\",{\"1\":{\"219\":1}}],[\"app\",{\"1\":{\"218\":4,\"219\":18}}],[\"appclassloader的父加载器是extclassloader\",{\"1\":{\"216\":1}}],[\"appendonly\",{\"1\":{\"219\":1}}],[\"append\",{\"1\":{\"94\":1}}],[\"appendable\",{\"1\":{\"94\":1}}],[\"approximately\",{\"1\":{\"77\":1}}],[\"applicationlistener\",{\"1\":{\"216\":1}}],[\"applicationlistenermethodadapter\",{\"1\":{\"216\":1}}],[\"applicationeventpublisher等接口\",{\"1\":{\"216\":1}}],[\"applicationcontext和beanfactory有什么区别\",{\"1\":{\"216\":1}}],[\"application\",{\"0\":{\"133\":1},\"1\":{\"8\":1,\"52\":1,\"64\":1,\"219\":2}}],[\"apache\",{\"1\":{\"64\":9}}],[\"api或者\",{\"1\":{\"217\":1}}],[\"api完成的\",{\"1\":{\"64\":1}}],[\"api配置\",{\"1\":{\"64\":1}}],[\"api和tomcat等\",{\"1\":{\"64\":1}}],[\"api接口数据加解密\",{\"1\":{\"64\":1}}],[\"api\",{\"1\":{\"59\":1,\"64\":1}}],[\"authcenter\",{\"1\":{\"219\":12}}],[\"authorization\",{\"1\":{\"51\":1}}],[\"automake\",{\"1\":{\"231\":1}}],[\"automated\",{\"1\":{\"217\":1}}],[\"automatic\",{\"1\":{\"22\":1}}],[\"autoproxy\",{\"1\":{\"219\":1}}],[\"auto\",{\"1\":{\"87\":1}}],[\"autowired都可以说\",{\"1\":{\"216\":1}}],[\"autowired注解就没有用了\",{\"1\":{\"216\":1}}],[\"autowired注解是有spring提供的\",{\"1\":{\"216\":1}}],[\"autowired字段注入\",{\"1\":{\"216\":1}}],[\"autowired\",{\"1\":{\"216\":2}}],[\"autowire\",{\"1\":{\"64\":1}}],[\"active=cloud\",{\"1\":{\"248\":1}}],[\"active\",{\"1\":{\"219\":3}}],[\"actives=\",{\"1\":{\"64\":4}}],[\"actives\",{\"1\":{\"64\":1}}],[\"accelerator\",{\"1\":{\"217\":1}}],[\"acceptor\",{\"1\":{\"216\":1}}],[\"accept\",{\"1\":{\"51\":10,\"216\":3}}],[\"accordingtotransactionstatus\",{\"1\":{\"216\":2}}],[\"ack后\",{\"1\":{\"216\":1}}],[\"acknowledgement\",{\"1\":{\"17\":1}}],[\"ack\",{\"0\":{\"18\":1},\"1\":{\"15\":2,\"17\":2,\"18\":3,\"23\":1,\"216\":1}}],[\"a收到重复的确认后\",{\"1\":{\"23\":1}}],[\"a收到了b第一次发送的对m1的确认消息\",{\"1\":{\"23\":1}}],[\"a也收到了2份确认消息\",{\"1\":{\"23\":1}}],[\"a发送m1消息\",{\"1\":{\"23\":1}}],[\"a能重传\",{\"1\":{\"23\":1}}],[\"a重传m1消息\",{\"1\":{\"23\":2}}],[\"a\",{\"1\":{\"19\":4,\"27\":1,\"33\":1,\"37\":1,\"64\":1,\"73\":1,\"77\":1,\"96\":4,\"216\":7,\"217\":1,\"219\":3,\"223\":1,\"231\":1}}],[\"arch=$basearch\",{\"1\":{\"231\":3}}],[\"args\",{\"1\":{\"87\":1,\"96\":1,\"219\":1}}],[\"arguments\",{\"1\":{\"64\":1}}],[\"arp协议和rarp协议\",{\"1\":{\"64\":1}}],[\"arp\",{\"1\":{\"64\":1}}],[\"are\",{\"1\":{\"64\":1,\"231\":2}}],[\"arq包括停止等待arq协议和连续arq协议\",{\"1\":{\"22\":1}}],[\"arq\",{\"1\":{\"22\":1,\"23\":2,\"24\":1}}],[\"arq协议\",{\"0\":{\"22\":1},\"1\":{\"21\":1}}],[\"articles\",{\"1\":{\"80\":1}}],[\"article\",{\"1\":{\"13\":1,\"19\":1,\"37\":3,\"64\":12}}],[\"arrayblockingqueue\",{\"1\":{\"64\":1}}],[\"arraydeque\",{\"1\":{\"64\":1}}],[\"arraylist更适合随机查找\",{\"1\":{\"216\":1}}],[\"arraylist底层是基于数组实现的\",{\"1\":{\"216\":1}}],[\"arraylist和linkedlist有哪些区别\",{\"1\":{\"216\":1}}],[\"arraylist和linkedlist内部实现\",{\"1\":{\"64\":2}}],[\"arraylist<integer>\",{\"1\":{\"86\":2}}],[\"arraylist不是同步的\",{\"1\":{\"71\":1}}],[\"arraylist的空\",{\"1\":{\"68\":1}}],[\"arraylist都是以类似数组的形式存储在内存中\",{\"1\":{\"64\":1}}],[\"arraylist在元素填满容器时会自动扩充容器大小的50\",{\"1\":{\"64\":2}}],[\"arraylist内部使用数组\",{\"1\":{\"64\":1}}],[\"arraylist\",{\"0\":{\"68\":1,\"71\":1,\"72\":1},\"1\":{\"64\":12,\"68\":5,\"69\":4,\"86\":20,\"89\":1}}],[\"arr\",{\"1\":{\"1\":7,\"2\":7,\"3\":8,\"4\":23}}],[\"tx\",{\"1\":{\"219\":2}}],[\"t选项指定了镜像的标签\",{\"1\":{\"218\":1}}],[\"t指定镜像名字\",{\"1\":{\"218\":1}}],[\"tulingmall\",{\"1\":{\"219\":63}}],[\"tuling\",{\"1\":{\"218\":3}}],[\"turn\",{\"1\":{\"37\":1}}],[\"timezone\",{\"1\":{\"231\":1}}],[\"timeout\",{\"1\":{\"219\":1}}],[\"timeunit\",{\"1\":{\"64\":3}}],[\"tidying\",{\"1\":{\"216\":1}}],[\"t包线口g8\",{\"1\":{\"216\":1}}],[\"t1是innodb的存储引擎\",{\"1\":{\"216\":1}}],[\"t1\",{\"1\":{\"216\":15}}],[\"two\",{\"1\":{\"73\":1}}],[\"twitter的finagle等\",{\"1\":{\"64\":1}}],[\"t\",{\"1\":{\"69\":1,\"216\":3,\"218\":3}}],[\"t>>\",{\"1\":{\"69\":1}}],[\"ttl\",{\"1\":{\"64\":1}}],[\"tem\",{\"1\":{\"231\":2}}],[\"terminated\",{\"1\":{\"216\":4}}],[\"tech\",{\"0\":{\"197\":1}}],[\"telnet或其他协议\",{\"1\":{\"64\":1}}],[\"test\",{\"1\":{\"219\":1}}],[\"test1\",{\"1\":{\"96\":1}}],[\"testfile\",{\"1\":{\"64\":3}}],[\"testfiledir\",{\"1\":{\"64\":4}}],[\"testloopoutallfilename\",{\"1\":{\"64\":2}}],[\"thin\",{\"1\":{\"219\":2}}],[\"this\",{\"1\":{\"64\":1,\"73\":3,\"77\":1,\"87\":6,\"231\":1}}],[\"that\",{\"1\":{\"77\":2,\"231\":3}}],[\"the\",{\"1\":{\"73\":1,\"94\":3,\"216\":2,\"219\":3,\"231\":7}}],[\"throw\",{\"1\":{\"73\":2}}],[\"thrownew\",{\"1\":{\"64\":6}}],[\"threac\",{\"1\":{\"216\":1}}],[\"threads\",{\"1\":{\"216\":1,\"219\":1}}],[\"threadscheduledexecutor\",{\"1\":{\"64\":1}}],[\"threadpool\",{\"1\":{\"216\":1}}],[\"threadpool的深入考察\",{\"1\":{\"64\":1}}],[\"threadpoolexecutor\",{\"1\":{\"64\":4}}],[\"thread调用exit方法如下\",{\"1\":{\"64\":1}}],[\"thread类会进行一些清理工作\",{\"1\":{\"64\":1}}],[\"thread\",{\"1\":{\"64\":1,\"216\":2}}],[\"threadfactory\",{\"1\":{\"64\":2}}],[\"threadlocalmap也是通过强引用指向entry对象\",{\"1\":{\"216\":1}}],[\"threadlocal\",{\"0\":{\"113\":1}}],[\"threadlocal使用场景及注意事项\",{\"1\":{\"64\":1}}],[\"threadlocal在没有线程池使用的情况下\",{\"1\":{\"64\":1}}],[\"threadlocal变量是维护在thread内部的\",{\"1\":{\"64\":1}}],[\"threadlocal的底层原理\",{\"1\":{\"216\":1}}],[\"threadlocal的适用场景\",{\"1\":{\"64\":1}}],[\"threadlocal的使用场景和原理\",{\"1\":{\"64\":2}}],[\"threadlocal是各线程将值存入该线程的map中\",{\"1\":{\"64\":1}}],[\"threadlocal是用来维护本线程的变量的\",{\"1\":{\"64\":1}}],[\"threadlocal原理及常用应用场景\",{\"1\":{\"64\":1}}],[\"threadlocal原理\",{\"1\":{\"64\":1}}],[\"threadlocal什么时候会出现oom的情况\",{\"1\":{\"64\":2}}],[\"threshold\",{\"1\":{\"69\":1,\"73\":1}}],[\"tcc等多种模式\",{\"1\":{\"216\":1}}],[\"tcc\",{\"1\":{\"64\":1}}],[\"tcp协议是7层网络协议中的传输层协议\",{\"1\":{\"216\":1}}],[\"tcp协议采用了三次握手策略\",{\"1\":{\"14\":1}}],[\"tcp和udp的区别\",{\"0\":{\"121\":1}}],[\"tcp和udp端口共同决定\",{\"1\":{\"64\":1}}],[\"tcp连接\",{\"1\":{\"27\":1}}],[\"tcp的三次握手和四次挥手\",{\"1\":{\"216\":1}}],[\"tcp的为什么是可靠连接\",{\"0\":{\"123\":1}}],[\"tcp的拥塞\",{\"1\":{\"64\":1}}],[\"tcp的拥塞控制采用了四种算法\",{\"1\":{\"26\":1}}],[\"tcp的接收端只允许发送端发送接收端缓冲区能接纳的数据\",{\"1\":{\"21\":1}}],[\"tcp的可靠体现在tcp在传递数据之前\",{\"1\":{\"20\":1}}],[\"tcp\",{\"0\":{\"14\":1,\"15\":1,\"20\":1,\"21\":1,\"46\":1},\"1\":{\"7\":1,\"9\":2,\"10\":1,\"12\":1,\"17\":2,\"18\":1,\"20\":4,\"21\":9,\"25\":1,\"26\":3,\"39\":1,\"43\":1,\"46\":3,\"47\":5,\"49\":1,\"51\":3,\"53\":2,\"64\":4,\"225\":1}}],[\"true\",{\"1\":{\"96\":5,\"219\":2}}],[\"tra1\",{\"1\":{\"216\":1}}],[\"trab\",{\"1\":{\"64\":6}}],[\"traa中trycatch后的事务提交\",{\"1\":{\"64\":2}}],[\"traa\",{\"1\":{\"64\":20}}],[\"trac\",{\"1\":{\"64\":15}}],[\"transactianal失效\",{\"1\":{\"216\":1}}],[\"transaction\",{\"1\":{\"64\":1,\"216\":4}}],[\"transactional也会失效\",{\"1\":{\"216\":1}}],[\"transactional是不会失效的\",{\"1\":{\"216\":1}}],[\"transactional的方法只有是被代理对象调用时\",{\"1\":{\"216\":1}}],[\"transactional会失效\",{\"1\":{\"216\":1}}],[\"transactional注解\",{\"1\":{\"216\":1}}],[\"transactional注解的bean\",{\"1\":{\"216\":1}}],[\"transactional\",{\"1\":{\"64\":9}}],[\"transitioning\",{\"1\":{\"216\":1}}],[\"transmission\",{\"1\":{\"9\":1}}],[\"transporter\",{\"1\":{\"216\":1}}],[\"transport\",{\"1\":{\"9\":1,\"216\":2}}],[\"transferto\",{\"1\":{\"64\":1}}],[\"transfer\",{\"1\":{\"8\":1}}],[\"trycatch\",{\"1\":{\"64\":4}}],[\"try的最后提交事务\",{\"1\":{\"64\":1}}],[\"try\",{\"1\":{\"64\":6,\"231\":1}}],[\"tree和b+tree区别\",{\"0\":{\"155\":1}}],[\"treebin\",{\"1\":{\"81\":1}}],[\"treeset以及jdk1\",{\"1\":{\"78\":1}}],[\"treeset\",{\"1\":{\"64\":6,\"89\":1}}],[\"treeset通过\",{\"1\":{\"64\":1}}],[\"treemap<person\",{\"1\":{\"87\":2}}],[\"treemap能够把它保存的记录根据键排序\",{\"1\":{\"64\":1}}],[\"treemap区别\",{\"1\":{\"64\":1}}],[\"treemap最常用\",{\"1\":{\"64\":1}}],[\"treemap\",{\"1\":{\"64\":4,\"78\":1,\"90\":1}}],[\"tar\",{\"1\":{\"231\":8}}],[\"target\",{\"1\":{\"73\":1}}],[\"table\",{\"1\":{\"216\":2}}],[\"tablesizefor\",{\"1\":{\"73\":2}}],[\"taobao\",{\"1\":{\"64\":2}}],[\"take\",{\"1\":{\"64\":1,\"216\":1}}],[\"tasks\",{\"1\":{\"216\":8}}],[\"task\",{\"1\":{\"57\":1,\"231\":1}}],[\"tag\",{\"1\":{\"33\":1,\"217\":1,\"218\":1}}],[\"type=single\",{\"1\":{\"219\":1}}],[\"type\",{\"1\":{\"51\":1,\"52\":1,\"216\":2,\"219\":2}}],[\"tool\",{\"1\":{\"219\":10}}],[\"tools两个软件包\",{\"1\":{\"231\":1}}],[\"tools\",{\"1\":{\"217\":1,\"231\":2}}],[\"tolerance\",{\"1\":{\"216\":1}}],[\"to\",{\"1\":{\"216\":1,\"219\":1,\"231\":3}}],[\"top\",{\"1\":{\"217\":1}}],[\"top命令cpu利用率和load\",{\"0\":{\"206\":1}}],[\"topic的分区partition分段segment以及索引等\",{\"1\":{\"64\":1}}],[\"topic这个内部topic记录其offset\",{\"1\":{\"64\":1}}],[\"tomcat是一个web服务器\",{\"1\":{\"216\":1}}],[\"tomcat如何进行优化\",{\"1\":{\"216\":1}}],[\"tomcat启动之后就是一个java进程\",{\"1\":{\"216\":1}}],[\"tomcat中为什么要使用自定义类加载器\",{\"1\":{\"216\":1}}],[\"tomcat中的线程是用来处理客户所发送过来的http请求的\",{\"1\":{\"216\":1}}],[\"tomcat的最大线程数为什么默认是200\",{\"1\":{\"216\":1}}],[\"tomcat的性能与最大并发配置\",{\"1\":{\"64\":1}}],[\"tomcat优化\",{\"1\":{\"64\":1}}],[\"tomcat并发\",{\"1\":{\"64\":1}}],[\"tomcat\",{\"1\":{\"53\":1,\"64\":1,\"219\":1}}],[\"todo重写compareto方法实现按年龄来排序\",{\"1\":{\"87\":1}}],[\"todo\",{\"1\":{\"50\":1,\"54\":1,\"87\":1}}],[\"token\",{\"1\":{\"32\":3}}],[\"tlskey=key\",{\"1\":{\"228\":1}}],[\"tlskey=\",{\"1\":{\"225\":1}}],[\"tlscert=cert\",{\"1\":{\"228\":1}}],[\"tlscert=\",{\"1\":{\"225\":1}}],[\"tlscacert=ca\",{\"1\":{\"228\":1}}],[\"tlscacert=\",{\"1\":{\"225\":1}}],[\"tlsverify\",{\"1\":{\"225\":1,\"228\":1}}],[\"tls\",{\"1\":{\"35\":1,\"47\":1,\"48\":3}}],[\"tls之上的http协议\",{\"1\":{\"35\":1}}],[\"tmp\",{\"1\":{\"4\":2,\"219\":1,\"231\":12}}],[\"和debian\",{\"1\":{\"231\":2}}],[\"和add命令类似\",{\"1\":{\"218\":1}}],[\"和企业版\",{\"1\":{\"217\":1}}],[\"和缓存雪崩类似\",{\"1\":{\"216\":1}}],[\"和列表类似\",{\"1\":{\"216\":1}}],[\"和tomcat有什么区别\",{\"1\":{\"216\":1}}],[\"和服务器端\",{\"1\":{\"216\":1}}],[\"和$\",{\"1\":{\"216\":1}}],[\"和异常的线程\",{\"1\":{\"216\":1}}],[\"和异步任务\",{\"1\":{\"57\":1}}],[\"和lock\",{\"1\":{\"216\":1}}],[\"和lock的区别\",{\"0\":{\"112\":1}}],[\"和hashmap的扩容逻辑类似\",{\"1\":{\"216\":1}}],[\"和rockedmq区别\",{\"0\":{\"164\":1}}],[\"和integer的区别\",{\"0\":{\"103\":1}}],[\"和null\",{\"1\":{\"73\":1}}],[\"和newfixedthreadpool创建的线程池不同\",{\"1\":{\"64\":1}}],[\"和第\",{\"1\":{\"68\":1}}],[\"和gc\",{\"1\":{\"64\":1}}],[\"和gbk的区别\",{\"1\":{\"64\":1}}],[\"和解锁\",{\"1\":{\"64\":1}}],[\"和set相比\",{\"1\":{\"172\":1}}],[\"和session有什么区别\",{\"0\":{\"32\":1}}],[\"和synchronized的区别\",{\"1\":{\"64\":1}}],[\"和排它锁\",{\"1\":{\"64\":1}}],[\"和map\",{\"1\":{\"64\":1}}],[\"和类级别的\",{\"1\":{\"64\":1}}],[\"和full\",{\"1\":{\"64\":2}}],[\"和许多路由选择协议\",{\"1\":{\"10\":1}}],[\"和网络层的\",{\"1\":{\"10\":1}}],[\"和\",{\"0\":{\"35\":1,\"73\":1,\"74\":1,\"81\":1,\"85\":1,\"105\":1,\"133\":1},\"1\":{\"7\":1,\"18\":1,\"19\":1,\"26\":1,\"32\":1,\"43\":1,\"50\":1,\"53\":1,\"54\":1,\"57\":4,\"64\":8,\"68\":1,\"81\":3,\"169\":1,\"216\":4,\"231\":2}}],[\"学习计算机网络时我们一般采用折中的办法\",{\"1\":{\"7\":1}}],[\"项目中怎么用的\",{\"0\":{\"144\":1}}],[\"项目中用到的设计模式有哪些\",{\"0\":{\"142\":1}}],[\"项目怎么解决这些问题\",{\"1\":{\"64\":1}}],[\"项目\",{\"1\":{\"6\":1,\"66\":1,\"75\":1}}],[\"g和daemon\",{\"1\":{\"253\":1}}],[\"g\",{\"1\":{\"253\":1}}],[\"gz\",{\"1\":{\"231\":5}}],[\"gpg\",{\"1\":{\"231\":4}}],[\"gpgkey=http\",{\"1\":{\"231\":4}}],[\"gpgcheck=1\",{\"1\":{\"231\":4}}],[\"gateway在authcenter启动之后再启动\",{\"1\":{\"219\":2}}],[\"gateway\",{\"1\":{\"216\":1,\"219\":10,\"230\":2}}],[\"gwu187\",{\"1\":{\"216\":1}}],[\"geographically\",{\"1\":{\"231\":1}}],[\"genrsa\",{\"1\":{\"223\":3}}],[\"generateorder\",{\"1\":{\"219\":1}}],[\"generated\",{\"1\":{\"87\":1}}],[\"get方式\",{\"1\":{\"219\":1}}],[\"getproperties\",{\"1\":{\"216\":1}}],[\"getpath\",{\"1\":{\"64\":1}}],[\"getage\",{\"1\":{\"87\":4}}],[\"getname\",{\"1\":{\"64\":1,\"87\":2}}],[\"getclass\",{\"1\":{\"64\":1}}],[\"get\",{\"1\":{\"50\":3,\"64\":3,\"81\":1,\"168\":1,\"217\":4}}],[\"group\",{\"1\":{\"219\":2}}],[\"groovy\",{\"1\":{\"64\":2}}],[\"grep\",{\"1\":{\"219\":1}}],[\"grep的使用\",{\"1\":{\"64\":1}}],[\"grizzly\",{\"1\":{\"216\":1}}],[\"gbk和utf8有什么区别\",{\"1\":{\"64\":1}}],[\"gbk编码格式\",{\"1\":{\"64\":1}}],[\"gbk编码\",{\"1\":{\"64\":1}}],[\"gb2312\",{\"1\":{\"64\":1}}],[\"g1会在应用线程上做更多的事情\",{\"1\":{\"64\":1}}],[\"g1收集器\",{\"1\":{\"64\":1}}],[\"gudong\",{\"1\":{\"64\":1}}],[\"guide哥\",{\"1\":{\"6\":1,\"66\":1,\"75\":1}}],[\"gcc\",{\"1\":{\"231\":1}}],[\"gc的流程\",{\"0\":{\"177\":1}}],[\"gc有环怎么处理\",{\"1\":{\"64\":2}}],[\"gc有什么区别\",{\"1\":{\"64\":2}}],[\"gc算法\",{\"1\":{\"64\":1}}],[\"gc\",{\"1\":{\"64\":21}}],[\"gc分哪两种\",{\"1\":{\"64\":2}}],[\"gc机制和原理\",{\"1\":{\"64\":2}}],[\"gitignore\",{\"1\":{\"231\":1}}],[\"gitignore文件忽略一些不需要做版本管理的文件\",{\"1\":{\"231\":1}}],[\"github的\",{\"1\":{\"217\":1}}],[\"github\",{\"1\":{\"6\":1,\"66\":1,\"75\":1}}],[\"gif\",{\"1\":{\"219\":1}}],[\"given\",{\"1\":{\"73\":1}}],[\"gicbiyjpinrhz41u\",{\"1\":{\"33\":1,\"37\":1}}],[\"golang\",{\"1\":{\"231\":1}}],[\"google\",{\"1\":{\"42\":7,\"43\":1}}],[\"gone\",{\"1\":{\"33\":1}}],[\"go\",{\"1\":{\"24\":1,\"231\":1}}],[\"介绍一下如何使用\",{\"1\":{\"231\":1}}],[\"介绍一下epoll\",{\"1\":{\"64\":1}}],[\"介绍一些运作过程\",{\"1\":{\"64\":2}}],[\"介绍gc\",{\"1\":{\"64\":1}}],[\"介绍jvm中7个区域\",{\"1\":{\"64\":1}}],[\"介绍下自己最满意的\",{\"1\":{\"64\":1}}],[\"介绍\",{\"1\":{\"6\":1,\"66\":1,\"75\":1}}],[\"3服务端处理完所有数据后\",{\"1\":{\"216\":1}}],[\"3客户端接收到syn\",{\"1\":{\"216\":1}}],[\"3要避免不重复消费\",{\"1\":{\"216\":1}}],[\"3流量削峰\",{\"1\":{\"216\":1}}],[\"3检查所查字段是否都是必须的\",{\"1\":{\"216\":1}}],[\"3间隙锁\",{\"1\":{\"216\":1}}],[\"3非叶子节点上的元素在叶子节点上都冗余了\",{\"1\":{\"216\":1}}],[\"3针对update语句生成一个redolog对象\",{\"1\":{\"216\":1}}],[\"3延时双删\",{\"1\":{\"216\":1}}],[\"3缓存穿透\",{\"1\":{\"216\":1}}],[\"3主节点接收到sync命名后\",{\"1\":{\"216\":1}}],[\"3同时还要考虑到锁过期\",{\"1\":{\"216\":1}}],[\"3列表\",{\"1\":{\"216\":1}}],[\"3内存池设计\",{\"1\":{\"216\":1}}],[\"3高扩展\",{\"1\":{\"216\":1}}],[\"3aio\",{\"1\":{\"216\":1}}],[\"3appclassloader\",{\"1\":{\"216\":1}}],[\"3微服务是一种更彻底的面向服务的架构\",{\"1\":{\"216\":1}}],[\"3protocol远程调用层\",{\"1\":{\"216\":1}}],[\"3并绑定一些监听器用来监听动态配置中心的变更\",{\"1\":{\"216\":1}}],[\"3然后将服务信息注册到注册中心\",{\"1\":{\"216\":1}}],[\"3然后筛选出非懒加载的单例beandefinition进行创建bean\",{\"1\":{\"216\":1}}],[\"3最小活跃调用数\",{\"1\":{\"216\":1}}],[\"3集群在工作过程中\",{\"1\":{\"216\":1}}],[\"3一个节点收到其他节点发过来的选票\",{\"1\":{\"216\":1}}],[\"3请求广播阶段\",{\"1\":{\"216\":1}}],[\"3利用redis\",{\"1\":{\"216\":1}}],[\"3execute\",{\"1\":{\"216\":2}}],[\"3e\",{\"1\":{\"216\":1}}],[\"3mybatis\",{\"1\":{\"216\":1}}],[\"3很好的与各种数据库兼容\",{\"1\":{\"216\":1}}],[\"3操作系统环境变量\",{\"1\":{\"216\":1}}],[\"3处理器映射器找到具体的处理器\",{\"1\":{\"216\":1}}],[\"3当调用代理对象的方法时\",{\"1\":{\"216\":1}}],[\"3填充属性\",{\"1\":{\"216\":1}}],[\"3consul\",{\"1\":{\"216\":1}}],[\"3c\",{\"1\":{\"216\":1}}],[\"3c类\",{\"1\":{\"216\":1}}],[\"3为什么要反转\",{\"1\":{\"216\":1}}],[\"3浏览器通过操作系统将请求通过四层网络协议发送出去\",{\"1\":{\"216\":1}}],[\"3根据dump文件找到异常的实例对象\",{\"1\":{\"216\":1}}],[\"3可以通过jstat命令来查看垃圾回收的情况\",{\"1\":{\"216\":1}}],[\"3seata\",{\"1\":{\"216\":1}}],[\"3spring容器创建完之后\",{\"1\":{\"216\":1}}],[\"3sychronized的底层是jvm层面的锁\",{\"1\":{\"216\":1}}],[\"3stop\",{\"1\":{\"216\":2}}],[\"3如果此时线程池中的线程数量大于等于corepoolsize\",{\"1\":{\"216\":1}}],[\"3如果自旋次数过多仍然没有获取到锁\",{\"1\":{\"216\":1}}],[\"3如果在线程池中使用threadlocal会造成内存泄漏\",{\"1\":{\"216\":1}}],[\"3如果某个线程put时\",{\"1\":{\"216\":1}}],[\"3如果是链表\",{\"1\":{\"216\":1}}],[\"3每个segment内部会进行扩容\",{\"1\":{\"216\":1}}],[\"3取每个元素的key\",{\"1\":{\"216\":1}}],[\"3写操作结束之后会把原数组指向新数组\",{\"1\":{\"216\":1}}],[\"3另外arraylist和linkedlist都实现了list接口\",{\"1\":{\"216\":1}}],[\"3确定好了要发送的数据后\",{\"1\":{\"216\":1}}],[\"39\",{\"0\":{\"132\":1}}],[\"37\",{\"0\":{\"130\":1}}],[\"3650\",{\"1\":{\"223\":3}}],[\"36\",{\"0\":{\"129\":1}}],[\"35\",{\"0\":{\"128\":1}}],[\"3306\",{\"1\":{\"219\":3}}],[\"3322c\",{\"1\":{\"216\":2}}],[\"33\",{\"0\":{\"126\":1}}],[\"31\",{\"0\":{\"124\":1}}],[\"38\",{\"0\":{\"131\":1}}],[\"384\",{\"1\":{\"64\":1}}],[\"38259539\",{\"1\":{\"64\":1}}],[\"32\",{\"0\":{\"125\":1},\"1\":{\"64\":3}}],[\"320\",{\"1\":{\"64\":1}}],[\"349\",{\"1\":{\"64\":2}}],[\"34\",{\"0\":{\"127\":1},\"1\":{\"58\":2}}],[\"3005\",{\"1\":{\"219\":1}}],[\"3000\",{\"1\":{\"219\":5}}],[\"30\",{\"0\":{\"123\":1},\"1\":{\"87\":2}}],[\"304\",{\"1\":{\"54\":1}}],[\"302\",{\"1\":{\"54\":2}}],[\"301\",{\"1\":{\"54\":2}}],[\"3xx\",{\"1\":{\"54\":1}}],[\"3号\",{\"1\":{\"24\":1}}],[\"3\",{\"0\":{\"6\":1,\"7\":1,\"14\":1,\"20\":1,\"21\":2,\"22\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"61\":1,\"71\":1,\"96\":1,\"154\":1,\"163\":1,\"174\":1,\"178\":1,\"194\":1,\"211\":1},\"1\":{\"23\":1,\"54\":1,\"64\":30,\"68\":1,\"86\":10,\"216\":8,\"217\":7,\"218\":2,\"219\":11,\"231\":11}}],[\"ng\",{\"1\":{\"219\":2}}],[\"nginx容器\",{\"1\":{\"217\":1}}],[\"nginx\",{\"1\":{\"217\":5,\"218\":5,\"231\":2,\"253\":1,\"254\":1}}],[\"ngnix中\",{\"1\":{\"64\":1}}],[\"nacos\",{\"1\":{\"219\":36}}],[\"nacos来作为注册中心将更合适\",{\"1\":{\"216\":1}}],[\"named\",{\"1\":{\"219\":1}}],[\"name选项自行指定\",{\"1\":{\"217\":1}}],[\"namesrv\",{\"1\":{\"219\":4}}],[\"names\",{\"1\":{\"217\":1}}],[\"name为idx\",{\"1\":{\"216\":1}}],[\"name=centos\",{\"1\":{\"231\":4}}],[\"name=tulingmall\",{\"1\":{\"219\":10}}],[\"name=elasticsearch\",{\"1\":{\"219\":1}}],[\"name=\",{\"1\":{\"64\":3}}],[\"name被译为域名\",{\"1\":{\"8\":1}}],[\"name\",{\"1\":{\"8\":1,\"64\":1,\"87\":8,\"169\":1,\"217\":2,\"219\":29}}],[\"n代表数组长度\",{\"1\":{\"79\":1}}],[\"number\",{\"1\":{\"77\":1,\"94\":1}}],[\"nullpointerexception\",{\"1\":{\"73\":1}}],[\"null\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1,\"64\":6,\"73\":3,\"77\":1}}],[\"n+r\",{\"1\":{\"64\":4}}],[\"nlog2n\",{\"1\":{\"64\":10}}],[\"n2\",{\"1\":{\"64\":9}}],[\"nfs\",{\"1\":{\"64\":1}}],[\"nio的网络通信框架\",{\"1\":{\"216\":1}}],[\"nio\",{\"1\":{\"216\":1}}],[\"nio系列教程\",{\"1\":{\"64\":3}}],[\"nio技术概览\",{\"1\":{\"64\":2}}],[\"nio适用场景\",{\"1\":{\"64\":1}}],[\"nio是什么\",{\"1\":{\"64\":2}}],[\"no\",{\"1\":{\"218\":1}}],[\"nodeps\",{\"1\":{\"219\":1}}],[\"node\",{\"1\":{\"81\":2,\"216\":1,\"219\":1}}],[\"nodes\",{\"1\":{\"64\":1}}],[\"noeviction\",{\"1\":{\"64\":1}}],[\"notify和notifyall\",{\"0\":{\"99\":1}}],[\"not\",{\"1\":{\"64\":1,\"231\":1,\"255\":1}}],[\"noteshare\",{\"1\":{\"64\":1}}],[\"note\",{\"1\":{\"64\":1}}],[\"none\",{\"1\":{\"33\":1,\"219\":1}}],[\"n\",{\"1\":{\"24\":3,\"64\":6,\"68\":3,\"69\":1,\"73\":14,\"77\":2,\"79\":2,\"84\":2,\"219\":1}}],[\"next\",{\"1\":{\"70\":1}}],[\"nested\",{\"1\":{\"64\":1}}],[\"never\",{\"1\":{\"64\":1}}],[\"net=none\",{\"1\":{\"217\":1}}],[\"net=container\",{\"1\":{\"217\":1}}],[\"net=host\",{\"1\":{\"217\":1}}],[\"net=bridge\",{\"1\":{\"217\":1}}],[\"net选项\",{\"1\":{\"217\":1}}],[\"net不是很熟悉\",{\"1\":{\"64\":1}}],[\"netty同时支持reactor单线程模型\",{\"1\":{\"216\":1}}],[\"netty的高性能体现在哪些方面\",{\"1\":{\"216\":1}}],[\"netty的线程模型是怎么样的\",{\"1\":{\"216\":1}}],[\"netty的特点\",{\"1\":{\"216\":1}}],[\"netty的优势是啥\",{\"0\":{\"144\":1}}],[\"netty是一个基于nio的异步网络通信框架\",{\"1\":{\"216\":1}}],[\"netty是什么\",{\"1\":{\"216\":1}}],[\"netty等\",{\"1\":{\"216\":1}}],[\"netty有没有用过\",{\"0\":{\"144\":1}}],[\"netty\",{\"1\":{\"53\":1,\"64\":1,\"216\":2}}],[\"network\",{\"1\":{\"45\":1}}],[\"net\",{\"1\":{\"13\":1,\"19\":1,\"37\":3,\"64\":13,\"217\":1,\"218\":1,\"219\":5,\"231\":2}}],[\"newratio=4的配置失效了\",{\"1\":{\"64\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"64\":1}}],[\"newcachedthreadpool在没有任务执行时\",{\"1\":{\"64\":1}}],[\"newcachedthreadpool\",{\"1\":{\"64\":1}}],[\"newfixedthreadpool此种线程池如果线程数达到最大值后会怎么办\",{\"1\":{\"64\":1}}],[\"newfixedthreadpool\",{\"1\":{\"64\":1}}],[\"new\",{\"1\":{\"4\":1,\"64\":13,\"73\":2,\"86\":2,\"87\":5,\"94\":1,\"96\":2,\"216\":6,\"223\":3}}],[\"pyropus\",{\"1\":{\"231\":2}}],[\"python\",{\"1\":{\"231\":1}}],[\"plus\",{\"1\":{\"231\":1}}],[\"plugins\",{\"1\":{\"219\":2}}],[\"plugin`\",{\"1\":{\"219\":1}}],[\"plugin\",{\"1\":{\"219\":1}}],[\"pem\",{\"1\":{\"223\":15,\"225\":3,\"228\":3}}],[\"person\",{\"1\":{\"87\":8}}],[\"person对象没有实现comparable接口\",{\"1\":{\"87\":1}}],[\"permgen变更为metaspace详解\",{\"1\":{\"64\":1}}],[\"png\",{\"1\":{\"219\":1}}],[\"picking\",{\"1\":{\"231\":1}}],[\"pick\",{\"1\":{\"231\":1}}],[\"pipeline\",{\"1\":{\"219\":1}}],[\"pid\",{\"1\":{\"218\":1}}],[\"pids\",{\"1\":{\"218\":1}}],[\"ping过程\",{\"1\":{\"64\":1}}],[\"ping的原理\",{\"1\":{\"64\":1}}],[\"ping\",{\"1\":{\"64\":1,\"217\":2,\"219\":2}}],[\"ptrace\",{\"1\":{\"218\":2,\"219\":10}}],[\"p选项\",{\"1\":{\"217\":2}}],[\"pk的规则也是一样的\",{\"1\":{\"216\":1}}],[\"pdata\",{\"1\":{\"87\":6}}],[\"pdf1mb\",{\"1\":{\"64\":1}}],[\"packages\",{\"1\":{\"231\":3}}],[\"passin\",{\"1\":{\"223\":3}}],[\"pass\",{\"1\":{\"223\":4}}],[\"passout\",{\"1\":{\"223\":1}}],[\"password=\",{\"1\":{\"223\":1}}],[\"password=test\",{\"1\":{\"219\":1}}],[\"password\",{\"1\":{\"219\":4}}],[\"path\",{\"1\":{\"219\":4,\"231\":2}}],[\"pages\",{\"0\":{\"256\":1}}],[\"pagehelper插件\",{\"0\":{\"106\":1}}],[\"pagecache\",{\"1\":{\"64\":1}}],[\"param\",{\"1\":{\"64\":1,\"231\":2}}],[\"parameter\",{\"1\":{\"64\":2}}],[\"parallelgcthreads=20\",{\"1\":{\"64\":4}}],[\"parallelold收集器\",{\"1\":{\"64\":1}}],[\"parallel\",{\"1\":{\"64\":3}}],[\"parallnew\",{\"1\":{\"64\":1}}],[\"parnew收集器\",{\"1\":{\"64\":1}}],[\"partial\",{\"1\":{\"33\":1}}],[\"partitions\",{\"1\":{\"216\":1}}],[\"partition\",{\"1\":{\"4\":2,\"216\":1}}],[\"php有pear的cache模块\",{\"1\":{\"64\":1}}],[\"phaser\",{\"1\":{\"64\":1}}],[\"phase\",{\"1\":{\"64\":2}}],[\"physical\",{\"1\":{\"12\":1}}],[\"primary\",{\"1\":{\"216\":1}}],[\"println\",{\"1\":{\"64\":3,\"86\":8,\"87\":1,\"96\":4}}],[\"private\",{\"1\":{\"64\":1,\"87\":2,\"94\":2}}],[\"priorityblockingqueue\",{\"1\":{\"64\":1}}],[\"priorityqueue\",{\"1\":{\"64\":1}}],[\"preparedstatement\",{\"1\":{\"216\":1}}],[\"pretenuresizethreshold参数只对serial和parnew两款收集器有效\",{\"1\":{\"64\":1}}],[\"pretenuresizethreshold\",{\"1\":{\"64\":1}}],[\"pre\",{\"1\":{\"64\":1}}],[\"product=1\",{\"1\":{\"219\":1}}],[\"product=2\",{\"1\":{\"219\":1}}],[\"product服务为例\",{\"1\":{\"219\":2}}],[\"product目录\",{\"1\":{\"219\":1}}],[\"product\",{\"1\":{\"219\":13}}],[\"project\",{\"1\":{\"219\":3}}],[\"profiles\",{\"1\":{\"219\":1,\"248\":1}}],[\"profile\",{\"1\":{\"216\":6}}],[\"proyfactoy可以提交此监听器\",{\"1\":{\"216\":1}}],[\"prototypeaspectlnstancefactory\",{\"1\":{\"216\":1}}],[\"prototypetargetsource\",{\"1\":{\"216\":1}}],[\"protocol\",{\"1\":{\"8\":1,\"9\":2,\"10\":1,\"64\":1,\"216\":4}}],[\"progress\",{\"1\":{\"216\":1}}],[\"programming\",{\"1\":{\"64\":1}}],[\"process\",{\"1\":{\"216\":3}}],[\"processon\",{\"1\":{\"216\":1}}],[\"provider\",{\"1\":{\"64\":1,\"216\":2}}],[\"provider服务提供者要控制执行并发请求上限\",{\"1\":{\"64\":2}}],[\"proxyfactory\",{\"1\":{\"216\":2}}],[\"proxy无法进行代理\",{\"1\":{\"64\":1}}],[\"proxy要更胜一筹的\",{\"1\":{\"64\":1}}],[\"proxy实际上是比cglib\",{\"1\":{\"64\":1}}],[\"proxy\",{\"1\":{\"64\":4,\"216\":2}}],[\"propertysource\",{\"1\":{\"216\":1}}],[\"propertyaccessor\",{\"1\":{\"216\":1}}],[\"properties或application\",{\"1\":{\"216\":4}}],[\"properties\",{\"1\":{\"64\":1}}],[\"properties配置浓缩在一个appliaction\",{\"1\":{\"64\":1}}],[\"propagation=propagation\",{\"1\":{\"64\":3}}],[\"propagation\",{\"1\":{\"64\":7}}],[\"propagion\",{\"1\":{\"64\":1}}],[\"promotion\",{\"1\":{\"64\":1}}],[\"port\",{\"1\":{\"219\":2}}],[\"ports\",{\"1\":{\"217\":1,\"219\":25}}],[\"poll\",{\"1\":{\"216\":1}}],[\"poll的区别\",{\"1\":{\"64\":1}}],[\"possible\",{\"1\":{\"216\":1}}],[\"position\",{\"1\":{\"77\":1}}],[\"post方式\",{\"1\":{\"219\":3}}],[\"postgresql\",{\"1\":{\"219\":1}}],[\"postprocessbeanfactory0\",{\"1\":{\"216\":1}}],[\"postconstruct注解\",{\"1\":{\"216\":1}}],[\"post的区别\",{\"1\":{\"64\":1}}],[\"post\",{\"1\":{\"50\":2,\"52\":1,\"64\":3,\"70\":1,\"92\":1}}],[\"power\",{\"1\":{\"73\":1}}],[\"pong机制\",{\"1\":{\"64\":1}}],[\"pool中所修改的数据页持久化到磁盘中\",{\"1\":{\"216\":1}}],[\"pool中的数据\",{\"1\":{\"216\":1}}],[\"pool中\",{\"1\":{\"216\":1}}],[\"pool\",{\"1\":{\"64\":1,\"216\":2,\"219\":1}}],[\"ps命令即可列出运行中的容器\",{\"1\":{\"217\":1}}],[\"ps\",{\"1\":{\"51\":1,\"217\":2,\"219\":1}}],[\"push\",{\"1\":{\"218\":1}}],[\"pull\",{\"1\":{\"217\":3}}],[\"pull命令即可从\",{\"1\":{\"217\":1}}],[\"pul\",{\"1\":{\"216\":1}}],[\"put\",{\"1\":{\"50\":1,\"52\":1,\"64\":1,\"73\":1,\"74\":1,\"81\":2,\"87\":4}}],[\"public\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":4,\"64\":1,\"69\":2,\"73\":2,\"86\":1,\"87\":8,\"96\":2}}],[\"p\",{\"1\":{\"4\":3,\"64\":6,\"78\":1,\"81\":1,\"216\":1,\"217\":2,\"218\":4,\"219\":3,\"222\":1}}],[\"md表示除了\",{\"1\":{\"231\":1}}],[\"md\",{\"1\":{\"231\":6}}],[\"mkdir\",{\"1\":{\"222\":1}}],[\"ms\",{\"1\":{\"218\":1}}],[\"m9r2r2uj\",{\"1\":{\"217\":1}}],[\"mget\",{\"1\":{\"168\":1}}],[\"multiples\",{\"1\":{\"77\":1}}],[\"mutex\",{\"1\":{\"64\":1}}],[\"m\",{\"1\":{\"64\":1,\"218\":2}}],[\"mvcc\",{\"1\":{\"64\":1}}],[\"mvc工作原理\",{\"1\":{\"64\":1}}],[\"mvc等其他特性改进\",{\"1\":{\"64\":2}}],[\"myappentrypoint\",{\"1\":{\"248\":1}}],[\"myappworkdir\",{\"1\":{\"248\":1}}],[\"my\",{\"1\":{\"219\":1}}],[\"mydockercompose\",{\"1\":{\"219\":1}}],[\"mydata\",{\"1\":{\"217\":1,\"219\":18}}],[\"myid大者获胜\",{\"1\":{\"216\":1}}],[\"mybatis中\",{\"1\":{\"216\":1}}],[\"mybatis\",{\"1\":{\"216\":1,\"219\":1}}],[\"mybatis存在哪些优点和缺点\",{\"1\":{\"216\":1}}],[\"mybatis的事务\",{\"0\":{\"138\":1}}],[\"mybatis缓存机制的设计与实现\",{\"1\":{\"64\":1}}],[\"mybatis缓存\",{\"1\":{\"64\":1}}],[\"mybatis数据源与连接池\",{\"1\":{\"64\":3}}],[\"mysqld\",{\"1\":{\"219\":1}}],[\"mysql慢查询该如何优化\",{\"1\":{\"216\":1}}],[\"mysql就会为它分配一个唯一的id值\",{\"1\":{\"216\":1}}],[\"mysql中用得最多的就是b+树了\",{\"1\":{\"216\":1}}],[\"mysql中的mvcc\",{\"1\":{\"64\":1}}],[\"mysql7中你将得到结果\",{\"1\":{\"216\":1}}],[\"mysql8中你将得到结果\",{\"1\":{\"216\":1}}],[\"mysql8中分别创建一个表\",{\"1\":{\"216\":1}}],[\"mysql8两个版本来举例子说明一下\",{\"1\":{\"216\":1}}],[\"mysql优化\",{\"1\":{\"64\":1}}],[\"mysql优化系列\",{\"1\":{\"64\":1}}],[\"mysql死锁排查\",{\"1\":{\"64\":1}}],[\"mysql索引使用的是b+树\",{\"1\":{\"216\":1}}],[\"mysql索引原理之聚簇索引\",{\"1\":{\"64\":1}}],[\"mysql索引失效的几种情况\",{\"1\":{\"64\":1}}],[\"mysql索引背后的数据结构及算法原理\",{\"1\":{\"64\":1}}],[\"mysql索引\",{\"1\":{\"64\":1}}],[\"mysql主从同步的实现原理\",{\"1\":{\"64\":1}}],[\"mysql主键索引\",{\"1\":{\"64\":1}}],[\"mysql的锁\",{\"1\":{\"64\":1}}],[\"mysql的主从实时备份同步的配置\",{\"1\":{\"64\":1}}],[\"mysql的存储引擎的不同\",{\"1\":{\"64\":1}}],[\"mysql分表自增id解决方案\",{\"1\":{\"64\":1}}],[\"mysql分库分表方案\",{\"1\":{\"64\":1}}],[\"mysql大数据量使用limit分页\",{\"1\":{\"64\":1}}],[\"mysql怎么分表\",{\"1\":{\"64\":1}}],[\"mysql参数\",{\"1\":{\"64\":1}}],[\"mysql存储引擎之myisam和innodb总结性梳理\",{\"1\":{\"64\":1}}],[\"mysql默认隔离级别\",{\"1\":{\"64\":1}}],[\"mysql默认的隔离级别\",{\"1\":{\"64\":2}}],[\"mysql会根据执行的sql语句选择日志保存方式\",{\"1\":{\"64\":1}}],[\"mysql复制主要有三种方式\",{\"1\":{\"64\":1}}],[\"mysql\",{\"1\":{\"64\":6,\"216\":1,\"219\":23}}],[\"mysql锁有哪些\",{\"1\":{\"216\":1}}],[\"mysql锁\",{\"1\":{\"64\":2}}],[\"mysql记录binlog的方式主要包括三种模式\",{\"1\":{\"64\":2}}],[\"memtester\",{\"1\":{\"231\":12}}],[\"member\",{\"1\":{\"219\":10}}],[\"mem\",{\"1\":{\"218\":2}}],[\"memory\",{\"1\":{\"64\":2}}],[\"metaspacesize=256m\",{\"1\":{\"218\":1}}],[\"method\",{\"1\":{\"50\":1,\"64\":4,\"87\":1,\"216\":1}}],[\"message\",{\"1\":{\"216\":1}}],[\"messagesourceaccessor\",{\"1\":{\"216\":1}}],[\"messagesource\",{\"1\":{\"216\":1}}],[\"me\",{\"1\":{\"216\":1}}],[\"meituan\",{\"0\":{\"197\":1}}],[\"mergesort\",{\"1\":{\"64\":1}}],[\"mqbroker\",{\"1\":{\"219\":1}}],[\"mqnamesrv\",{\"1\":{\"219\":1}}],[\"mqproducer\",{\"1\":{\"216\":2}}],[\"mqserver\",{\"1\":{\"216\":2}}],[\"mqsubscriber\",{\"1\":{\"216\":2}}],[\"mq\",{\"1\":{\"64\":4}}],[\"mbr\",{\"1\":{\"64\":2}}],[\"micromall\",{\"1\":{\"219\":1}}],[\"microservice\",{\"1\":{\"218\":8,\"219\":2}}],[\"mirrorlist\",{\"1\":{\"231\":3}}],[\"mirrorlist=http\",{\"1\":{\"231\":3}}],[\"mirrorlist=\",{\"1\":{\"231\":1}}],[\"mirror\",{\"1\":{\"217\":1,\"231\":2}}],[\"mirrors\",{\"1\":{\"217\":2,\"231\":10}}],[\"milliseconds\",{\"1\":{\"64\":1}}],[\"mixed模式\",{\"1\":{\"64\":1}}],[\"mixed\",{\"1\":{\"64\":2}}],[\"min\",{\"1\":{\"219\":2}}],[\"mina等网络传输框架\",{\"1\":{\"216\":1}}],[\"mina\",{\"1\":{\"64\":1,\"216\":2}}],[\"minor\",{\"1\":{\"64\":4}}],[\"minindex\",{\"1\":{\"3\":5}}],[\"may\",{\"1\":{\"231\":1}}],[\"make\",{\"1\":{\"231\":7}}],[\"makecache\",{\"1\":{\"217\":1}}],[\"master\",{\"1\":{\"219\":1}}],[\"mall目录下\",{\"1\":{\"219\":1}}],[\"mall目录下新建微服务编排文件docker\",{\"1\":{\"219\":1}}],[\"mall目录下新建一个编排文件docker\",{\"1\":{\"219\":1}}],[\"mall目录下分别创建tulingmall\",{\"1\":{\"219\":1}}],[\"mall目录执行如下命令\",{\"1\":{\"219\":2}}],[\"mall\",{\"1\":{\"219\":11}}],[\"malloc等调用可能会失败\",{\"1\":{\"64\":1}}],[\"maven仓库的话\",{\"1\":{\"217\":1}}],[\"maven的仓库有点类似\",{\"1\":{\"217\":1}}],[\"mainreactor\",{\"1\":{\"216\":1}}],[\"main\",{\"1\":{\"87\":1,\"96\":1}}],[\"maxmetaspacesize=512m\",{\"1\":{\"219\":5}}],[\"maxmetaspacesize=256m\",{\"1\":{\"218\":1,\"219\":5}}],[\"maximum\",{\"1\":{\"73\":4}}],[\"maximumpoolsize\",{\"1\":{\"64\":4}}],[\"maxgcpausemillis=100\",{\"1\":{\"64\":3}}],[\"max\",{\"1\":{\"64\":3,\"219\":5}}],[\"maxpoolsize\",{\"1\":{\"64\":2}}],[\"manually\",{\"1\":{\"231\":1}}],[\"management\",{\"1\":{\"219\":2}}],[\"manager功能\",{\"1\":{\"217\":1}}],[\"manager\",{\"1\":{\"64\":2,\"217\":1}}],[\"mandatory\",{\"1\":{\"64\":1}}],[\"mark\",{\"1\":{\"64\":2}}],[\"major\",{\"1\":{\"64\":2}}],[\"mapper\",{\"1\":{\"219\":2}}],[\"mapping\",{\"1\":{\"219\":1}}],[\"map的value为需要缓存的值\",{\"1\":{\"216\":1}}],[\"map的key为threadlocal对象\",{\"1\":{\"216\":1}}],[\"map的区别\",{\"1\":{\"64\":1}}],[\"map会维护与key有关联的值\",{\"1\":{\"67\":1}}],[\"map三者的区别\",{\"0\":{\"67\":1}}],[\"map实现类\",{\"1\":{\"64\":1}}],[\"map是一个接口\",{\"1\":{\"64\":1}}],[\"map是存储键和值这样的双列数据的集合\",{\"1\":{\"64\":1}}],[\"map不是collection的子接口或者实现类\",{\"1\":{\"64\":1}}],[\"map中存储的数据是没有顺序的\",{\"1\":{\"64\":1}}],[\"map和set都是用红黑树实现的\",{\"1\":{\"64\":1}}],[\"map\",{\"0\":{\"90\":1},\"1\":{\"54\":1,\"64\":9,\"67\":1}}],[\"match等更多可供选择的缓存头来控制缓存策略\",{\"1\":{\"33\":1}}],[\"match\",{\"1\":{\"33\":1}}],[\"math\",{\"1\":{\"4\":1}}],[\"mongo\",{\"1\":{\"219\":6}}],[\"monitorservice\",{\"1\":{\"216\":1}}],[\"monitor\",{\"1\":{\"216\":3}}],[\"monitorfactory\",{\"1\":{\"216\":1}}],[\"most\",{\"1\":{\"64\":1}}],[\"mode=standalone\",{\"1\":{\"219\":1}}],[\"modelandview\",{\"1\":{\"216\":3}}],[\"mode\",{\"1\":{\"64\":2}}],[\"modified\",{\"1\":{\"33\":1}}],[\"more\",{\"1\":{\"4\":5}}],[\"mp\",{\"1\":{\"33\":1,\"37\":1}}],[\"rw\",{\"1\":{\"219\":1}}],[\"rf\",{\"1\":{\"217\":3}}],[\"rmqbroker\",{\"1\":{\"219\":1}}],[\"rm命令即可删除指定容器\",{\"1\":{\"217\":1}}],[\"rm\",{\"1\":{\"217\":5,\"223\":1}}],[\"rmi命令即可删除指定镜像\",{\"1\":{\"217\":1}}],[\"rmi\",{\"1\":{\"216\":1,\"217\":2}}],[\"rpm\",{\"1\":{\"219\":1,\"231\":4}}],[\"rpc调用\",{\"1\":{\"216\":2}}],[\"rpc调用和http调用是有区别的\",{\"1\":{\"216\":1}}],[\"rpc表示的是一种调用远程方法的方式\",{\"1\":{\"216\":1}}],[\"rpc表示远程过程调用\",{\"1\":{\"216\":1}}],[\"rpc\",{\"1\":{\"216\":6}}],[\"rpop\",{\"1\":{\"170\":1}}],[\"rpush\",{\"1\":{\"170\":1}}],[\"rdb和aof\",{\"0\":{\"173\":1},\"1\":{\"64\":1}}],[\"run时覆盖默认程序\",{\"1\":{\"231\":1}}],[\"run后面的参数直接覆盖\",{\"1\":{\"231\":1}}],[\"run指令后面的内容尽量按照字母顺序排序\",{\"1\":{\"231\":1}}],[\"run指令在构建时将会生成一个新的镜像层并且执行run指令后面的内容\",{\"1\":{\"231\":1}}],[\"run指令用于执行命令\",{\"1\":{\"218\":1}}],[\"run都是\",{\"1\":{\"218\":1}}],[\"run命令就不能附加命令了\",{\"1\":{\"218\":1}}],[\"run命令在\",{\"1\":{\"218\":1}}],[\"run命令运行容器的时候\",{\"1\":{\"217\":1}}],[\"run命令\",{\"1\":{\"217\":1}}],[\"run命令的\",{\"1\":{\"217\":1}}],[\"run命令创建容器时\",{\"1\":{\"217\":1}}],[\"run命令即可新建并启动一个容器\",{\"1\":{\"217\":1}}],[\"run添加了两个参数\",{\"1\":{\"217\":1}}],[\"run\",{\"1\":{\"216\":2,\"217\":2,\"218\":8,\"219\":1,\"225\":1,\"231\":13}}],[\"run和start区别\",{\"0\":{\"135\":1}}],[\"runable和callable\",{\"0\":{\"111\":1}}],[\"running\",{\"1\":{\"64\":1}}],[\"runnable\",{\"1\":{\"64\":1}}],[\"runtimeexception\",{\"1\":{\"64\":6}}],[\"rack\",{\"1\":{\"219\":2}}],[\"ramdomaccess\",{\"1\":{\"69\":1}}],[\"rarp\",{\"1\":{\"64\":1}}],[\"rabbitmq的死信队列\",{\"0\":{\"163\":1}}],[\"rabbitmq\",{\"0\":{\"160\":1},\"1\":{\"64\":1,\"219\":11}}],[\"randomaccess接口的list\",{\"1\":{\"69\":1}}],[\"randomaccess\",{\"1\":{\"69\":9}}],[\"random\",{\"1\":{\"4\":1,\"64\":2}}],[\"rbr\",{\"1\":{\"64\":2}}],[\"rockermq\",{\"1\":{\"219\":2}}],[\"rocketmqinc\",{\"1\":{\"219\":2}}],[\"rocketmq的事务消息是如何实现的\",{\"1\":{\"216\":1}}],[\"rocketmq\",{\"0\":{\"160\":1},\"1\":{\"64\":1,\"219\":19}}],[\"rocket重试机制\",{\"1\":{\"64\":1}}],[\"ro代表readonly只读\",{\"1\":{\"219\":2}}],[\"ro\",{\"1\":{\"219\":13}}],[\"root=info\",{\"1\":{\"219\":1}}],[\"root\",{\"1\":{\"216\":3,\"217\":1,\"219\":4}}],[\"roots强引用可到达\",{\"1\":{\"64\":1}}],[\"roots\",{\"1\":{\"64\":1}}],[\"roots有哪些\",{\"1\":{\"64\":1}}],[\"roots的点开始遍历遍历对象\",{\"1\":{\"64\":1}}],[\"root不正常引用\",{\"1\":{\"64\":1}}],[\"rollbackdeletemsg\",{\"1\":{\"216\":2}}],[\"rollback\",{\"1\":{\"64\":2}}],[\"rows\",{\"1\":{\"216\":1}}],[\"row模式\",{\"1\":{\"64\":1}}],[\"row\",{\"1\":{\"64\":2}}],[\"roundrobin\",{\"1\":{\"64\":1}}],[\"router\",{\"1\":{\"10\":1,\"216\":1}}],[\"req\",{\"1\":{\"223\":5}}],[\"requires\",{\"1\":{\"64\":4}}],[\"required\",{\"1\":{\"64\":1}}],[\"request\",{\"1\":{\"22\":1,\"50\":1,\"53\":1,\"216\":2}}],[\"recreate\",{\"1\":{\"219\":2}}],[\"recovery\",{\"1\":{\"26\":1}}],[\"released\",{\"1\":{\"231\":1}}],[\"release=$releasever\",{\"1\":{\"231\":3}}],[\"relative\",{\"1\":{\"219\":2}}],[\"reload\",{\"1\":{\"217\":1,\"226\":1}}],[\"relow\",{\"1\":{\"57\":1}}],[\"redo\",{\"1\":{\"216\":1}}],[\"redis这些中间件服务因为都在docker\",{\"1\":{\"219\":1}}],[\"redis和mysql如何保证数据一致\",{\"1\":{\"216\":1}}],[\"redis和memcache的区别\",{\"1\":{\"64\":1}}],[\"redis主节点每执行一个写命令就会向从节点异步发送相同的写命令\",{\"1\":{\"216\":1}}],[\"redis主从复制的核心原理\",{\"1\":{\"216\":1}}],[\"redis等作为注册中心\",{\"1\":{\"216\":1}}],[\"redis可以非常方便的实现如共同关注\",{\"1\":{\"171\":1}}],[\"redis有哪些数据结构\",{\"1\":{\"64\":1,\"216\":1}}],[\"redis的列表通过命令的组合\",{\"1\":{\"216\":1}}],[\"redis的数据结构有\",{\"1\":{\"216\":1}}],[\"redis的数据添加过程是怎样的\",{\"1\":{\"64\":1}}],[\"redis的订阅机制\",{\"0\":{\"174\":1}}],[\"redis的持久化\",{\"0\":{\"173\":1}}],[\"redis的5种数据类型\",{\"0\":{\"167\":1}}],[\"redis的单线程模型\",{\"1\":{\"64\":1}}],[\"redis的淘汰策略有哪些\",{\"1\":{\"64\":1}}],[\"redis集群实现\",{\"1\":{\"64\":1}}],[\"redis集群如何同步\",{\"1\":{\"64\":1}}],[\"redis五种数据类型介绍\",{\"1\":{\"64\":1}}],[\"redis数据类型\",{\"1\":{\"64\":1}}],[\"redis是如何持久化的\",{\"1\":{\"64\":1}}],[\"redis是单进程单线程的\",{\"1\":{\"64\":1}}],[\"redis分布式锁底层是如何实现的\",{\"1\":{\"216\":1}}],[\"redis分布式锁的实现就利用了这种数据结构\",{\"1\":{\"216\":1}}],[\"redis分布式锁的特点是高可用\",{\"1\":{\"216\":1}}],[\"redis分布式锁的正确实现方式\",{\"1\":{\"64\":1}}],[\"redis分布式锁操作的原子性\",{\"1\":{\"64\":2}}],[\"redis只在两个地方用到了跳跃表\",{\"1\":{\"64\":1}}],[\"redis内部是如何实现的\",{\"1\":{\"64\":2}}],[\"redis如何使用redis实现分布式锁\",{\"1\":{\"64\":2}}],[\"redis单进程单线程的redis如何能够高并发\",{\"1\":{\"64\":1}}],[\"redis跳跃表的问题\",{\"1\":{\"64\":2}}],[\"redis支持哪几种数据结构\",{\"1\":{\"64\":2}}],[\"redis采用多线程会有哪些问题\",{\"1\":{\"64\":2}}],[\"redis为什么这么快\",{\"1\":{\"64\":2}}],[\"redis\",{\"0\":{\"166\":1},\"1\":{\"64\":11,\"170\":3,\"172\":1,\"218\":1,\"219\":15}}],[\"reactor多线程模型和reactor主从多线程模型\",{\"1\":{\"216\":1}}],[\"readme\",{\"1\":{\"231\":3}}],[\"reade\",{\"1\":{\"216\":1}}],[\"readwritelock\",{\"0\":{\"112\":1}}],[\"readobject\",{\"1\":{\"74\":1}}],[\"read\",{\"1\":{\"64\":4,\"216\":2}}],[\"readnbytes\",{\"1\":{\"64\":1}}],[\"readallbytes\",{\"1\":{\"64\":1}}],[\"remove\",{\"1\":{\"217\":2}}],[\"remoting\",{\"1\":{\"216\":3}}],[\"remarked\",{\"1\":{\"231\":1}}],[\"remark\",{\"1\":{\"64\":1}}],[\"renyong\",{\"1\":{\"216\":1}}],[\"reei\",{\"1\":{\"216\":1}}],[\"reentrantlock通过代码中int类型的state标识来标识锁的状态\",{\"1\":{\"216\":1}}],[\"reentrantlock可以选择公平锁或非公平锁\",{\"1\":{\"216\":1}}],[\"reentrantlock需要程序员手动加锁与释放锁\",{\"1\":{\"216\":1}}],[\"reentrantlock是api层面的锁\",{\"1\":{\"216\":1}}],[\"reentrantlock是一个类\",{\"1\":{\"216\":1}}],[\"reentrantlock是可重入锁\",{\"1\":{\"216\":1}}],[\"reentrantlock中trylock\",{\"1\":{\"216\":1}}],[\"reentrantlock中的公平锁和非公平锁的底层实现\",{\"1\":{\"216\":1}}],[\"reentrantlock\",{\"1\":{\"64\":1,\"83\":2}}],[\"reverse\",{\"1\":{\"86\":4}}],[\"registry上下载镜像\",{\"1\":{\"217\":1}}],[\"registry莫过于官⽅的docker\",{\"1\":{\"217\":1}}],[\"registry和私有docker\",{\"1\":{\"217\":1}}],[\"registry可分为公有docker\",{\"1\":{\"217\":1}}],[\"registry可包含多个\",{\"1\":{\"217\":1}}],[\"registry比作\",{\"1\":{\"217\":1}}],[\"registry来避免镜像的手动复制\",{\"1\":{\"217\":1}}],[\"registry是一个集中存储与分发镜像的服务\",{\"1\":{\"217\":1}}],[\"registryservice\",{\"1\":{\"216\":1}}],[\"registryfactory\",{\"1\":{\"216\":1}}],[\"registry\",{\"1\":{\"64\":1,\"216\":2,\"217\":4,\"219\":1}}],[\"ref\",{\"1\":{\"216\":1}}],[\"referenceconfig\",{\"1\":{\"216\":1}}],[\"reference注解来引入一个服务时\",{\"1\":{\"216\":1}}],[\"reference\",{\"1\":{\"64\":3}}],[\"reflow\",{\"1\":{\"57\":4,\"58\":2}}],[\"rejectedexecutionhandler\",{\"1\":{\"64\":2}}],[\"replicas\",{\"1\":{\"219\":1}}],[\"replication\",{\"1\":{\"64\":3}}],[\"repos\",{\"1\":{\"231\":1}}],[\"repository\",{\"1\":{\"217\":1}}],[\"repo=extras\",{\"1\":{\"231\":1}}],[\"repo=updates\",{\"1\":{\"231\":1}}],[\"repo=os\",{\"1\":{\"231\":1}}],[\"repo\",{\"1\":{\"217\":2,\"231\":4}}],[\"repain\",{\"1\":{\"57\":5}}],[\"repeatable\",{\"1\":{\"64\":2}}],[\"repeat\",{\"1\":{\"22\":1}}],[\"response\",{\"1\":{\"216\":2}}],[\"responsebody\",{\"1\":{\"216\":1}}],[\"result\",{\"1\":{\"216\":1}}],[\"restart\",{\"1\":{\"217\":1,\"219\":6,\"226\":1}}],[\"rest\",{\"1\":{\"52\":1}}],[\"resource\",{\"1\":{\"34\":2,\"64\":1,\"216\":1}}],[\"retrycount\",{\"1\":{\"219\":1}}],[\"retransmit\",{\"1\":{\"26\":1}}],[\"returns\",{\"1\":{\"73\":1}}],[\"return\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":2,\"64\":2,\"69\":2,\"73\":1,\"77\":2,\"86\":1,\"87\":5}}],[\"r\",{\"1\":{\"4\":11,\"217\":3}}],[\"ln\",{\"1\":{\"231\":2}}],[\"lnstantiationstrategy\",{\"1\":{\"216\":1}}],[\"l=$city\",{\"1\":{\"223\":1}}],[\"lua脚本\",{\"1\":{\"216\":1}}],[\"luyuxugsx8wtozy7\",{\"1\":{\"64\":1}}],[\"lransaction\",{\"1\":{\"216\":2}}],[\"lrange\",{\"1\":{\"170\":1}}],[\"lrange等\",{\"1\":{\"170\":1}}],[\"lru\",{\"1\":{\"64\":2}}],[\"lpop\",{\"1\":{\"170\":1}}],[\"lpush\",{\"1\":{\"170\":1}}],[\"lvgg\",{\"1\":{\"64\":1}}],[\"limit\",{\"1\":{\"218\":1}}],[\"lib\",{\"1\":{\"217\":1,\"218\":2,\"219\":6,\"225\":1}}],[\"lisi\",{\"1\":{\"87\":1}}],[\"list<\",{\"1\":{\"69\":1}}],[\"list接口存储一组不唯一\",{\"1\":{\"67\":1}}],[\"listfiles\",{\"1\":{\"64\":1}}],[\"list中的元素有序\",{\"1\":{\"64\":1}}],[\"list中存储的数据是有顺序\",{\"1\":{\"64\":1}}],[\"list是存储单列数据的集合\",{\"1\":{\"64\":1}}],[\"list\",{\"0\":{\"170\":1},\"1\":{\"64\":11,\"67\":1,\"69\":6,\"86\":4,\"89\":1,\"170\":5,\"217\":1,\"219\":1}}],[\"line\",{\"1\":{\"231\":1}}],[\"linux总结\",{\"0\":{\"205\":1}}],[\"linux系统下查看cpu\",{\"1\":{\"64\":2}}],[\"linux系统swappiness参数在内存与交换分区之间优化作用\",{\"1\":{\"64\":1}}],[\"linux上提供的memory\",{\"1\":{\"64\":1}}],[\"linux进程间通信方式\",{\"1\":{\"64\":1}}],[\"linux\",{\"1\":{\"44\":1,\"51\":1,\"64\":1,\"217\":2,\"231\":1}}],[\"links\",{\"1\":{\"219\":18}}],[\"linkedblockingdeque\",{\"1\":{\"64\":1}}],[\"linkedblockingqueue\",{\"1\":{\"64\":2}}],[\"linkedhashset\",{\"1\":{\"64\":3,\"89\":2}}],[\"linkedhashmap会产生java\",{\"1\":{\"64\":1}}],[\"linkedhashmap工作原理及实现\",{\"1\":{\"64\":1}}],[\"linkedhashmap\",{\"1\":{\"64\":3,\"89\":1,\"90\":4}}],[\"linkedlist更适合删除和添加\",{\"1\":{\"216\":1}}],[\"linkedlist底层是基于链表实现的\",{\"1\":{\"216\":1}}],[\"linkedlist线程不同步\",{\"1\":{\"64\":1}}],[\"linkedlist线程不安全\",{\"1\":{\"64\":1}}],[\"linkedlist则以链表的形式进行存储\",{\"1\":{\"64\":1}}],[\"linkedlist的区别是什么\",{\"1\":{\"64\":1}}],[\"linkedlist适合指定位置插入\",{\"1\":{\"64\":2}}],[\"linkedlist\",{\"0\":{\"68\":1},\"1\":{\"64\":4,\"68\":4,\"69\":2,\"89\":1}}],[\"link\",{\"1\":{\"11\":1,\"216\":1}}],[\"looking\",{\"1\":{\"216\":1}}],[\"loop\",{\"1\":{\"57\":1}}],[\"login\",{\"1\":{\"219\":3}}],[\"login命令登录镜像仓库\",{\"1\":{\"218\":1}}],[\"logstash\",{\"1\":{\"219\":7}}],[\"logs\",{\"1\":{\"217\":1,\"219\":9}}],[\"log来实现事务\",{\"1\":{\"216\":1}}],[\"logbuffer\",{\"1\":{\"216\":1}}],[\"log\",{\"1\":{\"84\":1,\"216\":1,\"218\":2,\"219\":5}}],[\"load\",{\"0\":{\"207\":1},\"1\":{\"73\":2,\"77\":1}}],[\"loadfactor\",{\"1\":{\"73\":6}}],[\"load的理解\",{\"1\":{\"64\":1}}],[\"loadbalance\",{\"1\":{\"64\":5,\"216\":1}}],[\"localtime\",{\"1\":{\"219\":20,\"231\":2}}],[\"local\",{\"1\":{\"216\":5,\"218\":1,\"222\":2,\"223\":1,\"225\":3,\"231\":1}}],[\"locate\",{\"1\":{\"34\":1}}],[\"locations\",{\"1\":{\"219\":1}}],[\"location\",{\"1\":{\"34\":1,\"169\":1}}],[\"lock底层用的reentrantlock\",{\"0\":{\"112\":1}}],[\"lock\",{\"1\":{\"64\":2}}],[\"long\",{\"1\":{\"64\":1}}],[\"latest\",{\"1\":{\"217\":1}}],[\"lazy\",{\"1\":{\"64\":1,\"216\":1}}],[\"lang包\",{\"1\":{\"85\":1}}],[\"lang\",{\"1\":{\"64\":1}}],[\"language\",{\"1\":{\"51\":2}}],[\"last\",{\"1\":{\"64\":1}}],[\"layer\",{\"1\":{\"8\":1,\"9\":1,\"11\":1,\"12\":1}}],[\"l++\",{\"1\":{\"4\":2}}],[\"level\",{\"1\":{\"219\":1}}],[\"lettuce\",{\"1\":{\"219\":1}}],[\"let\",{\"1\":{\"219\":1}}],[\"len\",{\"1\":{\"216\":1}}],[\"length==hash\",{\"1\":{\"79\":1}}],[\"length\",{\"1\":{\"1\":2,\"2\":2,\"3\":3,\"4\":2,\"79\":2}}],[\"leaf等开源中间件实现了雪花算法\",{\"1\":{\"216\":1}}],[\"leader依然还是leader\",{\"1\":{\"216\":1}}],[\"leader检测\",{\"1\":{\"64\":1}}],[\"leader副本的时候\",{\"1\":{\"64\":1}}],[\"least\",{\"1\":{\"64\":2}}],[\"leastactive\",{\"1\":{\"64\":1}}],[\"less\",{\"1\":{\"4\":2}}],[\"l\",{\"1\":{\"4\":12}}],[\"jiangqingdong\",{\"1\":{\"223\":1}}],[\"jianshu\",{\"1\":{\"64\":3}}],[\"jpg\",{\"1\":{\"219\":1}}],[\"jprofile\",{\"1\":{\"64\":1}}],[\"jre\",{\"1\":{\"219\":1,\"248\":1,\"249\":1}}],[\"just\",{\"1\":{\"219\":1}}],[\"juejin\",{\"1\":{\"70\":1,\"92\":1}}],[\"jmap这些命令\",{\"1\":{\"218\":1,\"219\":10}}],[\"jmap是怎么做到的\",{\"0\":{\"186\":1}}],[\"jmovm\",{\"1\":{\"216\":1}}],[\"jni全局引用\",{\"1\":{\"64\":1}}],[\"jni方法栈中的局部变量或者参数\",{\"1\":{\"64\":1}}],[\"join\",{\"1\":{\"64\":1}}],[\"jx\",{\"1\":{\"64\":1}}],[\"jdbc\",{\"1\":{\"216\":3,\"219\":1}}],[\"jdbc和mybatis的区别\",{\"0\":{\"104\":1}}],[\"jdbc如何实现事务\",{\"1\":{\"64\":2}}],[\"jdk代理和cglib代理区别啥的\",{\"0\":{\"134\":1}}],[\"jdk原生代码无疑使用的人会更多范围也更广\",{\"1\":{\"64\":1}}],[\"jdk原生代码\",{\"1\":{\"64\":1}}],[\"jdk\",{\"1\":{\"64\":3,\"77\":4,\"80\":1,\"249\":1}}],[\"jdk6\",{\"1\":{\"64\":1}}],[\"jdk5\",{\"1\":{\"64\":3}}],[\"jdk8\",{\"1\":{\"64\":1}}],[\"jdk8的增强\",{\"1\":{\"64\":1}}],[\"jdk8以后\",{\"1\":{\"64\":1}}],[\"jdk8以前\",{\"1\":{\"64\":1}}],[\"jdk动态代理只能为接口创建动态代理实例\",{\"1\":{\"64\":1}}],[\"jdk1\",{\"0\":{\"77\":1,\"78\":1,\"83\":1,\"84\":1},\"1\":{\"64\":5,\"68\":2,\"73\":1,\"77\":3,\"78\":1,\"81\":7,\"89\":2,\"90\":3}}],[\"jtp06197\",{\"1\":{\"64\":1}}],[\"jackson\",{\"1\":{\"64\":1}}],[\"jackieeecheng\",{\"1\":{\"64\":1}}],[\"jar包直接运行了from\",{\"1\":{\"248\":1}}],[\"jar包冲突时在类加载过程中哪一步报的错\",{\"0\":{\"189\":1}}],[\"jar包冲突遇到过吗\",{\"0\":{\"189\":1}}],[\"jar所在目录的上一级目录\",{\"1\":{\"219\":1}}],[\"jar等\",{\"1\":{\"64\":1}}],[\"jar\",{\"1\":{\"64\":2,\"218\":4,\"219\":14,\"248\":2}}],[\"javaagent\",{\"1\":{\"219\":10}}],[\"java镜像\",{\"1\":{\"217\":1}}],[\"java仓库下载最新版本的\",{\"1\":{\"217\":1}}],[\"java这个关键词的镜像仓库\",{\"1\":{\"217\":1}}],[\"javassist等代理机制\",{\"1\":{\"216\":1}}],[\"java代码从编译到执行有哪些步骤\",{\"0\":{\"187\":1}}],[\"java基础\",{\"0\":{\"93\":1}}],[\"java基础篇\",{\"1\":{\"64\":1}}],[\"java集合\",{\"0\":{\"66\":1}}],[\"java集合框架\",{\"1\":{\"64\":1}}],[\"java自带序列化\",{\"1\":{\"64\":1}}],[\"java在方法调用传递参数时\",{\"1\":{\"64\":1}}],[\"java中四种引用类型\",{\"1\":{\"64\":1}}],[\"java中\",{\"1\":{\"64\":1}}],[\"java中没有指针的概念\",{\"1\":{\"64\":1}}],[\"java中参数传递时的问题\",{\"1\":{\"64\":2}}],[\"java中的参数传递时传值呢\",{\"1\":{\"64\":1}}],[\"java中的线程安全是什么\",{\"1\":{\"64\":1}}],[\"java中的队列都有哪些\",{\"1\":{\"64\":1}}],[\"java中的treeset\",{\"1\":{\"64\":1}}],[\"java方法栈中的局部变量或者参数\",{\"1\":{\"64\":1}}],[\"java对象内存分配策略\",{\"1\":{\"64\":1}}],[\"java的内存模型以及gc算法\",{\"1\":{\"64\":1}}],[\"java内存模型\",{\"1\":{\"64\":1}}],[\"java优化\",{\"1\":{\"64\":2}}],[\"java就更多了\",{\"1\":{\"64\":1}}],[\"java线程池主线程等待子线程执行完成\",{\"1\":{\"64\":1}}],[\"java线程池与五种常用线程池策略使用与解析\",{\"1\":{\"64\":1}}],[\"java线程池原理详解二\",{\"1\":{\"64\":1}}],[\"java线程池原理详解一\",{\"1\":{\"64\":1}}],[\"java并发编程学习笔记之clh队列锁\",{\"1\":{\"64\":1}}],[\"java并发编程实战\",{\"1\":{\"64\":1}}],[\"java并发编程的类\",{\"1\":{\"64\":1}}],[\"java并发编程\",{\"1\":{\"64\":1}}],[\"java并发和并行\",{\"1\":{\"64\":1}}],[\"java阻塞队列arrayblockingqueue和linkedblockingqueue实现原理分析\",{\"1\":{\"64\":1}}],[\"java数组和链表两种结构的操作效率\",{\"1\":{\"64\":1}}],[\"java8的新特性\",{\"1\":{\"64\":1}}],[\"java8新特性\",{\"1\":{\"64\":1}}],[\"java7\",{\"1\":{\"64\":2}}],[\"java反射中\",{\"1\":{\"64\":1}}],[\"java终级面试题\",{\"1\":{\"64\":1}}],[\"javazhiyin\",{\"1\":{\"64\":1}}],[\"java9\",{\"1\":{\"64\":1}}],[\"java9比java8改进了什么\",{\"1\":{\"64\":2}}],[\"java\",{\"1\":{\"64\":22,\"75\":1,\"78\":1,\"84\":1,\"85\":1,\"91\":3,\"94\":2,\"217\":4,\"218\":4,\"219\":16,\"231\":1,\"248\":1,\"249\":2}}],[\"java扩展篇\",{\"1\":{\"64\":2}}],[\"java多线程\",{\"1\":{\"64\":2}}],[\"javaguide\",{\"1\":{\"6\":1,\"66\":1,\"75\":1,\"91\":2}}],[\"jvm在加载类时\",{\"1\":{\"216\":1}}],[\"jvm在加载一个类时\",{\"1\":{\"216\":1}}],[\"jvm在进行垃圾回收时\",{\"1\":{\"216\":1}}],[\"jvm中存在三个默认的类加载器\",{\"1\":{\"216\":1}}],[\"jvm中哪些可以作为gc\",{\"1\":{\"216\":1}}],[\"jvm中哪些是线程共享区\",{\"1\":{\"216\":1}}],[\"jvm中最大堆大小有没有限制\",{\"1\":{\"64\":1}}],[\"jvm调优实战说一下\",{\"0\":{\"176\":1}}],[\"jvm调优常用参数配置\",{\"1\":{\"64\":1}}],[\"jvm总结\",{\"0\":{\"175\":1}}],[\"jvm了解吗\",{\"0\":{\"108\":1}}],[\"jvm的模型有什么\",{\"0\":{\"107\":1}}],[\"jvm会根据系统配置自行设置\",{\"1\":{\"64\":1}}],[\"jvm会根据当前系统配置\",{\"1\":{\"64\":1}}],[\"jvm会自动调整年轻代大小\",{\"1\":{\"64\":1}}],[\"jvm会把该线程置为阻塞状态\",{\"1\":{\"64\":1}}],[\"jvm会把该线程放入\",{\"1\":{\"64\":1}}],[\"jvm给了三种选择\",{\"1\":{\"64\":1}}],[\"jvm老年代和新生代的比例\",{\"1\":{\"64\":1}}],[\"jvm源码分析之string\",{\"1\":{\"64\":1}}],[\"jvm源码分析之systemgc完全解读\",{\"1\":{\"64\":1}}],[\"jvm源码分析之堆外内存完全解读\",{\"1\":{\"64\":1}}],[\"jvm内存溢出详解\",{\"1\":{\"64\":1}}],[\"jvm内存模型与gc算法\",{\"1\":{\"64\":1}}],[\"jvm内存模型\",{\"1\":{\"64\":2}}],[\"jvm直接内存\",{\"1\":{\"64\":1}}],[\"jvm性能调优\",{\"1\":{\"64\":1}}],[\"jvm性能调优都做了什么\",{\"1\":{\"64\":1}}],[\"jvm\",{\"1\":{\"64\":16,\"219\":1}}],[\"jvm虚拟机内存划分\",{\"1\":{\"64\":3}}],[\"jvm里的有几种classloader\",{\"1\":{\"64\":2}}],[\"jvm相关\",{\"1\":{\"64\":2}}],[\"jsr310日期api的支持\",{\"1\":{\"64\":2}}],[\"jsr\",{\"1\":{\"64\":2}}],[\"jshell\",{\"1\":{\"64\":2}}],[\"js\",{\"1\":{\"56\":1,\"57\":14,\"219\":1}}],[\"json\",{\"1\":{\"52\":2,\"64\":1,\"217\":2,\"231\":1}}],[\"jetty和undertow这样的容器\",{\"1\":{\"64\":1}}],[\"jetty\",{\"1\":{\"53\":1,\"64\":1}}],[\"j++\",{\"1\":{\"3\":1}}],[\"j\",{\"1\":{\"2\":7,\"3\":4,\"4\":3,\"64\":2}}],[\"src\",{\"1\":{\"248\":2}}],[\"src可以是\",{\"1\":{\"218\":1}}],[\"sf\",{\"1\":{\"231\":2}}],[\"sso\",{\"1\":{\"219\":1}}],[\"ssl协议及完整交互过程\",{\"1\":{\"64\":2}}],[\"ssl\",{\"1\":{\"35\":1,\"47\":2,\"48\":3}}],[\"snapshot\",{\"1\":{\"218\":1,\"219\":2}}],[\"snailclimb\",{\"1\":{\"169\":1}}],[\"skywalking\",{\"1\":{\"219\":10}}],[\"skeleton\",{\"1\":{\"216\":1}}],[\"skiplist\",{\"1\":{\"64\":1}}],[\"s3为true\",{\"1\":{\"216\":1}}],[\"s2为false\",{\"1\":{\"216\":1}}],[\"should\",{\"1\":{\"231\":1}}],[\"show=true\",{\"1\":{\"219\":1}}],[\"showduplicates\",{\"1\":{\"217\":1}}],[\"show\",{\"1\":{\"216\":1,\"219\":2}}],[\"shanghai\",{\"1\":{\"231\":3}}],[\"sha256\",{\"1\":{\"223\":2}}],[\"shared\",{\"1\":{\"219\":1}}],[\"share\",{\"1\":{\"218\":1,\"219\":3,\"231\":2}}],[\"sh\",{\"1\":{\"217\":1,\"218\":2,\"219\":2,\"223\":5,\"224\":2,\"231\":2,\"247\":1}}],[\"shell\",{\"1\":{\"217\":1,\"231\":4}}],[\"shimo\",{\"1\":{\"64\":1}}],[\"smoke\",{\"1\":{\"248\":1}}],[\"smembers\",{\"1\":{\"171\":1}}],[\"smtp协议等等\",{\"1\":{\"8\":1}}],[\"specify\",{\"1\":{\"219\":2}}],[\"split\",{\"1\":{\"216\":1}}],[\"spop\",{\"1\":{\"171\":1}}],[\"spring在启动时\",{\"1\":{\"216\":1}}],[\"spring需要很据beandefinition来实例化bean\",{\"1\":{\"216\":1}}],[\"spring用到了哪些设计模式\",{\"1\":{\"216\":1}}],[\"spring会发布一个容器启动事件\",{\"1\":{\"216\":1}}],[\"spring会创建一个代理对象作为bean\",{\"1\":{\"216\":1}}],[\"spring容器启动流程是怎样的\",{\"1\":{\"216\":1}}],[\"spring本身并没有针对bean做线程安全的处理\",{\"1\":{\"216\":1}}],[\"spring启动\",{\"1\":{\"216\":1}}],[\"spring执行机制\",{\"0\":{\"136\":1}}],[\"springcloud用过什么\",{\"0\":{\"130\":1}}],[\"spring的扫描就是通过benafactorypostprocessor来实现的\",{\"1\":{\"216\":1}}],[\"spring的bean是怎么管理\",{\"0\":{\"127\":1}}],[\"spring的ioc和aop\",{\"0\":{\"126\":1}}],[\"spring的事务管理\",{\"1\":{\"64\":1}}],[\"spring和springmvc的常用注解\",{\"0\":{\"125\":1}}],[\"spring中什么时候\",{\"1\":{\"216\":1}}],[\"spring中的设计模式\",{\"1\":{\"216\":1}}],[\"spring中的事务是如何实现的\",{\"1\":{\"216\":1}}],[\"spring中的bean创建的生命周期有哪些步骤\",{\"1\":{\"216\":1}}],[\"spring中bean是线程安全的吗\",{\"1\":{\"216\":1}}],[\"spring中beanfactory和applicationcontext的联系和区别\",{\"1\":{\"64\":1}}],[\"spring中一个bean的创建大概分为以下几个步骤\",{\"1\":{\"216\":1}}],[\"spring中用到哪些设计模式\",{\"1\":{\"64\":2}}],[\"springioc\",{\"1\":{\"64\":1}}],[\"spring循环依赖的三种方式\",{\"1\":{\"64\":1}}],[\"spring注入的几种方式\",{\"1\":{\"64\":1}}],[\"spring系列之beanfactory与applicationcontext\",{\"1\":{\"64\":1}}],[\"spring框架中需要引用哪些jar包\",{\"1\":{\"64\":1}}],[\"spring事务等等功能的时候\",{\"1\":{\"216\":1}}],[\"spring事务管理\",{\"1\":{\"64\":2}}],[\"spring事务\",{\"0\":{\"137\":1},\"1\":{\"64\":2}}],[\"spring4新特性\",{\"1\":{\"64\":8}}],[\"spring5官方文档\",{\"1\":{\"64\":1}}],[\"springboot\",{\"1\":{\"219\":1}}],[\"springboot在启动时会先创建一个spring容器\",{\"1\":{\"216\":1}}],[\"springboot是如何启动tomcat的\",{\"1\":{\"216\":1}}],[\"springbootconfiguration\",{\"1\":{\"216\":1}}],[\"springbootapplication注解\",{\"1\":{\"216\":1}}],[\"springboot中配置文件的加载顺序是怎样的\",{\"1\":{\"216\":1}}],[\"springboot中配置优先级是怎样的\",{\"1\":{\"216\":1}}],[\"springboot中常用注解及其底层实现\",{\"1\":{\"216\":1}}],[\"springboot中基于\",{\"1\":{\"216\":1}}],[\"springboot会通过自动配置类来承载这些bean\",{\"1\":{\"216\":1}}],[\"springboot会自引入其他依赖\",{\"1\":{\"64\":1}}],[\"springboot的自动配置就是帮我们配置了一些\",{\"1\":{\"216\":1}}],[\"springboot的自动配置主要作用就是帮助程序员配置了bean\",{\"1\":{\"216\":1}}],[\"springboot的自动配置是如何实现的\",{\"1\":{\"216\":1}}],[\"springboot的compantscan扫描范围是所有的包还是到哪一层\",{\"0\":{\"129\":1}}],[\"springboot的注解\",{\"0\":{\"128\":1}}],[\"springboot将原有的xml配置改为java配置\",{\"1\":{\"64\":1}}],[\"springboot可以建立独立的spring应用程序\",{\"1\":{\"64\":1}}],[\"spring如何实现事务管理的\",{\"1\":{\"64\":1}}],[\"spring如何实现事务\",{\"1\":{\"64\":2}}],[\"springmvc的底层工作流程\",{\"1\":{\"216\":1}}],[\"springmvc的执行流程\",{\"0\":{\"139\":1}}],[\"springmvc的原理\",{\"1\":{\"64\":1}}],[\"springmvc一个controller处理所有用户请求的并发问题\",{\"1\":{\"64\":1}}],[\"springmvc\",{\"1\":{\"64\":2}}],[\"spring\",{\"1\":{\"64\":35,\"216\":7,\"219\":5,\"248\":1}}],[\"spring相关\",{\"1\":{\"64\":2}}],[\"sigterm\",{\"1\":{\"237\":1}}],[\"sigkill信号来强制停止容器\",{\"1\":{\"217\":1}}],[\"simpleautowirecandidateresolver\",{\"1\":{\"216\":1}}],[\"size\",{\"1\":{\"69\":1,\"73\":1,\"216\":3,\"217\":1,\"219\":1}}],[\"singletontargetsource\",{\"1\":{\"216\":1}}],[\"sinterstore\",{\"1\":{\"171\":1}}],[\"sinat\",{\"1\":{\"64\":1}}],[\"since\",{\"1\":{\"33\":2}}],[\"s的磁盘就能达到惊人的600mb每秒\",{\"1\":{\"64\":1}}],[\"sleuth\",{\"1\":{\"216\":1}}],[\"slot上\",{\"1\":{\"64\":1}}],[\"slave中的数据不一致\",{\"1\":{\"64\":1}}],[\"sadd\",{\"1\":{\"171\":1}}],[\"sagas\",{\"1\":{\"64\":2}}],[\"sayhello\",{\"1\":{\"64\":5}}],[\"sbr\",{\"1\":{\"64\":2}}],[\"sudo\",{\"1\":{\"217\":1,\"219\":2}}],[\"subjectaltname\",{\"1\":{\"223\":1}}],[\"subj\",{\"1\":{\"223\":3}}],[\"subreactor\",{\"1\":{\"216\":1}}],[\"sub=ca2841acda7c4a6b9c1d8ee4e5b4379e\",{\"1\":{\"64\":1}}],[\"sunion\",{\"1\":{\"171\":1}}],[\"super\",{\"1\":{\"69\":1,\"87\":1}}],[\"support\",{\"1\":{\"219\":1}}],[\"supported\",{\"1\":{\"64\":1}}],[\"supports\",{\"1\":{\"64\":1}}],[\"some\",{\"1\":{\"231\":1}}],[\"sock\",{\"1\":{\"225\":1}}],[\"socket框架netty的使用\",{\"1\":{\"64\":1}}],[\"socket通信模型的使用\",{\"1\":{\"64\":1}}],[\"socket通信\",{\"1\":{\"64\":1}}],[\"socket通讯等\",{\"1\":{\"64\":1}}],[\"socketchannel\",{\"1\":{\"64\":1}}],[\"socket\",{\"1\":{\"53\":1,\"64\":1}}],[\"soa和微服务基本上都是分布式架构的\",{\"1\":{\"216\":1}}],[\"soa\",{\"1\":{\"216\":1}}],[\"software\",{\"1\":{\"231\":2}}],[\"soft\",{\"1\":{\"216\":1}}],[\"source=gold\",{\"1\":{\"92\":1}}],[\"sorted\",{\"0\":{\"172\":1},\"1\":{\"172\":2}}],[\"sortedset\",{\"1\":{\"64\":2}}],[\"sort\",{\"1\":{\"64\":1,\"85\":1,\"86\":5,\"217\":1}}],[\"sort排序算法\",{\"1\":{\"64\":1}}],[\"scale\",{\"1\":{\"219\":2}}],[\"scavenge收集器一般并不需要设置\",{\"1\":{\"64\":1}}],[\"scavenge收集器不认识这个参数\",{\"1\":{\"64\":1}}],[\"scavenge收集器\",{\"1\":{\"64\":1}}],[\"scheduler\",{\"1\":{\"64\":1}}],[\"swarm或kubernetes\",{\"1\":{\"219\":1}}],[\"swap交换分区概念\",{\"1\":{\"64\":1}}],[\"swap分区\",{\"1\":{\"64\":1}}],[\"swap\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":5,\"64\":1}}],[\"sweep\",{\"1\":{\"64\":2}}],[\"s1的清理都会由于minorgc\",{\"1\":{\"64\":1}}],[\"s0\",{\"1\":{\"64\":1}}],[\"sql单独写\",{\"1\":{\"216\":1}}],[\"sql\",{\"1\":{\"216\":8}}],[\"sql优化方式\",{\"0\":{\"153\":1}}],[\"sql优化\",{\"1\":{\"64\":2}}],[\"sql解析\",{\"1\":{\"64\":1}}],[\"sql行转列\",{\"1\":{\"64\":2}}],[\"sql的整个解析\",{\"1\":{\"64\":2}}],[\"st=$state\",{\"1\":{\"223\":1}}],[\"styletang\",{\"1\":{\"219\":1}}],[\"stream\",{\"1\":{\"218\":1}}],[\"string对象的intern方法\",{\"1\":{\"216\":1}}],[\"string数据结构是简单的key\",{\"1\":{\"168\":1}}],[\"string为啥默认用final\",{\"0\":{\"95\":1}}],[\"stringbuffer和stringbuilder是可变的\",{\"1\":{\"216\":1}}],[\"stringbuffer\",{\"1\":{\"94\":8,\"216\":1}}],[\"stringbuilder是线程不安全的\",{\"1\":{\"216\":1}}],[\"stringbuilder的区别\",{\"1\":{\"216\":1}}],[\"stringbuilder\",{\"1\":{\"94\":6,\"216\":1}}],[\"string和stringbuffer和stringbuilder区别\",{\"0\":{\"94\":1}}],[\"string>\",{\"1\":{\"87\":2}}],[\"stringtable\",{\"1\":{\"64\":1}}],[\"string\",{\"0\":{\"168\":1},\"1\":{\"64\":3,\"87\":5,\"94\":8,\"96\":11,\"169\":1,\"216\":1}}],[\"stop容器名称来停止指定容器\",{\"1\":{\"217\":1}}],[\"stop\",{\"1\":{\"217\":1,\"219\":2}}],[\"stop命令\",{\"1\":{\"217\":1}}],[\"storage\",{\"1\":{\"94\":1}}],[\"store\",{\"1\":{\"59\":1,\"219\":4}}],[\"step\",{\"1\":{\"216\":2}}],[\"stub\",{\"1\":{\"87\":1,\"216\":1}}],[\"stackoverflowerror异常\",{\"1\":{\"64\":1}}],[\"stat\",{\"1\":{\"219\":2}}],[\"stats\",{\"1\":{\"218\":3}}],[\"statistics\",{\"1\":{\"216\":1}}],[\"static\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":4,\"64\":1,\"69\":1,\"73\":1,\"77\":2,\"83\":1,\"87\":1,\"96\":1}}],[\"state=\",{\"1\":{\"223\":1}}],[\"state\",{\"1\":{\"216\":2}}],[\"statement模式\",{\"1\":{\"64\":1}}],[\"statement\",{\"1\":{\"64\":2,\"216\":1}}],[\"stateless\",{\"1\":{\"31\":1}}],[\"status\",{\"1\":{\"54\":1,\"217\":1,\"231\":1}}],[\"stars0\",{\"1\":{\"217\":1}}],[\"stars\",{\"1\":{\"217\":1}}],[\"starting\",{\"1\":{\"223\":1}}],[\"start命令来启动\",{\"1\":{\"217\":1}}],[\"start\",{\"1\":{\"217\":2,\"219\":1}}],[\"starter三部曲之三\",{\"1\":{\"64\":1}}],[\"starter三部曲之二\",{\"1\":{\"64\":1}}],[\"starter三部曲之一\",{\"1\":{\"64\":1}}],[\"starter\",{\"1\":{\"64\":2}}],[\"star\",{\"1\":{\"6\":1,\"66\":1,\"75\":1}}],[\"s\",{\"1\":{\"33\":1,\"37\":1}}],[\"seata\",{\"1\":{\"219\":1}}],[\"search\",{\"1\":{\"217\":1,\"219\":3}}],[\"search命令搜索存放在\",{\"1\":{\"217\":1}}],[\"secrets\",{\"1\":{\"219\":1}}],[\"secret\",{\"1\":{\"219\":2}}],[\"seconds\",{\"1\":{\"64\":1}}],[\"select关键字对应的那个查询的类型\",{\"1\":{\"216\":1}}],[\"select\",{\"1\":{\"216\":1}}],[\"selectionsort\",{\"1\":{\"3\":1}}],[\"sendmessagewithvipchannel=false\",{\"1\":{\"219\":1}}],[\"sendmsg\",{\"1\":{\"216\":2}}],[\"sende\",{\"1\":{\"216\":1}}],[\"send\",{\"1\":{\"216\":2}}],[\"sendok\",{\"1\":{\"216\":2}}],[\"sendhaifmsg\",{\"1\":{\"216\":2}}],[\"segment的锁\",{\"1\":{\"83\":1}}],[\"segment<k\",{\"1\":{\"83\":1}}],[\"segment\",{\"1\":{\"81\":2,\"83\":7}}],[\"segmentfault\",{\"1\":{\"27\":1}}],[\"seek\",{\"1\":{\"64\":1}}],[\"semphore\",{\"1\":{\"64\":1}}],[\"semaphore表示信号量\",{\"1\":{\"216\":1}}],[\"semaphore\",{\"1\":{\"64\":1}}],[\"set增加了一个权重参数score\",{\"1\":{\"172\":1}}],[\"set是一个很好的选择\",{\"1\":{\"171\":1}}],[\"set<person>\",{\"1\":{\"87\":1}}],[\"setage\",{\"1\":{\"87\":1}}],[\"setautocommit\",{\"1\":{\"64\":3}}],[\"setname\",{\"1\":{\"87\":1}}],[\"setnx\",{\"1\":{\"64\":1}}],[\"set中的元素无序\",{\"1\":{\"64\":1}}],[\"set\",{\"0\":{\"67\":1,\"171\":1,\"172\":1},\"1\":{\"64\":8,\"67\":1,\"89\":1,\"168\":1,\"171\":3,\"172\":1,\"219\":1}}],[\"servlet\",{\"0\":{\"132\":1},\"1\":{\"219\":1}}],[\"service下配置了volumn\",{\"1\":{\"240\":1}}],[\"services=192\",{\"1\":{\"219\":10}}],[\"services\",{\"1\":{\"219\":4}}],[\"serviceproxy\",{\"1\":{\"216\":1}}],[\"serviceconfig\",{\"1\":{\"216\":1}}],[\"service注解进行解析得到程序员所定义的服务参数\",{\"1\":{\"216\":1}}],[\"service或\",{\"1\":{\"64\":1}}],[\"service>\",{\"1\":{\"64\":3}}],[\"service\",{\"1\":{\"64\":5,\"216\":1,\"217\":1,\"219\":5,\"225\":1,\"241\":2}}],[\"serverauth\",{\"1\":{\"223\":2}}],[\"server=\",{\"1\":{\"223\":1}}],[\"server=utf8mb4\",{\"1\":{\"219\":2}}],[\"servertimezone=utc\",{\"1\":{\"219\":1}}],[\"server构建docker镜像吗\",{\"1\":{\"219\":1}}],[\"server首页\",{\"1\":{\"218\":1}}],[\"server为例\",{\"1\":{\"218\":1}}],[\"serversocketchannel\",{\"1\":{\"64\":1}}],[\"serversocketchannel||socketchannel||filechannel\",{\"1\":{\"64\":1}}],[\"server\",{\"1\":{\"16\":3,\"55\":1,\"216\":2,\"218\":8,\"219\":9,\"223\":7,\"225\":2}}],[\"serialization\",{\"1\":{\"216\":1}}],[\"serializable\",{\"1\":{\"64\":1,\"83\":1}}],[\"serial\",{\"1\":{\"64\":1}}],[\"serial收集器\",{\"1\":{\"64\":1}}],[\"serial+serialold\",{\"1\":{\"64\":1}}],[\"sessiontimeoutms\",{\"1\":{\"219\":1}}],[\"session管理\",{\"1\":{\"64\":1}}],[\"session都是用来跟踪浏览器用户身份的会话方式\",{\"1\":{\"32\":1}}],[\"session\",{\"0\":{\"133\":1},\"1\":{\"31\":9,\"32\":4,\"219\":2}}],[\"sys\",{\"1\":{\"219\":10}}],[\"systemd\",{\"1\":{\"217\":1,\"225\":1}}],[\"systemctl\",{\"1\":{\"217\":4,\"226\":2}}],[\"system\",{\"1\":{\"64\":4,\"86\":8,\"87\":1,\"96\":4,\"216\":1,\"217\":1,\"225\":1,\"231\":1}}],[\"system缩写\",{\"1\":{\"8\":1}}],[\"sychronized和reentrantlock的区别\",{\"1\":{\"216\":1}}],[\"sychronized的偏向锁\",{\"1\":{\"216\":1}}],[\"sychornized\",{\"0\":{\"112\":1}}],[\"syncreplica\",{\"1\":{\"64\":1}}],[\"syncronized\",{\"1\":{\"64\":1}}],[\"synchronized等技术是没办法来控制多个进程中的线程的\",{\"1\":{\"216\":1}}],[\"synchronized等技术来作为锁\",{\"1\":{\"216\":1}}],[\"synchronized只锁定当前链表或红黑二叉树的首节点\",{\"1\":{\"84\":1}}],[\"synchronized锁做了很多优化\",{\"1\":{\"81\":1}}],[\"synchronized锁的是对象\",{\"1\":{\"64\":1}}],[\"synchronized锁粒度\",{\"1\":{\"64\":2}}],[\"synchronizedmap\",{\"1\":{\"64\":1}}],[\"synchronized标记的变量可以被编译器优化\",{\"1\":{\"64\":1}}],[\"synchronized可能会造成线程的阻塞\",{\"1\":{\"64\":1}}],[\"synchronized则可以使用在变量\",{\"1\":{\"64\":1}}],[\"synchronized则是锁定当前变量\",{\"1\":{\"64\":1}}],[\"synchronized还会创建一个内存屏障\",{\"1\":{\"64\":1}}],[\"synchronized\",{\"1\":{\"64\":3,\"81\":2}}],[\"synchronousqueue实现原理\",{\"1\":{\"64\":2}}],[\"synchronousqueue\",{\"1\":{\"64\":2}}],[\"synchronous\",{\"1\":{\"57\":1}}],[\"syn\",{\"0\":{\"17\":1,\"18\":1},\"1\":{\"15\":2,\"17\":4,\"18\":2}}],[\"+heapdumponoutofmemoryerror\",{\"1\":{\"216\":1}}],[\"+usecmscompactatfullcollection\",{\"1\":{\"64\":2}}],[\"+useconcmarksweepgc\",{\"1\":{\"64\":3}}],[\"+usecompressedoops\",{\"1\":{\"64\":2}}],[\"+useparnewgc\",{\"1\":{\"64\":2}}],[\"+useparalleloldgc\",{\"1\":{\"64\":2}}],[\"+useparallelgc\",{\"1\":{\"64\":5}}],[\"+useadaptivesizepolicy\",{\"1\":{\"64\":2}}],[\"+parallold\",{\"1\":{\"64\":1}}],[\"++less\",{\"1\":{\"4\":1}}],[\"+\",{\"1\":{\"1\":2,\"2\":2,\"3\":1,\"4\":4,\"47\":1,\"64\":4,\"73\":3,\"87\":2,\"216\":2,\"218\":1}}],[\"04\",{\"1\":{\"219\":1}}],[\"0k\",{\"1\":{\"217\":1}}],[\"0已经支持了应用级注册\",{\"1\":{\"216\":1}}],[\"0之前的版本采取的就是接口级注册\",{\"1\":{\"216\":1}}],[\"0之前仅仅只是语法层面的支持\",{\"1\":{\"216\":1}}],[\"09\",{\"0\":{\"197\":1}}],[\"003\",{\"1\":{\"64\":1}}],[\"008\",{\"1\":{\"64\":1}}],[\"060\",{\"1\":{\"64\":1}}],[\"0支持对年老代并行收集\",{\"1\":{\"64\":1}}],[\"0以上\",{\"1\":{\"64\":1}}],[\"0以后\",{\"1\":{\"64\":1}}],[\"0以前都是使用串行收集器\",{\"1\":{\"64\":1}}],[\"0l\",{\"1\":{\"64\":1}}],[\"03\",{\"1\":{\"64\":1,\"217\":1}}],[\"05\",{\"1\":{\"64\":1}}],[\"0中主要使用header里的if\",{\"1\":{\"33\":1}}],[\"0中\",{\"1\":{\"33\":2}}],[\"0中默认使用短连接\",{\"1\":{\"30\":1}}],[\"0最早在网页中使用是在1996年\",{\"1\":{\"33\":1}}],[\"0和http\",{\"0\":{\"33\":1}}],[\"0\",{\"1\":{\"1\":2,\"2\":1,\"3\":1,\"4\":2,\"25\":1,\"64\":6,\"73\":3,\"77\":1,\"96\":1,\"216\":1,\"218\":16,\"219\":39,\"223\":4,\"225\":4,\"231\":9}}],[\">home=$home\",{\"1\":{\"246\":1}}],[\">key\",{\"1\":{\"64\":1}}],[\">slot<\",{\"1\":{\"64\":1}}],[\">random\",{\"1\":{\"64\":1}}],[\">>>\",{\"1\":{\"73\":5,\"77\":6}}],[\">>\",{\"0\":{\"27\":1},\"1\":{\"219\":1,\"223\":4,\"231\":1}}],[\">=\",{\"1\":{\"2\":1,\"64\":2,\"73\":1,\"216\":1}}],[\">\",{\"1\":{\"1\":2,\"2\":1,\"4\":1,\"42\":5,\"64\":18,\"73\":1,\"87\":1,\"216\":2,\"218\":1}}],[\"1ms\",{\"1\":{\"219\":1}}],[\"1秒刷新一次\",{\"1\":{\"218\":1}}],[\"1客户端向服务端发送fin\",{\"1\":{\"216\":1}}],[\"1客户端向服务端发送一个syn\",{\"1\":{\"216\":1}}],[\"1为了保证消息不多\",{\"1\":{\"216\":1}}],[\"1pull表示消费者主动拉取\",{\"1\":{\"216\":1}}],[\"1proxy服务代理层\",{\"1\":{\"216\":1}}],[\"1死信队列也是一个消息队列\",{\"1\":{\"216\":1}}],[\"1解耦\",{\"1\":{\"216\":1}}],[\"1检查是否走了索引\",{\"1\":{\"216\":1}}],[\"1kb\",{\"1\":{\"216\":1}}],[\"1叶子节点存储的是完整的一条条的行数据\",{\"1\":{\"216\":1}}],[\"1乐观锁\",{\"1\":{\"216\":1}}],[\"1共享锁\",{\"1\":{\"216\":1}}],[\"1行锁\",{\"1\":{\"216\":1}}],[\"1拥有b树的特点\",{\"1\":{\"216\":1}}],[\"1节点排序\",{\"1\":{\"216\":1}}],[\"1innodb在收到一个update语句后\",{\"1\":{\"216\":1}}],[\"1i1\",{\"1\":{\"216\":1}}],[\"1先更新mysql\",{\"1\":{\"216\":1}}],[\"1先生成新数组\",{\"1\":{\"216\":2}}],[\"1缓存雪崩\",{\"1\":{\"216\":1}}],[\"1一般发生在从节点初始化的时候\",{\"1\":{\"216\":1}}],[\"1一般生产系统中都会设置当系统发生了oom时\",{\"1\":{\"216\":1}}],[\"1字符串\",{\"1\":{\"216\":1}}],[\"1nio模型\",{\"1\":{\"216\":1}}],[\"1异步\",{\"1\":{\"216\":1}}],[\"1分布式架构是指将单体架构中的各个部分拆分\",{\"1\":{\"216\":1}}],[\"1都是为了防止系统崩溃\",{\"1\":{\"216\":1}}],[\"1服务熔断是指\",{\"1\":{\"216\":1}}],[\"1当服务a调用服务b\",{\"1\":{\"216\":1}}],[\"1当程序员使用\",{\"1\":{\"216\":1}}],[\"1eureka\",{\"1\":{\"216\":1}}],[\"1随机\",{\"1\":{\"216\":1}}],[\"1集群中各个节点首先都是观望状态\",{\"1\":{\"216\":1}}],[\"1领导者选举阶段\",{\"1\":{\"216\":1}}],[\"1本地消息表\",{\"1\":{\"216\":1}}],[\"1zookeeper\",{\"1\":{\"216\":1}}],[\"1uuid\",{\"1\":{\"216\":1}}],[\"1bio\",{\"1\":{\"216\":1}}],[\"1ba\",{\"1\":{\"216\":1}}],[\"1bootstrapclassloader\",{\"1\":{\"216\":1}}],[\"1基于\",{\"1\":{\"216\":1}}],[\"1命令行参数\",{\"1\":{\"216\":1}}],[\"1用户发送请求至前端控制器dispatcherservlet\",{\"1\":{\"216\":1}}],[\"1在创建spring容器\",{\"1\":{\"216\":1}}],[\"1如果bean是无状态的\",{\"1\":{\"216\":1}}],[\"1如果此时线程池中的线程数量小于corepoolsize\",{\"1\":{\"216\":1}}],[\"1推断构造方法\",{\"1\":{\"216\":1}}],[\"1a\",{\"1\":{\"216\":1}}],[\"1a类\",{\"1\":{\"216\":1}}],[\"1控制对象的创建\",{\"1\":{\"216\":1}}],[\"1建一些类\",{\"1\":{\"216\":1}}],[\"1什么是控制\",{\"1\":{\"216\":1}}],[\"1浏览器解析用户输入的url\",{\"1\":{\"216\":1}}],[\"1可以使用jmap来查看jvm中各个区域的使用情况\",{\"1\":{\"216\":1}}],[\"1偏向锁\",{\"1\":{\"216\":1}}],[\"1trylock\",{\"1\":{\"216\":1}}],[\"1threadlocal是java中所提供的线程本地存储机制\",{\"1\":{\"216\":1}}],[\"1oo55h\",{\"1\":{\"216\":1}}],[\"1线购t1\",{\"1\":{\"216\":1}}],[\"1首先利用setnx来保证\",{\"1\":{\"216\":1}}],[\"1首先dubbo会将程序员所使用的\",{\"1\":{\"216\":1}}],[\"1首先集群启动时\",{\"1\":{\"216\":1}}],[\"1首先copyonwritearraylist内部也是用数组来实现的\",{\"1\":{\"216\":1}}],[\"1首先\",{\"1\":{\"216\":2}}],[\"1sql\",{\"1\":{\"216\":1}}],[\"1spring事务底层是基于数据库事务和aop机制的\",{\"1\":{\"216\":1}}],[\"1sychronized是一个关键字\",{\"1\":{\"216\":1}}],[\"1string是不可变的\",{\"1\":{\"216\":1}}],[\"1s1\",{\"1\":{\"216\":1}}],[\"1呢\",{\"1\":{\"216\":1}}],[\"1通过网络\",{\"1\":{\"216\":1}}],[\"1running\",{\"1\":{\"216\":2}}],[\"1点25\",{\"1\":{\"216\":2}}],[\"192\",{\"1\":{\"219\":4}}],[\"19\",{\"0\":{\"112\":1},\"1\":{\"217\":1}}],[\"18\",{\"0\":{\"111\":1}}],[\"17\",{\"0\":{\"110\":1}}],[\"15672\",{\"1\":{\"219\":2}}],[\"15hystrix\",{\"1\":{\"216\":1}}],[\"15\",{\"0\":{\"91\":1,\"108\":1,\"190\":1}}],[\"14sentinel\",{\"1\":{\"216\":1}}],[\"14\",{\"0\":{\"88\":1,\"107\":1,\"189\":1}}],[\"163\",{\"1\":{\"231\":16}}],[\"16383\",{\"1\":{\"64\":1}}],[\"168\",{\"1\":{\"219\":15}}],[\"16=18724条\",{\"1\":{\"216\":1}}],[\"16kb\",{\"1\":{\"216\":1}}],[\"16\",{\"0\":{\"109\":1},\"1\":{\"73\":1,\"77\":1}}],[\"160\",{\"1\":{\"64\":1}}],[\"16209077\",{\"1\":{\"37\":1}}],[\"1而且还支持http2\",{\"1\":{\"64\":1}}],[\"1xx\",{\"1\":{\"54\":1}}],[\"1则在请求头引入了range头域\",{\"1\":{\"33\":1}}],[\"1则在1999年才开始广泛应用于现在的各大浏览器网络请求中\",{\"1\":{\"33\":1}}],[\"1则引入了更多的缓存控制策略例如entity\",{\"1\":{\"33\":1}}],[\"1中新增了24个错误状态响应码\",{\"1\":{\"33\":1}}],[\"1的持续连接有非流水线方式和流水线方式\",{\"1\":{\"33\":1}}],[\"1的主要区别是什么\",{\"0\":{\"33\":1}}],[\"1也是当前使用最为广泛的http协议\",{\"1\":{\"33\":1}}],[\"13dubbo\",{\"1\":{\"216\":1}}],[\"13954634\",{\"1\":{\"64\":1}}],[\"13\",{\"0\":{\"33\":1,\"35\":1,\"85\":1,\"106\":1,\"188\":1,\"204\":1}}],[\"127\",{\"1\":{\"219\":2}}],[\"12seata\",{\"1\":{\"216\":1}}],[\"128至127之间\",{\"1\":{\"216\":1}}],[\"128至127这些数字提前生成integer对象\",{\"1\":{\"216\":1}}],[\"12\",{\"0\":{\"32\":1,\"34\":1,\"82\":1,\"105\":1,\"187\":1,\"203\":1},\"1\":{\"77\":1,\"217\":1}}],[\"1156\",{\"0\":{\"253\":1}}],[\"11800\",{\"1\":{\"219\":10}}],[\"111a\",{\"1\":{\"216\":1}}],[\"1111a\",{\"1\":{\"216\":1}}],[\"111是小于222的\",{\"1\":{\"216\":1}}],[\"11zipkin\",{\"1\":{\"216\":1}}],[\"11通过同步机制和两阶段提交机制来达到集群中节点数据一致\",{\"1\":{\"216\":1}}],[\"11dispatcherservlet\",{\"1\":{\"216\":1}}],[\"11spring事务的传播机制是基于数据库连接来做的\",{\"1\":{\"216\":1}}],[\"11\",{\"0\":{\"31\":1,\"81\":1,\"104\":1,\"186\":1,\"202\":1},\"1\":{\"216\":2,\"217\":1}}],[\"1190000006879700\",{\"1\":{\"27\":1}}],[\"1起\",{\"1\":{\"30\":1,\"33\":1}}],[\"10912\",{\"1\":{\"219\":2}}],[\"10911\",{\"1\":{\"219\":2}}],[\"10909\",{\"1\":{\"219\":2}}],[\"10spring\",{\"1\":{\"216\":1}}],[\"10spring事务的传播机制是spring事务自己实现的\",{\"1\":{\"216\":1}}],[\"10最后leader节点返回客户端写请求响应成功\",{\"1\":{\"216\":1}}],[\"10dispatcherservlet\",{\"1\":{\"216\":1}}],[\"100\",{\"1\":{\"219\":1}}],[\"100倍你怎么设计\",{\"0\":{\"195\":1}}],[\"1000w之间这些数全部生成\",{\"1\":{\"64\":1}}],[\"10\",{\"0\":{\"30\":1,\"80\":1,\"103\":1,\"185\":1,\"201\":1},\"1\":{\"58\":1,\"64\":13,\"87\":2,\"94\":1,\"217\":3,\"219\":1,\"230\":1}}],[\"1\",{\"0\":{\"6\":1,\"7\":2,\"14\":1,\"20\":1,\"21\":1,\"22\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":3,\"34\":1,\"35\":1,\"39\":1,\"67\":1,\"94\":1,\"152\":1,\"161\":1,\"167\":1,\"176\":1,\"192\":1,\"206\":1,\"209\":1},\"1\":{\"1\":3,\"2\":4,\"3\":2,\"4\":7,\"6\":1,\"23\":3,\"30\":2,\"33\":3,\"50\":2,\"57\":1,\"64\":47,\"66\":1,\"68\":3,\"69\":1,\"73\":4,\"75\":1,\"77\":5,\"79\":2,\"80\":1,\"86\":5,\"87\":2,\"89\":1,\"91\":1,\"96\":1,\"169\":1,\"216\":15,\"217\":4,\"218\":11,\"219\":26,\"231\":4,\"237\":1}}],[\"=1170对\",{\"1\":{\"216\":1}}],[\"=\",{\"1\":{\"1\":2,\"2\":2,\"3\":4,\"4\":6,\"64\":8,\"73\":4,\"77\":1,\"86\":1,\"87\":6,\"94\":1,\"96\":4,\"216\":5,\"219\":6,\"223\":3}}],[\"========end========\",{\"1\":{\"223\":1}}],[\"==和equals区别\",{\"0\":{\"96\":1}}],[\"==指引用是否相同\",{\"1\":{\"75\":1}}],[\"==是指对内存地址进行比较\",{\"1\":{\"75\":1}}],[\"==是判断两个变量或实例是不是指向同一个内存空间\",{\"1\":{\"75\":1}}],[\"==与equals的区别\",{\"1\":{\"75\":1}}],[\"==\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1,\"64\":3,\"77\":1,\"96\":5,\"216\":4}}],[\"emailaddress=$email\",{\"1\":{\"223\":1}}],[\"email=\",{\"1\":{\"223\":1}}],[\"es\",{\"1\":{\"219\":4}}],[\"echo\",{\"1\":{\"218\":1,\"223\":6,\"231\":1,\"246\":2}}],[\"ecsskgs\",{\"1\":{\"216\":1}}],[\"ee\",{\"1\":{\"217\":1}}],[\"ee8c9dccc953\",{\"1\":{\"64\":1}}],[\"edition\",{\"1\":{\"217\":2}}],[\"eden的清理\",{\"1\":{\"64\":1}}],[\"eureka目录\",{\"1\":{\"218\":1}}],[\"eureka\",{\"1\":{\"216\":1,\"218\":9,\"219\":8}}],[\"e如果消费失败\",{\"1\":{\"216\":2}}],[\"e五个字段\",{\"1\":{\"216\":1}}],[\"each\",{\"1\":{\"77\":1,\"231\":1}}],[\"equals\",{\"1\":{\"75\":2,\"96\":9}}],[\"equals是判断两个变量或实例所指向的内存空间的值是不是相同\",{\"1\":{\"75\":1}}],[\"equals方法被覆盖过\",{\"1\":{\"75\":1}}],[\"elapsedtimems\",{\"1\":{\"219\":1}}],[\"elasticsearch\",{\"1\":{\"219\":12}}],[\"el7\",{\"1\":{\"217\":1}}],[\"element\",{\"1\":{\"68\":2}}],[\"else\",{\"1\":{\"4\":2,\"64\":2,\"69\":1,\"87\":1}}],[\"existing\",{\"1\":{\"231\":1}}],[\"exited表示已停止\",{\"1\":{\"217\":1}}],[\"example\",{\"1\":{\"219\":3}}],[\"exactly\",{\"1\":{\"64\":7}}],[\"execstart=\",{\"1\":{\"225\":1}}],[\"execstart\",{\"1\":{\"225\":1}}],[\"exec\",{\"1\":{\"217\":1,\"219\":2,\"231\":1,\"237\":1}}],[\"exec命令用于进入一个正在运行的docker容器\",{\"1\":{\"217\":1}}],[\"executors\",{\"1\":{\"64\":3}}],[\"executes=\",{\"1\":{\"64\":2}}],[\"executes\",{\"1\":{\"64\":1}}],[\"exclusions\",{\"1\":{\"219\":1}}],[\"exchange\",{\"1\":{\"216\":2}}],[\"exchangeserver\",{\"1\":{\"216\":1}}],[\"exchangeclient\",{\"1\":{\"216\":1}}],[\"exchangechannel\",{\"1\":{\"216\":1}}],[\"exchanger\",{\"1\":{\"216\":1}}],[\"excutors可以产生哪些线程池\",{\"1\":{\"64\":1}}],[\"extfile\",{\"1\":{\"223\":8}}],[\"external\",{\"1\":{\"219\":12}}],[\"extend\",{\"1\":{\"231\":1}}],[\"extendedkeyusage=clientauth\",{\"1\":{\"223\":1}}],[\"extendedkeyusage\",{\"1\":{\"223\":2}}],[\"extends文件或环境变量文件等\",{\"1\":{\"219\":1}}],[\"extends\",{\"1\":{\"69\":1,\"83\":1,\"219\":1}}],[\"extension\",{\"1\":{\"92\":1,\"219\":1}}],[\"extras\",{\"1\":{\"231\":3}}],[\"extra\",{\"1\":{\"216\":1,\"230\":1}}],[\"extclassloader的父加载器是bootstrapclassloader\",{\"1\":{\"216\":1}}],[\"exposure\",{\"1\":{\"219\":1}}],[\"expose\",{\"1\":{\"218\":2,\"219\":3}}],[\"exporter\",{\"1\":{\"216\":2}}],[\"explain语句结果中各个字段分表表示什么\",{\"1\":{\"216\":1}}],[\"expandcapacity\",{\"1\":{\"94\":1}}],[\"expires来做为缓存判断的标准\",{\"1\":{\"33\":1}}],[\"endpoint\",{\"1\":{\"219\":1}}],[\"endpoints\",{\"1\":{\"219\":1}}],[\"engine\",{\"1\":{\"219\":1}}],[\"engine=innodb\",{\"1\":{\"216\":1}}],[\"env=development\",{\"1\":{\"219\":1}}],[\"environment\",{\"1\":{\"219\":20}}],[\"env\",{\"1\":{\"218\":1,\"219\":11,\"231\":1,\"243\":2}}],[\"enabled=0\",{\"1\":{\"231\":1}}],[\"enable\",{\"1\":{\"217\":1}}],[\"enableautoconfiguration\",{\"1\":{\"216\":1}}],[\"enterprise\",{\"1\":{\"217\":1}}],[\"entrypoint指令可以结合cmd指令使用\",{\"1\":{\"231\":1}}],[\"entrypoint指令都将使用该用户执行命令\",{\"1\":{\"218\":1}}],[\"entrypointcommand\",{\"1\":{\"231\":1}}],[\"entrypoint后面跟\",{\"1\":{\"231\":1}}],[\"entrypoint\",{\"1\":{\"218\":1,\"219\":1,\"231\":4}}],[\"entrypoint和\",{\"1\":{\"218\":1}}],[\"entrypint\",{\"1\":{\"218\":1}}],[\"entry对象也就不会被回收\",{\"1\":{\"216\":1}}],[\"entry的前面去\",{\"1\":{\"64\":1}}],[\"entry\",{\"1\":{\"64\":1}}],[\"encode\",{\"1\":{\"216\":2}}],[\"encoding\",{\"1\":{\"51\":3}}],[\"ensures\",{\"1\":{\"77\":1}}],[\"en\",{\"1\":{\"64\":1}}],[\"eventually\",{\"1\":{\"216\":1}}],[\"eventlistener注解的方法适九成applicationlistener\",{\"1\":{\"216\":1}}],[\"event\",{\"1\":{\"57\":1}}],[\"eg\",{\"1\":{\"50\":1}}],[\"etc\",{\"1\":{\"44\":1,\"217\":3,\"219\":22,\"223\":2,\"231\":4}}],[\"e\",{\"1\":{\"1\":4,\"68\":5,\"216\":1,\"218\":1,\"219\":1}}],[\"2push表示broker主动给消费者推送消息\",{\"1\":{\"216\":1}}],[\"2pc\",{\"1\":{\"64\":1}}],[\"2延时队列就是用来存放需要在指定时间被处理的元素的队列\",{\"1\":{\"216\":1}}],[\"2异步\",{\"1\":{\"216\":1}}],[\"2检查所利用的索引\",{\"1\":{\"216\":1}}],[\"2非叶子节点存储的是主键和页地址\",{\"1\":{\"216\":1}}],[\"2悲观锁\",{\"1\":{\"216\":1}}],[\"2排它锁\",{\"1\":{\"216\":1}}],[\"2表锁\",{\"1\":{\"216\":1}}],[\"2叶子节点之间有指针\",{\"1\":{\"216\":1}}],[\"2一个节点了可以存多个元素\",{\"1\":{\"216\":1}}],[\"2执行update语句\",{\"1\":{\"216\":1}}],[\"2先删除redis缓存数据\",{\"1\":{\"216\":1}}],[\"2先根据url域名从本地hosts文件查找是否有映射ip\",{\"1\":{\"216\":1}}],[\"2缓存击穿\",{\"1\":{\"216\":1}}],[\"2从节点发送sync命令连接主节点\",{\"1\":{\"216\":1}}],[\"2哈希表\",{\"1\":{\"216\":1}}],[\"2内存零拷贝\",{\"1\":{\"216\":1}}],[\"2高性能\",{\"1\":{\"216\":1}}],[\"2nio\",{\"1\":{\"216\":1}}],[\"2nacos\",{\"1\":{\"216\":1}}],[\"2都让用户体验到某些功能暂时不可用\",{\"1\":{\"216\":1}}],[\"2服务端接收fin后\",{\"1\":{\"216\":1}}],[\"2服务端接收到syn后\",{\"1\":{\"216\":1}}],[\"2服务降级是指\",{\"1\":{\"216\":1}}],[\"2服务限流是指在高并发请求下\",{\"1\":{\"216\":1}}],[\"2registry注册中心层\",{\"1\":{\"216\":1}}],[\"2redis\",{\"1\":{\"216\":1}}],[\"2轮询\",{\"1\":{\"216\":1}}],[\"2然后还要利用lua脚本来保证多个redis操作的原子性\",{\"1\":{\"216\":1}}],[\"2然后从注册中心进行查询服务信息\",{\"1\":{\"216\":1}}],[\"2然后调用servicebean的export方法进行服务导出\",{\"1\":{\"216\":1}}],[\"2然后leader会和其他节点进行数据同步\",{\"1\":{\"216\":1}}],[\"2然后相互交互投票\",{\"1\":{\"216\":1}}],[\"2数据同步阶段\",{\"1\":{\"216\":1}}],[\"2消息队列\",{\"1\":{\"216\":1}}],[\"2利用单机数据库的自增主键\",{\"1\":{\"216\":1}}],[\"2mybatis\",{\"1\":{\"216\":1}}],[\"2与\",{\"1\":{\"216\":1}}],[\"2java系统属性\",{\"1\":{\"216\":1}}],[\"2在创建spring容器过程中\",{\"1\":{\"216\":1}}],[\"2dispatcherservlet\",{\"1\":{\"216\":1}}],[\"2另外推荐用构造方法进行依赖注入\",{\"1\":{\"216\":1}}],[\"2首先要确保消息不多发\",{\"1\":{\"216\":1}}],[\"2首先会进行扫描\",{\"1\":{\"216\":1}}],[\"2首先对于使用了\",{\"1\":{\"216\":1}}],[\"2如果bean是有状态的\",{\"1\":{\"216\":1}}],[\"2如果此时线程池中的线程数量等于corepoolsize\",{\"1\":{\"216\":1}}],[\"2实例化\",{\"1\":{\"216\":1}}],[\"2b\",{\"1\":{\"216\":1}}],[\"2b类\",{\"1\":{\"216\":1}}],[\"2控制对象内属性的赋值\",{\"1\":{\"216\":1}}],[\"2用一些注解\",{\"1\":{\"216\":1}}],[\"2什么是反转\",{\"1\":{\"216\":1}}],[\"2extclassloader\",{\"1\":{\"216\":1}}],[\"2我们可以利用jsisualvm等工具来分析dump文件\",{\"1\":{\"216\":1}}],[\"2可以通过jstack来查看线程的运行情况\",{\"1\":{\"216\":1}}],[\"2轻量级锁\",{\"1\":{\"216\":1}}],[\"2lock\",{\"1\":{\"216\":1}}],[\"2threadlocal底层是通过threadlocalmap来实现的\",{\"1\":{\"216\":1}}],[\"2当某个线程进行put时\",{\"1\":{\"216\":1}}],[\"2每个segment相对于一个小型的hashmap\",{\"1\":{\"216\":1}}],[\"2遍历老数组中的每个位置上的链表或红黑树\",{\"1\":{\"216\":1}}],[\"2遍历老数组中的每个位置上的链表上的每个元素\",{\"1\":{\"216\":1}}],[\"2并且\",{\"1\":{\"216\":1}}],[\"2由于底层数据结构不同\",{\"1\":{\"216\":1}}],[\"2i3\",{\"1\":{\"216\":1}}],[\"2soa是一种面向服务的架构\",{\"1\":{\"216\":1}}],[\"2s\",{\"1\":{\"216\":1}}],[\"2sql\",{\"1\":{\"216\":1}}],[\"2sychronized会自动的加锁与释放锁\",{\"1\":{\"216\":1}}],[\"2stringbuffer是线程安全的\",{\"1\":{\"216\":1}}],[\"2s2\",{\"1\":{\"216\":1}}],[\"2shutdown\",{\"1\":{\"216\":2}}],[\"2方法参数通常是对象\",{\"1\":{\"216\":1}}],[\"2=2\",{\"1\":{\"216\":1}}],[\"29\",{\"0\":{\"122\":1}}],[\"28\",{\"0\":{\"121\":1}}],[\"27017\",{\"1\":{\"219\":2}}],[\"27\",{\"0\":{\"120\":1,\"197\":1}}],[\"26\",{\"0\":{\"119\":1}}],[\"25\",{\"0\":{\"118\":1},\"1\":{\"219\":1}}],[\"24\",{\"0\":{\"117\":1}}],[\"2375\",{\"1\":{\"225\":1,\"228\":1}}],[\"23\",{\"0\":{\"116\":1}}],[\"2222b\",{\"1\":{\"216\":2}}],[\"22\",{\"0\":{\"115\":1},\"1\":{\"169\":1,\"219\":1}}],[\"2296010\",{\"1\":{\"64\":1}}],[\"2181\",{\"1\":{\"219\":3}}],[\"21\",{\"0\":{\"114\":1}}],[\"2147483648到2147483647\",{\"1\":{\"79\":1}}],[\"21673805\",{\"1\":{\"78\":1}}],[\"2+1个节点申请锁\",{\"1\":{\"216\":1}}],[\"2+1\",{\"1\":{\"64\":1}}],[\"2013年发布至今\",{\"1\":{\"217\":1}}],[\"2018\",{\"0\":{\"197\":1}}],[\"2017\",{\"1\":{\"64\":1}}],[\"20\",{\"0\":{\"113\":1},\"1\":{\"77\":1,\"87\":2,\"216\":1,\"219\":1,\"230\":1}}],[\"204\",{\"1\":{\"54\":1,\"219\":10}}],[\"200只是一个默认值\",{\"1\":{\"216\":1}}],[\"200\",{\"1\":{\"54\":1}}],[\"2005\",{\"1\":{\"13\":1}}],[\"2xx\",{\"1\":{\"54\":1}}],[\"2\",{\"0\":{\"14\":1,\"20\":1,\"60\":1,\"66\":2,\"67\":2,\"68\":3,\"71\":2,\"72\":2,\"73\":2,\"74\":2,\"75\":2,\"76\":2,\"79\":2,\"80\":2,\"81\":2,\"82\":2,\"85\":2,\"88\":2,\"91\":2,\"95\":1,\"153\":1,\"162\":1,\"173\":1,\"177\":1,\"193\":1,\"207\":1,\"210\":1},\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1,\"23\":3,\"64\":31,\"68\":1,\"73\":1,\"89\":1,\"96\":1,\"216\":9,\"217\":4,\"218\":2,\"219\":7,\"231\":2}}],[\"<服务名>\",{\"1\":{\"219\":2}}],[\"<容器完整id>\",{\"1\":{\"218\":1}}],[\"<h1>this\",{\"1\":{\"218\":1}}],[\"<=\",{\"1\":{\"73\":1}}],[\"<binarysearch\",{\"1\":{\"69\":1}}],[\"<t>\",{\"1\":{\"69\":1}}],[\"<dubbo\",{\"1\":{\"64\":11}}],[\"<待补充>\",{\"1\":{\"64\":2}}],[\"<\",{\"1\":{\"1\":2,\"2\":2,\"3\":4,\"4\":4,\"64\":2,\"73\":2,\"87\":1,\"218\":1}}],[\"ico\",{\"1\":{\"219\":1}}],[\"iconfont\",{\"1\":{\"57\":1}}],[\"i4为false\",{\"1\":{\"216\":1}}],[\"i2为true\",{\"1\":{\"216\":1}}],[\"illegal\",{\"1\":{\"73\":2}}],[\"illegalargumentexception\",{\"1\":{\"73\":2}}],[\"it\",{\"1\":{\"217\":1}}],[\"it参数\",{\"1\":{\"217\":1}}],[\"iteratorbinarysearch\",{\"1\":{\"69\":1}}],[\"its\",{\"1\":{\"64\":1}}],[\"ibatis与hibernate的区别\",{\"1\":{\"64\":1}}],[\"ibm\",{\"1\":{\"8\":2,\"64\":1}}],[\"iis还是其他容器\",{\"1\":{\"64\":1}}],[\"isnan\",{\"1\":{\"73\":1}}],[\"isr应该总是包含所有的副本\",{\"1\":{\"64\":1}}],[\"isr是一组与leaders完全同步的消息副本\",{\"1\":{\"64\":1}}],[\"isr\",{\"1\":{\"64\":1}}],[\"isr集合\",{\"1\":{\"64\":1}}],[\"is\",{\"1\":{\"64\":1,\"94\":2,\"216\":1,\"218\":1}}],[\"isdirectory\",{\"1\":{\"64\":1}}],[\"isfile\",{\"1\":{\"64\":1}}],[\"isolation\",{\"1\":{\"64\":1}}],[\"image\",{\"1\":{\"217\":2,\"218\":2,\"219\":25}}],[\"images命令即可列出已下载的镜像\",{\"1\":{\"217\":1}}],[\"images\",{\"1\":{\"217\":3}}],[\"import等注解\",{\"1\":{\"216\":1}}],[\"import注解\",{\"1\":{\"216\":1}}],[\"implements\",{\"1\":{\"83\":1,\"87\":1,\"94\":1}}],[\"im\",{\"1\":{\"64\":1,\"70\":1,\"92\":1}}],[\"io流的框架体系\",{\"1\":{\"64\":1}}],[\"io流详解\",{\"1\":{\"64\":1}}],[\"io多路复用\",{\"1\":{\"64\":1}}],[\"io多路复用epoll的实现采用红黑树组织管理sockfd\",{\"1\":{\"64\":1}}],[\"ioc表示控制反转\",{\"1\":{\"216\":2}}],[\"ioc这个概念给人的感觉就是我好像会\",{\"1\":{\"216\":1}}],[\"ioc容器初始化过程学习\",{\"1\":{\"64\":1}}],[\"ioc\",{\"1\":{\"64\":1}}],[\"ioc原理解读\",{\"1\":{\"64\":2}}],[\"ioc的思想最核心的地方在于\",{\"1\":{\"64\":1}}],[\"ioc文英全称inversion\",{\"1\":{\"64\":1}}],[\"ioc是什么\",{\"1\":{\"64\":2}}],[\"io密集型\",{\"1\":{\"64\":3}}],[\"io\",{\"1\":{\"57\":1,\"64\":3}}],[\"idea加密连接服务器docker\",{\"0\":{\"220\":1}}],[\"identifier\",{\"1\":{\"34\":1}}],[\"idle\",{\"1\":{\"219\":3}}],[\"id长度较之uuid更短\",{\"1\":{\"216\":1}}],[\"idx\",{\"1\":{\"216\":6}}],[\"idwtwt\",{\"1\":{\"64\":1}}],[\"id=c10ecc5535e673b3f7fa396e57866569\",{\"1\":{\"64\":1}}],[\"id\",{\"1\":{\"31\":2,\"64\":1,\"169\":1,\"216\":1,\"217\":6,\"218\":1,\"219\":1}}],[\"iputils\",{\"1\":{\"217\":1}}],[\"ip的报文丢弃\",{\"1\":{\"64\":1}}],[\"ip的一些基本知识\",{\"1\":{\"64\":1}}],[\"ip四层模型比较\",{\"1\":{\"64\":1}}],[\"ips\",{\"1\":{\"44\":1}}],[\"ip协议详解笔记\",{\"1\":{\"64\":1}}],[\"ip协议数据传输过程中的粘包和分包问题\",{\"1\":{\"64\":1}}],[\"ip协议的\",{\"1\":{\"33\":1}}],[\"ip协议族\",{\"1\":{\"12\":1}}],[\"ip并不一定单指tcp和ip这两个具体的协议\",{\"1\":{\"12\":1}}],[\"ip\",{\"0\":{\"110\":1},\"1\":{\"7\":1,\"10\":4,\"11\":1,\"12\":1,\"17\":1,\"26\":1,\"41\":5,\"42\":3,\"43\":1,\"45\":3,\"64\":1,\"217\":3,\"223\":2,\"231\":1}}],[\"ip各层的结构与功能\",{\"0\":{\"7\":1}}],[\"include\",{\"1\":{\"219\":1}}],[\"incr\",{\"1\":{\"168\":1}}],[\"incrby\",{\"1\":{\"64\":1}}],[\"invocation\",{\"1\":{\"216\":1}}],[\"invoker\",{\"1\":{\"216\":10}}],[\"ingnr动\",{\"1\":{\"216\":1}}],[\"instead\",{\"1\":{\"231\":1}}],[\"install命令安装软件时就会默认从\",{\"1\":{\"231\":1}}],[\"install\",{\"1\":{\"217\":5,\"219\":2,\"231\":7}}],[\"instanceof\",{\"1\":{\"69\":1}}],[\"inspect\",{\"1\":{\"217\":1}}],[\"insert\",{\"1\":{\"64\":2,\"94\":1}}],[\"insertionsort\",{\"1\":{\"2\":1}}],[\"in\",{\"1\":{\"64\":1,\"216\":1,\"223\":2}}],[\"innodb中主键索引对应的b+树\",{\"1\":{\"216\":1}}],[\"innodb中的b+树的高度该如何计算\",{\"1\":{\"216\":1}}],[\"innodb通过buffer\",{\"1\":{\"216\":1}}],[\"innodb是如何实现事务的\",{\"1\":{\"216\":1}}],[\"innodb和myisam的区别\",{\"0\":{\"156\":1}}],[\"innodb引擎下mysql自身配置优化\",{\"1\":{\"64\":1}}],[\"innodb\",{\"1\":{\"64\":1}}],[\"inputstream\",{\"1\":{\"64\":5}}],[\"initialcapacity\",{\"1\":{\"73\":8}}],[\"initial\",{\"1\":{\"64\":1,\"73\":1,\"219\":1}}],[\"indexof\",{\"1\":{\"94\":1}}],[\"indexedbinarysearch\",{\"1\":{\"69\":1}}],[\"index\",{\"1\":{\"50\":1,\"68\":3,\"216\":7,\"218\":1}}],[\"integer\",{\"1\":{\"64\":1,\"86\":2}}],[\"interrupt\",{\"1\":{\"216\":1}}],[\"interface\",{\"1\":{\"69\":1}}],[\"interface=\",{\"1\":{\"64\":6}}],[\"internal\",{\"1\":{\"230\":3}}],[\"intern\",{\"1\":{\"64\":1}}],[\"intert\",{\"1\":{\"10\":1}}],[\"introduction\",{\"0\":{\"197\":1}}],[\"intro\",{\"1\":{\"64\":1}}],[\"int\",{\"0\":{\"103\":1},\"1\":{\"1\":3,\"2\":3,\"3\":4,\"4\":17,\"64\":2,\"68\":3,\"69\":1,\"73\":5,\"77\":4,\"86\":1,\"87\":5,\"94\":2,\"216\":4}}],[\"i++\",{\"1\":{\"1\":1,\"2\":1,\"3\":1}}],[\"i\",{\"1\":{\"1\":6,\"2\":3,\"3\":5,\"4\":3,\"64\":3,\"68\":5,\"216\":2,\"218\":4}}],[\"ifconfig等指令\",{\"1\":{\"217\":1}}],[\"if\",{\"1\":{\"1\":2,\"2\":1,\"3\":1,\"4\":4,\"33\":3,\"64\":4,\"69\":1,\"73\":3,\"87\":2,\"96\":4,\"231\":1}}],[\"冒泡排序\",{\"0\":{\"1\":1},\"1\":{\"64\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(et(t,v[s],n)):e==="search"?self.postMessage(tt(t,v[s],n)):self.postMessage({suggestions:et(t,v[s],n),results:tt(t,v[s],n)})};
//# sourceMappingURL=index.js.map

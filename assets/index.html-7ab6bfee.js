const e=JSON.parse('{"key":"v-56aac58a","path":"/pages/202308230723/","title":"RocketMQ高性能核心原理","lang":"zh-CN","frontmatter":{"title":"RocketMQ高性能核心原理","date":"2023-08-23T07:23:37.000Z","permalink":"/pages/202308230723/","author":{"name":"江"},"category":["消息队列","RocketMQ"],"description":"前面的部分我们都是为了快速的体验RocketMQ的搭建和使用。这一部分，我们主要分享一些RocketMQ比较有特色的设计点。这些设计点正是RocketMQ高效性能的关键所在。同时，这些关键的设计点也可以带到后续的源码阅读章节中去验证，为枯燥的源码阅读找到一些目标。 一、读队列与写队列 在RocketMQ的管理控制台创建Topic时，可以看到要单独设置读队列和写队列。通常在运行时，都需要设置读队列=写队列。 image","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/pages/202308230723/"}],["meta",{"property":"og:site_name","content":"学习笔记"}],["meta",{"property":"og:title","content":"RocketMQ高性能核心原理"}],["meta",{"property":"og:description","content":"前面的部分我们都是为了快速的体验RocketMQ的搭建和使用。这一部分，我们主要分享一些RocketMQ比较有特色的设计点。这些设计点正是RocketMQ高效性能的关键所在。同时，这些关键的设计点也可以带到后续的源码阅读章节中去验证，为枯燥的源码阅读找到一些目标。 一、读队列与写队列 在RocketMQ的管理控制台创建Topic时，可以看到要单独设置读队列和写队列。通常在运行时，都需要设置读队列=写队列。 image"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-30T15:10:48.000Z"}],["meta",{"property":"article:author","content":"江"}],["meta",{"property":"article:published_time","content":"2023-08-23T07:23:37.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-30T15:10:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ高性能核心原理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-23T07:23:37.000Z\\",\\"dateModified\\":\\"2023-08-30T15:10:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"江\\"}]}"]]},"headers":[{"level":2,"title":"4.1 零拷贝技术加速文件读写","slug":"_4-1-零拷贝技术加速文件读写","link":"#_4-1-零拷贝技术加速文件读写","children":[]},{"level":2,"title":"4.2 顺序写加速文件写入磁盘","slug":"_4-2-顺序写加速文件写入磁盘","link":"#_4-2-顺序写加速文件写入磁盘","children":[]},{"level":2,"title":"4.3 刷盘机制保证消息不丢失","slug":"_4-3-刷盘机制保证消息不丢失","link":"#_4-3-刷盘机制保证消息不丢失","children":[]},{"level":2,"title":"6.1 Producer负载均衡","slug":"_6-1-producer负载均衡","link":"#_6-1-producer负载均衡","children":[]},{"level":2,"title":"6.2 Consumer负载均衡","slug":"_6-2-consumer负载均衡","link":"#_6-2-consumer负载均衡","children":[]},{"level":2,"title":"7.1、如何让消息进行重试","slug":"_7-1、如何让消息进行重试","link":"#_7-1、如何让消息进行重试","children":[]},{"level":2,"title":"7.2、重试消息如何处理","slug":"_7-2、重试消息如何处理","link":"#_7-2、重试消息如何处理","children":[]},{"level":2,"title":"9.1、幂等的概念","slug":"_9-1、幂等的概念","link":"#_9-1、幂等的概念","children":[]},{"level":2,"title":"9.2、消息幂等的必要性","slug":"_9-2、消息幂等的必要性","link":"#_9-2、消息幂等的必要性","children":[]},{"level":2,"title":"9.3、处理方式","slug":"_9-3、处理方式","link":"#_9-3、处理方式","children":[]}],"git":{"createdTime":1693408248000,"updatedTime":1693408248000,"contributors":[{"name":"jiangqingdong","email":"thejqd@gmail.com","commits":1}]},"readingTime":{"minutes":35.9,"words":10771},"filePathRelative":"30.分布式框架/05.消息队列/02.RocketMQ/20.RocketMQ高性能核心原理.md","localizedDate":"2023年8月23日","excerpt":"<p>前面的部分我们都是为了快速的体验RocketMQ的搭建和使用。这一部分，我们主要分享一些RocketMQ比较有特色的设计点。这些设计点正是RocketMQ高效性能的关键所在。同时，这些关键的设计点也可以带到后续的源码阅读章节中去验证，为枯燥的源码阅读找到一些目标。</p>\\n<h1> 一、读队列与写队列</h1>\\n<p>在RocketMQ的管理控制台创建Topic时，可以看到要单独设置读队列和写队列。通常在运行时，都需要设置读队列=写队列。</p>\\n<figure><img src=\\"https://note.youdao.com/yws/public/resource/b1d25d692746087094a9eb2b2c3e4023/802DBDA17C2D4E4493B8B26C77BA8EA3?ynotemdtimestamp=1692746656864\\" alt=\\"image\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>image</figcaption></figure>","autoDesc":true}');export{e as data};

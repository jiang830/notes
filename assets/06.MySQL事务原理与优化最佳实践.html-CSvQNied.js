import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,a as t}from"./app-CT4bPn0M.js";const p={},e=t('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>我们的数据库一般都会并发执行多个事务，多个事务可能会并发的对相同的一批数据进行增删改查操作，可能就会导致我们说的脏写、脏读、不可重复读、幻读这些问题。</p><p>这些问题的本质都是数据库的多事务并发问题，为了解决多事务并发问题，数据库设计了<strong>事务隔离机制、锁机制、MVCC多版本并发控制隔离机制、日志机制</strong>，用一整套机制来<strong>解决多事务并发问题</strong>。接下来的，我们会深入讲解这些机制，让大家彻底理解数据库内部的执行原理。</p><h2 id="事务及其acid属性" tabindex="-1"><a class="header-anchor" href="#事务及其acid属性"><span>事务及其ACID属性</span></a></h2><p>事务是一组操作要么全部成功，要么全部失败，目的是为了保证数据最终的一致性。</p><p>事务具有以下4个属性,通常简称为事务的ACID属性。</p><ul><li>原子性(Atomicity) ：当前事务的操作要么同时成功，要么同时失败。原子性由undo log日志来实现。</li><li>一致性(Consistent) ：使用事务的最终目的，由其它3个特性以及业务代码正确逻辑来实现。</li><li>隔离性(Isolation) ：在事务并发执行时，他们内部的操作不能互相干扰。隔离性由MySQL的各种锁以及MVCC机制来实现。</li><li>持久性(Durable) ：一旦提交了事务，它对数据库的改变就应该是永久性的。持久性由redo log日志来实现。</li></ul><h2 id="并发事务处理带来的问题" tabindex="-1"><a class="header-anchor" href="#并发事务处理带来的问题"><span>并发事务处理带来的问题</span></a></h2><p>更新丢失(Lost Update)或脏写</p><p>当两个或多个事务选择同一行数据修改，有可能发生更新丢失问题，即最后的更新覆盖了由其他事务所做的更新。</p><p>脏读（Dirty Reads）</p><p>事务A读取到了事务B已经修改但尚未提交的数据</p><p>不可重读（Non-Repeatable Reads）</p><p>事务A内部的相同查询语句在不同时刻读出的结果不一致</p><p>幻读（Phantom Reads）</p><p>事务A读取到了事务B提交的新增数据</p><h2 id="事务隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔离级别"><span>事务隔离级别</span></a></h2><p>“脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数据库提供一定的事务隔离机制来解决。</p><table><thead><tr><th>隔离级别</th><th>脏读(Dirty Read)</th><th>不可重复读(NonRepeatable Read)</th><th>幻读(Phantom Read)</th></tr></thead><tbody><tr><td>读未提交(Read uncommitted)</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读已提交(Read committed)</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读(Repeatableread)</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>可串行化(Serializable)</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><p>数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔离实质上就是使事务在一定程度上“串行化”进行,这显然与“并发”是矛盾的。</p><p>同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用对“不可重复读&quot;和“幻读”并不敏感,可能更关心数据并发访问的能力。</p><p>查看当前数据库的事务隔离级别: show variables like &#39;tx_isolation&#39;;</p><p>设置事务隔离级别：set tx_isolation=&#39;REPEATABLE-READ&#39;;</p><p><strong>Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔离级别，如果Spring设置了就用已经设置的隔离级别</strong></p><h3 id="事务隔离级别案例分析" tabindex="-1"><a class="header-anchor" href="#事务隔离级别案例分析"><span>事务隔离级别案例分析</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>account<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>balance<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>account<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>balance<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&#39;lilei&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;450&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>account<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>balance<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&#39;hanmei&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;16000&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>account<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>balance<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&#39;lucy&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2400&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="读未提交" tabindex="-1"><a class="header-anchor" href="#读未提交"><span>读未提交</span></a></h4><p>（1）打开一个客户端A，并设置当前事务模式为read uncommitted（未提交读），查询表account的初始值：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">set</span> tx_isolation<span class="token operator">=</span><span class="token string">&#39;read-uncommitted&#39;</span><span class="token punctuation">;</span>              \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ <img src="https://img.jssjqd.cn/202402260312421.png" alt="image-20240226031211463"></p><p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p><p>​ <img src="https://img.jssjqd.cn/202402260312915.png" alt="image-20240226031220943"></p><p>（3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：</p><p>​ <img src="https://img.jssjqd.cn/202402260312852.png" alt="image-20240226031224958"></p><p>（4）一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是<strong>脏数据</strong>：</p><p>​ <img src="https://img.jssjqd.cn/202402260312781.png" alt="image-20240226031228897"></p><p>（5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，如果你这么想就太天真了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别</p><p><img src="https://img.jssjqd.cn/202402260312212.png" alt="image-20240226031233225"></p><h4 id="读已提交" tabindex="-1"><a class="header-anchor" href="#读已提交"><span>读已提交</span></a></h4><p>（1）打开一个客户端A，并设置当前事务模式为read committed（未提交读），查询表account的所有记录：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">set</span> tx_isolation<span class="token operator">=</span><span class="token string">&#39;read-committed&#39;</span><span class="token punctuation">;</span>              \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ <img src="https://img.jssjqd.cn/202402260312688.png" alt="image-20240226031236798"></p><p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p><p>​ <img src="https://img.jssjqd.cn/202402260312572.png" alt="image-20240226031240619"></p><p>（3）这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：</p><p>​ <img src="https://img.jssjqd.cn/202402260312798.png" alt="image-20240226031243959"></p><p>（4）客户端B的事务提交</p><p>​ <img src="https://img.jssjqd.cn/202402260312961.png" alt="image-20240226031247060"></p><p>（5）客户端A执行与上一步相同的查询，结果 与上一步不一致，即产生了不可重复读的问题</p><p>​ <img src="https://img.jssjqd.cn/202402260312944.png" alt="image-20240226031250148"></p><h4 id="可重复读" tabindex="-1"><a class="header-anchor" href="#可重复读"><span>可重复读</span></a></h4><p>这个隔离级别记住一句话就能理解：可重复读隔离级别在事务开启的时候，第一次查询是查的数据库里已提交的最新数据，这时候全数据库会有一个快照(当然数据库并不是真正的生成了一个快照，这个快照机制怎么实现的后面课程会详细讲)，在这个事务之后执行的查询操作都是查快照里的数据，别的事务不管怎么修改数据对当前这个事务的查询都没有影响，但是当前事务如果修改了某条数据，那当前事务之后查这条修改的数据就是被修改之后的值，但是查其它数据依然是从快照里查，不受影响。</p><p>（1）打开一个客户端A，并设置当前事务模式为repeatable read，查询表account的所有记录</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">set</span> tx_isolation<span class="token operator">=</span><span class="token string">&#39;repeatable-read&#39;</span><span class="token punctuation">;</span>              \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ <img src="https://img.jssjqd.cn/202402260312304.png" alt="image-20240226031255387"></p><p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account并提交</p><p>​ <img src="https://img.jssjqd.cn/202402260312720.png" alt="image-20240226031258711"></p><p>（3）在客户端A查询表account的所有记录，与步骤（1）查询结果一致，没有出现不可重复读的问题</p><p>​ <img src="https://img.jssjqd.cn/202402260313301.png" alt="image-20240226031302281"></p><p>（4）在客户端A，接着执行 <strong>update account set balance = balance - 50 where id = 1</strong>，balance没有变成400-50=350，lilei的balance值用的是步骤2中的350来算的，所以是300，数据的一致性倒是没有被破坏。可重复读的隔离级别下使用了MVCC(multi-version concurrency control)机制，select操作是<strong>快照读（历史版本）</strong>；insert、update和delete是<strong>当前读（当前版本）</strong>。</p><p>​ <img src="https://img.jssjqd.cn/202402260313755.png" alt="image-20240226031305735"></p><p>（5）重新打开客户端B，插入一条新数据后提交</p><p>​ <img src="https://img.jssjqd.cn/202402260313261.png" alt="image-20240226031309356"></p><p>（6）在客户端A查询表account的所有记录，没有查出新增数据，所以没有出现幻读</p><p>​ <img src="https://img.jssjqd.cn/202402260313833.png" alt="image-20240226031312694"></p><p>（7)验证幻读</p><p>在客户端A执行update account set balance=888 where id = 4；能更新成功，再次查询能查到客户端B新增的数据</p><p>​ <img src="https://img.jssjqd.cn/202402260313649.png" alt="image-20240226031318635"></p><h4 id="串行化" tabindex="-1"><a class="header-anchor" href="#串行化"><span>串行化</span></a></h4><p>（1）打开一个客户端A，并设置当前事务模式为serializable，查询表account的初始值：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">set</span> tx_isolation<span class="token operator">=</span><span class="token string">&#39;serializable&#39;</span><span class="token punctuation">;</span>              \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ <img src="https://img.jssjqd.cn/202402260313337.png" alt="image-20240226031322512"></p><p>（2）打开一个客户端B，并设置当前事务模式为serializable，更新相同的id为1的记录会被阻塞等待，更新id为2的记录可以成功，说明在串行模式下innodb的查询也会被加上行锁，如果查询的记录不存在会给这条不存在的记录加上锁(这种是间隙锁，后面会详细讲)。</p><p>如果客户端A执行的是一个范围查询，那么该<strong>范围内的所有行包括每行记录所在的间隙区间范围都会被加锁</strong>。此时如果客户端B在该范围内插入数据都会被阻塞，所以就避免了幻读。</p><p>这种隔离级别并发性极低，开发中很少会用。</p><p>​ <img src="https://img.jssjqd.cn/202402260313068.png" alt="image-20240226031326301"></p><p><strong>事务问题定位</strong></p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">#查询执行时间超过1秒的事务，详细的定位问题方法后面讲完锁课程后会一起讲解</span>\n<span class="token keyword">SELECT</span>\n	<span class="token operator">*</span> \n<span class="token keyword">FROM</span>\n	information_schema<span class="token punctuation">.</span>innodb_trx \n<span class="token keyword">WHERE</span>\n	TIME_TO_SEC<span class="token punctuation">(</span> timediff<span class="token punctuation">(</span> <span class="token function">now</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> trx_started <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>\n \n <span class="token comment">#强制结束事务</span>\n <span class="token keyword">kill</span> 事务对应的线程id<span class="token punctuation">(</span>就是上面语句查出结果里的trx_mysql_thread_id字段的值<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>大事务的影响</strong></p><ul><li>并发情况下，数据库连接池容易被撑爆</li><li>锁定太多的数据，造成大量的阻塞和锁超时</li><li>执行时间长，容易造成主从延迟</li><li>回滚所需要的时间比较长</li><li>undo log膨胀</li><li>容易导致死锁</li></ul><p><strong>事务优化</strong></p><ul><li>将查询等数据准备操作放到事务外</li><li>事务中避免远程调用，远程调用要设置超时，防止事务等待时间太久</li><li>事务中避免一次性处理太多数据，可以拆分成多个事务分次处理</li><li>更新等涉及加锁的操作尽可能放在事务靠后的位置</li><li>能异步处理的尽量异步处理</li><li>应用侧(业务代码)保证数据一致性，非事务执行</li></ul>',82),i=[e];function c(l,o){return s(),a("div",null,i)}const u=n(p,[["render",c],["__file","06.MySQL事务原理与优化最佳实践.html.vue"]]),k=JSON.parse('{"path":"/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/00.MySQL/06.MySQL%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html","title":"","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"事务及其ACID属性","slug":"事务及其acid属性","link":"#事务及其acid属性","children":[]},{"level":2,"title":"并发事务处理带来的问题","slug":"并发事务处理带来的问题","link":"#并发事务处理带来的问题","children":[]},{"level":2,"title":"事务隔离级别","slug":"事务隔离级别","link":"#事务隔离级别","children":[{"level":3,"title":"事务隔离级别案例分析","slug":"事务隔离级别案例分析","link":"#事务隔离级别案例分析","children":[]}]}],"git":{"createdTime":1709200080000,"updatedTime":1709200080000,"contributors":[{"name":"jiangqingdong","email":"thejqd@gmail.com","commits":1}]},"readingTime":{"minutes":8.14,"words":2442},"filePathRelative":"性能调优/00.MySQL/06.MySQL事务原理与优化最佳实践.md","localizedDate":"2024年2月29日","excerpt":"<h2>概述</h2>\\n<p>我们的数据库一般都会并发执行多个事务，多个事务可能会并发的对相同的一批数据进行增删改查操作，可能就会导致我们说的脏写、脏读、不可重复读、幻读这些问题。</p>\\n<p>这些问题的本质都是数据库的多事务并发问题，为了解决多事务并发问题，数据库设计了<strong>事务隔离机制、锁机制、MVCC多版本并发控制隔离机制、日志机制</strong>，用一整套机制来<strong>解决多事务并发问题</strong>。接下来的，我们会深入讲解这些机制，让大家彻底理解数据库内部的执行原理。</p>\\n<h2>事务及其ACID属性</h2>\\n<p>事务是一组操作要么全部成功，要么全部失败，目的是为了保证数据最终的一致性。</p>"}');export{u as comp,k as data};

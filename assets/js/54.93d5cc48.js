(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{368:function(a,s,e){"use strict";e.r(s);var t=e(7),l=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("ol",[s("li",[s("p",[a._v("说一下你在项目中的redis的应用场景？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("1，5大value类型：根据我的redis课有场景的介绍\n2，基本上就是缓存~！\n3，为的是服务无状态，延申思考，看你的项目有哪些数据结构或对象，在单机里需要单机锁，在多机需要分布式锁，抽出来放入redis中；\n4，无锁化\n")])])])]),a._v(" "),s("li",[s("p",[a._v("redis是单线程还是多线程？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("1，无论什么版本，工作线程就是一个\n2，6.x高版本出现了IO多线程\n3，使用上来说，没有变化\n------\n3，[去学一下系统IO课]，你要真正的理解面向IO模型编程的时候，有内核的事，从内核把数据搬运到程序里这是第一步，然后，搬运回来的数据做的计算式第二步，netty\n4，单线程，满足redis的串行原子，只不过IO多线程后，把输入/输出放到更多的线程里去并行，好处如下：1，执行时间缩短，更快；2，更好的压榨系统及硬件的资源(网卡能够高效的使用)；\n*，客户端被读取的顺序不能被保障\n那个顺序时可以被保障的：在一个连接里，socket里\n")])])])]),a._v(" "),s("li",[s("p",[a._v("redis存在线程安全的问题吗？为什么？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("重复2中的单线程串行\nredis可以保障内部串行\n外界使用的时候要保障，业务上要自行保障顺序~！\n")])])])]),a._v(" "),s("li",[s("p",[a._v("遇到过缓存穿透吗？详细描述一下。")])]),a._v(" "),s("li",[s("p",[a._v("遇到过缓存击穿吗？详细描述一下。")])]),a._v(" "),s("li",[s("p",[a._v("如何避免缓存雪崩？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("以上问题，核心就是避免DB无效/重复请求，结合图去理解\n涉及一些架构思想上的提升\n")])])])]),a._v(" "),s("li",[s("p",[a._v("Redis是怎么删除过期key的？")])]),a._v(" "),s("li",[s("p",[a._v("缓存如何回收的？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("1，后台在轮询，分段分批的删除哪些过期的key\n2，请求的时候判断时候已经过期了\n尽量的把内存无用空间回收回来~！\n")])])])]),a._v(" "),s("li",[s("p",[a._v("缓存是如何淘汰的")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("0，内存空间不足的情况下：\n1，淘汰机制里有不允许淘汰\n2，lru/lfu/random/TTL\n3，全空间\n4，设置过过期的key的集合中\n")])])])]),a._v(" "),s("li",[s("p",[a._v("如何进行缓存预热？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("1，提前把数据塞入redis，(你知道那些是热数据吗？肯定不知道，会造成上线很多数据没有缓存命中)\n2，开发逻辑上也要规避差集(你没缓存的)，会造成击穿，穿透，雪崩，实施456中的锁方案\n3，一劳永逸，未来也不怕了\n*，结合4，5，6点去看，看图理解\n")])])])]),a._v(" "),s("li",[s("p",[a._v("数据库与缓存不一致如何解决？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("1，恶心点的，我们可以使用分布式事务来解决，（意义不大），顶多读多，写稀有情况下\n结合图去思考\n1，redis是缓存，更倾向于稍微的有时差\n2，还是减少DB的操作\n3，真的要落地，咱就canal吧\n")])])])]),a._v(" "),s("li",[s("p",[a._v("简述一下主从不一致的问题？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("1，redis的确默认是弱一致性，异步的同步\n2，锁不能用主从(单实例/分片集群/redlock)==>redisson\n3，在配置中提供了必须有多少个Client连接能同步，你可以配置同步因子，趋向于强制一性\n4，wait 2 0  小心\n5，34点就有点违背redis的初衷了\n")])])])]),a._v(" "),s("li",[s("p",[a._v("描述一下redis持久化原理？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("当前线程阻塞服务 不聊\n异步后台进程完成持久\nfork  +  cow\n")])])])]),a._v(" "),s("li",[s("p",[a._v("Redis有哪些持久化方式？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("1，RDB，AOF；主从同步也算持久化；\n2，高版本：开启AOF，AOF是可以通过执行日志得到全部内存数据的方式，但是追求性能：\n2.1，体积变大，重复无效指令  重写，后台用线程把内存的kv生成指令写个新的aof\n2.2，4.x 新增更有性能模式：把重写方式换成直接RDB放到aof文件的头部，比2.1的方法快了，再追加日志\n")])])])]),a._v(" "),s("li",[s("p",[a._v("Redis也打不住了，万级流量会打到DB上，该怎么处理？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("见456\n")])])])]),a._v(" "),s("li",[s("p",[a._v("redis中的事务三条指令式什么，第三条指令到达后执行失败了，怎么处理")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("见图\n")])])])]),a._v(" "),s("li",[s("p",[a._v("redis实现分布式锁的指令")])]),a._v(" "),s("li",[s("p",[a._v("为什么使用setnx？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("1，好东西，原子（不存在的情况下完成创建）\n2，如果要做分布式锁，就要用set k v nx ex  (不存在，过期时间，避免死锁)\n")])])])]),a._v(" "),s("li",[s("p",[a._v("分布式锁实现，理论：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\n")])])])])])])}),[],!1,null,null,null);s.default=l.exports}}]);
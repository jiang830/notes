(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{377:function(s,e,t){"use strict";t.r(e);var n=t(4),r=Object(n.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("p",[e("strong",[s._v("Redis的单线程和高性能")])]),s._v(" "),e("hr"),s._v(" "),e("p",[e("strong",[s._v("Redis是单线程吗？")])]),s._v(" "),e("p",[s._v("Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。")]),s._v(" "),e("p",[e("strong",[s._v("Redis 单线程为什么还能这么快？")])]),s._v(" "),e("p",[s._v("因为它所有的数据都在"),e("strong",[s._v("内存")]),s._v("中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性能损耗问题。正因为 Redis 是单线程，所以要小心使用 Redis 指令，对于那些耗时的指令(比如keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。")]),s._v(" "),e("p",[e("strong",[s._v("Redis 单线程如何处理那么多的并发客户端连接？")])]),s._v(" "),e("p",[s._v("Redis的"),e("strong",[s._v("IO多路复用")]),s._v("：redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。")]),s._v(" "),e("p",[s._v("​    "),e("img",{attrs:{src:"https://img.jssjqd.cn/20221013233622.png",alt:""}})]),s._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 查看redis支持的最大连接数，在redis.conf文件中可修改，# maxclients 10000")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),e("span",{pre:!0,attrs:{class:"token operator"}},[e("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v(" CONFIG GET maxclients\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v('##1) "maxclients"')]),s._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v('##2) "10000"       ')]),s._v("\n")])])]),e("p",[e("strong",[s._v("其他高级命令")])]),s._v(" "),e("p",[e("strong",[s._v("keys：全量遍历键")]),s._v("，用来列出所有满足特定正则字符串规则的key，当redis数据量比较大时，性能比较差，要避免使用")]),s._v(" "),e("p",[s._v("​    "),e("img",{attrs:{src:"https://img.jssjqd.cn/20221013233633.png",alt:""}})]),s._v(" "),e("p",[e("strong",[s._v("scan：渐进式遍历键")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("SCAN cursor [MATCH pattern] [COUNT count] \n")])])]),e("p",[s._v("scan 参数提供了三个参数，第一个是 cursor 整数值(hash桶的索引值)，第二个是 key 的正则模式，第三个是一次遍历的key的数量(参考值，底层遍历的数量不一定)，并不是符合条件的结果数量。第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。一直遍历到返回的 cursor 值为 0 时结束。")]),s._v(" "),e("p",[s._v("注意：但是scan并非完美无瑕， 如果在scan的过程中如果有键的变化（增加、 删除、 修改） ，那么遍历效果可能会碰到如下问题： 新增的键可能没有遍历到， 遍历出了重复的键等情况， 也就是说scan并不能保证完整的遍历出来所有的键， 这些是我们在开发时需要考虑的。")]),s._v(" "),e("p",[s._v("​    "),e("img",{attrs:{src:"https://img.jssjqd.cn/20221013233640.png",alt:""}})]),s._v(" "),e("p",[s._v("​    "),e("img",{attrs:{src:"https://img.jssjqd.cn/20221013233646.png",alt:""}})]),s._v(" "),e("p",[e("strong",[s._v("Info：查看redis服务运行信息，分为 9 大块，每个块都有非常多的参数，这 9 个块分别是:")])]),s._v(" "),e("p",[s._v("Server 服务器运行的环境参数")]),s._v(" "),e("p",[s._v("Clients 客户端相关信息")]),s._v(" "),e("p",[s._v("Memory 服务器运行内存统计数据")]),s._v(" "),e("p",[s._v("Persistence 持久化信息")]),s._v(" "),e("p",[s._v("Stats 通用统计数据")]),s._v(" "),e("p",[s._v("Replication 主从复制相关信息")]),s._v(" "),e("p",[s._v("CPU CPU 使用情况")]),s._v(" "),e("p",[s._v("Cluster 集群信息")]),s._v(" "),e("p",[s._v("KeySpace 键值对统计数量信息")]),s._v(" "),e("p",[s._v("​    "),e("img",{attrs:{src:"https://img.jssjqd.cn/20221013233654.png",alt:""}})]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("connected_clients:2                  # 正在连接的客户端数量\n\ninstantaneous_ops_per_sec:789        # 每秒执行多少次指令\n\nused_memory:929864                   # Redis分配的内存总量(byte)，包含redis进程内部的开销和数据占用的内存\nused_memory_human:908.07K            # Redis分配的内存总量(Kb，human会展示出单位)\nused_memory_rss_human:2.28M          # 向操作系统申请的内存大小(Mb)（这个值一般是大于used_memory的，因为Redis的内存分配策略会产生内存碎片）\nused_memory_peak:929864              # redis的内存消耗峰值(byte)\nused_memory_peak_human:908.07K       # redis的内存消耗峰值(KB)\n\nmaxmemory:0                         # 配置中设置的最大可使用内存值(byte),默认0,不限制，一般配置为机器物理内存的百分之七八十，需要留一部分给操作系统\nmaxmemory_human:0B                  # 配置中设置的最大可使用内存值\nmaxmemory_policy:noeviction         # 当达到maxmemory时的淘汰策略\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);
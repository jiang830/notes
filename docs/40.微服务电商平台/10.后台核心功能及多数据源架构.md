---
title: 后台核心功能及多数据源架构
date: 2023-05-04 07:36:32
permalink: /pages/f0b148/
categories: 
  - 微服务电商平台
tags: 
  - null
author: 
  name: 江
---
电商管理后台跟其他管理系统一样，本质上是一个纯粹的CRUD管理系统，没有什么技术难度。这一类系统通常都不是项目的核心模块，但是却是串联核心业务必不可少的辅助模块。对于后台管理系统，我们今天还是关注他的技术路线，至于业务功能，大家可以随着以后各个业务线的具体设计过程再继续深入。

重点关注两个问题：

- 通过后台项目快速理解电商数据全貌。先整体梳理一下电商项目的后台表结构，快速梳理电商管理系统的后台数据管理功能。

- 如何给普通的CRUD管理系统赋能。电商后台功能虽然复杂，但是其实后端技术层面的难度并不大，相信大家就算自己实现也没有什么难度。但是在今天课程中，会带大家打开技术想象力，给这个简单的系统增加不一样的设计。带你接触一下什么是互联网思维。


## 电商后台项目需要访问的数据源说明	

整个电商管理后台本质上是一个纯粹的CRUD管理系统，所以，整个电商项目的数据库设计情况：

| 库名              | 表前缀    | 说明               |
| ----------------- | --------- | ------------------ |
| tl_mall_goods     | pms_      | 商品相关表         |
| tl_mall_normal    | cms_      | 其他辅助功能相关表 |
| tl_mall_promotion | sms_      | 促销相关表         |
| tl_mall_user      | ums_      | 用户管理相关表     |
| tl_mall_cart      | oms_cart_ | 购物车相关表       |
| tl_mall_order     | oms_      | 订单相关表         |

这些不同库中的很多基础数据，除了购物车模块外，都需要由电商管理后台进行统一管理。所以，对于电商管理系统，会采用多数据源管理的方式，尽量快速的完成基础数据维护。其中，订单库由于进行了分库分表，管理比较复杂，所以电商管理后台不会直接访问订单相关的表，而是通过微服务的方式调用订单模块的相关功能来间接管理订单。

## 电商后台使用MyBatis-plus快速访问多个数据源	

电商后台项目使用的MyBatis\-plus框架访问数据库。对于MyBatis和MyBatis\-plus框架，这里就不多做介绍了。而我们这个电商后台管理项目，与常见的一些普通的管理系统的最大区别，在于这个电商项目管理数据的方式更为直接粗暴，直接跨多个数据库管理的后台数据。这里分享三种常用的多数据源管理方案：

> 示例参见：springboot\_dynamicdatasource

### 使用Spring提供的AbstractRoutingDataSource	

这种方式的核心是使用Spring提供的AbstractRoutingDataSource抽象类，注入多个数据源。

```java
@Component
@Primary   // 将该Bean设置为主要注入Bean
public class DynamicDataSource extends AbstractRoutingDataSource {
    // 当前使用的数据源标识
    public static ThreadLocal<String> name = new ThreadLocal<>();
    // 写
    @Autowired
    DataSource dataSource1;
    // 读
    @Autowired
    DataSource dataSource2;

    // 返回当前数据源标识
    @Override
    protected Object determineCurrentLookupKey() {
        return name.get();

    }

    @Override
    public void afterPropertiesSet() {

        // 为targetDataSources初始化所有数据源
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put("W", dataSource1);
        targetDataSources.put("R", dataSource2);

        super.setTargetDataSources(targetDataSources);

        // 为defaultTargetDataSource 设置默认的数据源
        super.setDefaultTargetDataSource(dataSource1);

        super.afterPropertiesSet();
    }
}
```

将自己实现的DynamicDataSource注册成为默认的DataSource实例后，只需要在每次使用DataSource时，提前改变一下其中的name标识，就可以快速切换数据源。

```java
@Component
@Aspect
public class DynamicDataSourceAspect implements Ordered {

    // 前置
    @Before("within(com.tuling.dynamic.datasource.service.impl.*) && @annotation(wr)")
    public void before(JoinPoint point, WR wr){
        String name = wr.value();
        DynamicDataSource.name.set(name);

        System.out.println(name);
    }

    @Override
    public int getOrder() {
        return 0;
    }

    // 环绕通知
}
```

### 使用MyBatis注册多个SqlSessionFactory	

如果使用MyBatis框架，要注册多个数据源的话，就需要将MyBatis底层的DataSource、SqlSessionFactory、DataSourceTransactionManager这些核心对象一并进行手动注册。例如：

```java
@Configuration
// 继承mybatis:
// 1. 指定扫描的mapper接口包（主库）
// 2. 指定使用sqlSessionFactory是哪个（主库）
@MapperScan(basePackages = "com.tuling.datasource.dynamic.mybatis.mapper.r",
        sqlSessionFactoryRef="rSqlSessionFactory")
public class RMyBatisConfig {
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.datasource2")
    public DataSource dataSource2() {
        // 底层会自动拿到spring.datasource中的配置， 创建一个DruidDataSource
        return DruidDataSourceBuilder.create().build();
    }

    @Bean
    @Primary
    public SqlSessionFactory rSqlSessionFactory()
            throws Exception {
        final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        // 指定主库
        sessionFactory.setDataSource(dataSource2());
        // 指定主库对应的mapper.xml文件
        /*sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver()
                .getResources("classpath:mapper/r/*.xml"));*/
        return sessionFactory.getObject();
    }



    @Bean
    public DataSourceTransactionManager rTransactionManager(){
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource2());
        return dataSourceTransactionManager;
    }

    @Bean
    public TransactionTemplate rTransactionTemplate(){
        return new TransactionTemplate(rTransactionManager());
    }
}
```

这样就完成了读库的注册。而读库与写库之间，就可以通过指定不同的Mapper和XML文件的地址来进行区分。

### 使用dynamic-datasource框架	

dynamic\-datasource是MyBaits\-plus作者设计的一个多数据源开源方案。使用这个框架需要引入对应的pom依赖

```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>dynamic-datasource-spring-boot-starter</artifactId>
    <version>3.5.0</version>
</dependency>
```

这样就可以在SpringBoot的配置文件中直接配置多个数据源。

```yaml
spring:
  datasource:
    dynamic:
      #设置默认的数据源或者数据源组,默认值即为master
      primary: master
      #严格匹配数据源,默认false. true未匹配到指定数据源时抛异常,false使用默认数据源
      strict: false
      datasource:
        master:
          url: jdbc:mysql://127.0.0.1:3306/datasource1?serverTimezone=UTC&useUnicode=true&characterEncoding=UTF8&useSSL=false
          username: root
          password: root
          initial-size: 1
          min-idle: 1
          max-active: 20
          test-on-borrow: true
          driver-class-name: com.mysql.cj.jdbc.Driver
        slave_1:
          url: jdbc:mysql://127.0.0.1:3306/datasource2?serverTimezone=UTC&useUnicode=true&characterEncoding=UTF8&useSSL=false
          username: root
          password: root
          initial-size: 1
          min-idle: 1
          max-active: 20
          test-on-borrow: true
          driver-class-name: com.mysql.cj.jdbc.Driver
```

这样就配置完成了master和slave\_1两个数据库。

接下来在使用时，只要在对应的方法或者类上添加@DS注解即可。例如

```java
@Service
public class FriendImplService implements FriendService {

    @Autowired
    FriendMapper friendMapper;


    @Override
    @DS("slave_1")  // 从库， 如果按照下划线命名方式配置多个  ， 可以指定前缀即可（组名）
    public List<Friend> list() {
        return friendMapper.list();
    }

    @Override
    @DS("master")
    public void save(Friend friend) {
        friendMapper.save(friend);
    }


    @DS("master")
    @DSTransactional
    public void saveAll(){
        // 执行多数据源的操作
    }

}
```

当前电商管理后台采用了第三种方式来进行多数据源的管理。

oms订单数据除外。因为订单相关数据已经完成了分库分表，不能直接查。


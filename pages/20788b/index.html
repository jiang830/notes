<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>适配器模式 | 学习笔记</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="个人技术博客,技术文档,学习,面试,markdown">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.b0792086.css" as="style"><link rel="preload" href="/assets/js/app.73613012.js" as="script"><link rel="preload" href="/assets/js/2.1211d3e1.js" as="script"><link rel="preload" href="/assets/js/16.7b69e07f.js" as="script"><link rel="prefetch" href="/assets/js/10.a044793b.js"><link rel="prefetch" href="/assets/js/100.5696225b.js"><link rel="prefetch" href="/assets/js/101.a42b3f5a.js"><link rel="prefetch" href="/assets/js/102.1e45d274.js"><link rel="prefetch" href="/assets/js/103.96db28ac.js"><link rel="prefetch" href="/assets/js/104.ff504f26.js"><link rel="prefetch" href="/assets/js/105.fd498331.js"><link rel="prefetch" href="/assets/js/106.a2a6ca7c.js"><link rel="prefetch" href="/assets/js/11.5e7d0c95.js"><link rel="prefetch" href="/assets/js/12.e841c0c3.js"><link rel="prefetch" href="/assets/js/13.41a2fb93.js"><link rel="prefetch" href="/assets/js/14.e2a3317c.js"><link rel="prefetch" href="/assets/js/15.a81a6ef1.js"><link rel="prefetch" href="/assets/js/17.777b188a.js"><link rel="prefetch" href="/assets/js/18.c81cf408.js"><link rel="prefetch" href="/assets/js/19.a59301e0.js"><link rel="prefetch" href="/assets/js/20.18827160.js"><link rel="prefetch" href="/assets/js/21.8d5d511f.js"><link rel="prefetch" href="/assets/js/22.a8ac93a6.js"><link rel="prefetch" href="/assets/js/23.1bbe4807.js"><link rel="prefetch" href="/assets/js/24.00525e76.js"><link rel="prefetch" href="/assets/js/25.3c90e0a0.js"><link rel="prefetch" href="/assets/js/26.c93f745b.js"><link rel="prefetch" href="/assets/js/27.01181006.js"><link rel="prefetch" href="/assets/js/28.93af4585.js"><link rel="prefetch" href="/assets/js/29.a0806690.js"><link rel="prefetch" href="/assets/js/3.70a493ce.js"><link rel="prefetch" href="/assets/js/30.3beac9a7.js"><link rel="prefetch" href="/assets/js/31.3ee788ac.js"><link rel="prefetch" href="/assets/js/32.6522140e.js"><link rel="prefetch" href="/assets/js/33.24b1949c.js"><link rel="prefetch" href="/assets/js/34.90e39367.js"><link rel="prefetch" href="/assets/js/35.a67486b8.js"><link rel="prefetch" href="/assets/js/36.d9ffefc3.js"><link rel="prefetch" href="/assets/js/37.e3a99db4.js"><link rel="prefetch" href="/assets/js/38.8e250355.js"><link rel="prefetch" href="/assets/js/39.fc7bdfc1.js"><link rel="prefetch" href="/assets/js/4.9805163b.js"><link rel="prefetch" href="/assets/js/40.454bd56a.js"><link rel="prefetch" href="/assets/js/41.a235b641.js"><link rel="prefetch" href="/assets/js/42.af91ee0f.js"><link rel="prefetch" href="/assets/js/43.ee9374e7.js"><link rel="prefetch" href="/assets/js/44.36c8feb3.js"><link rel="prefetch" href="/assets/js/45.d8301c73.js"><link rel="prefetch" href="/assets/js/46.9a5a32af.js"><link rel="prefetch" href="/assets/js/47.d58b6a64.js"><link rel="prefetch" href="/assets/js/48.f02903e0.js"><link rel="prefetch" href="/assets/js/49.19767842.js"><link rel="prefetch" href="/assets/js/5.c3d6e4f2.js"><link rel="prefetch" href="/assets/js/50.48750e81.js"><link rel="prefetch" href="/assets/js/51.c4254bbf.js"><link rel="prefetch" href="/assets/js/52.b343e884.js"><link rel="prefetch" href="/assets/js/53.98458ade.js"><link rel="prefetch" href="/assets/js/54.fde5639b.js"><link rel="prefetch" href="/assets/js/55.1d6eee4b.js"><link rel="prefetch" href="/assets/js/56.b00d9d45.js"><link rel="prefetch" href="/assets/js/57.eaec60f9.js"><link rel="prefetch" href="/assets/js/58.4b703868.js"><link rel="prefetch" href="/assets/js/59.26a30b6e.js"><link rel="prefetch" href="/assets/js/6.c77dab88.js"><link rel="prefetch" href="/assets/js/60.eb33df05.js"><link rel="prefetch" href="/assets/js/61.d173fa46.js"><link rel="prefetch" href="/assets/js/62.429026f8.js"><link rel="prefetch" href="/assets/js/63.b58a3d49.js"><link rel="prefetch" href="/assets/js/64.851d5d76.js"><link rel="prefetch" href="/assets/js/65.674d6d9d.js"><link rel="prefetch" href="/assets/js/66.ececc579.js"><link rel="prefetch" href="/assets/js/67.b733240a.js"><link rel="prefetch" href="/assets/js/68.6e4191d3.js"><link rel="prefetch" href="/assets/js/69.699a59ea.js"><link rel="prefetch" href="/assets/js/7.76f628a5.js"><link rel="prefetch" href="/assets/js/70.4f4dcf9b.js"><link rel="prefetch" href="/assets/js/71.ed9703c6.js"><link rel="prefetch" href="/assets/js/72.b6d86aab.js"><link rel="prefetch" href="/assets/js/73.d835d9fc.js"><link rel="prefetch" href="/assets/js/74.ee7c0011.js"><link rel="prefetch" href="/assets/js/75.4db81ffe.js"><link rel="prefetch" href="/assets/js/76.0bfb8bde.js"><link rel="prefetch" href="/assets/js/77.4fb5960f.js"><link rel="prefetch" href="/assets/js/78.20e475a5.js"><link rel="prefetch" href="/assets/js/79.1fda7459.js"><link rel="prefetch" href="/assets/js/8.d2e1201f.js"><link rel="prefetch" href="/assets/js/80.b3da8d44.js"><link rel="prefetch" href="/assets/js/81.d57d0933.js"><link rel="prefetch" href="/assets/js/82.66610608.js"><link rel="prefetch" href="/assets/js/83.96744a0a.js"><link rel="prefetch" href="/assets/js/84.b9a8b20b.js"><link rel="prefetch" href="/assets/js/85.e6836d72.js"><link rel="prefetch" href="/assets/js/86.6ee49a02.js"><link rel="prefetch" href="/assets/js/87.b4c2ee51.js"><link rel="prefetch" href="/assets/js/88.a3470f95.js"><link rel="prefetch" href="/assets/js/89.dbea7400.js"><link rel="prefetch" href="/assets/js/9.2821f128.js"><link rel="prefetch" href="/assets/js/90.880b855c.js"><link rel="prefetch" href="/assets/js/91.34abb20a.js"><link rel="prefetch" href="/assets/js/92.94004492.js"><link rel="prefetch" href="/assets/js/93.e6616392.js"><link rel="prefetch" href="/assets/js/94.dd4b7e1f.js"><link rel="prefetch" href="/assets/js/95.13239188.js"><link rel="prefetch" href="/assets/js/96.5ce4eca8.js"><link rel="prefetch" href="/assets/js/97.3c1bd63b.js"><link rel="prefetch" href="/assets/js/98.13343bd8.js"><link rel="prefetch" href="/assets/js/99.9ce49f9c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b0792086.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open no-sidebar have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="学习笔记" class="logo"> <span class="site-name can-hide">学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://img.jssjqd.cn/202303140455599.jpg"> <div class="blogger-info"><h3>江</h3> <span></span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <!----> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/categories/?category=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" title="分类" data-v-06225672>设计模式</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="javascript:;" data-v-06225672>江</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2021-12-27</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">适配器模式<!----></h1>  <div class="theme-vdoing-content content__default"><h3 id="适配器模式"><a href="#适配器模式" class="header-anchor">#</a> 适配器模式</h3> <p><strong>适配器模式 (Adapter Pattern)</strong>：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器 (Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p> <p>在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。</p> <p>根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在<strong>对象适配器模式</strong>中，适配器与适配者之间是<strong>关联</strong>关系；在<strong>类适配器模式</strong>中，适配器与适配者之间是<strong>继承</strong>（或实现）关系。</p> <h4 id="角色"><a href="#角色" class="header-anchor">#</a> 角色</h4> <p><strong>Target（目标抽象类）</strong>：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</p> <p><strong>Adapter（适配器类）</strong>：适配器可以调用另一个接口，作为一个转换器，对 Adaptee 和 Target 进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承 Target 并关联一个 Adaptee 对象使二者产生联系。</p> <p><strong>Adaptee（适配者类）</strong>：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</p> <blockquote><p>缺省适配器模式 (Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。缺省适配器模式是适配器模式的一种变体，其应用也较为广泛。在 JDK 类库的事件处理包 java.awt.event 中广泛使用了缺省适配器模式，如 WindowAdapter、KeyAdapter、MouseAdapter 等。</p></blockquote> <h3 id="示例"><a href="#示例" class="header-anchor">#</a> 示例</h3> <h4 id="类适配器"><a href="#类适配器" class="header-anchor">#</a> 类适配器</h4> <p>首先有一个已存在的将被适配的类</p> <div class="language- extra-class"><pre class="language-text"><code>public class Adaptee {
    public void adapteeRequest() {
        System.out.println(&quot;被适配者的方法&quot;);
    }
}
</code></pre></div><p>定义一个目标接口</p> <div class="language- extra-class"><pre class="language-text"><code>public interface Target {
    void request();
}
</code></pre></div><p>怎么才可以在目标接口中的 <code>request()</code> 调用 <code>Adaptee</code> 的 <code>adapteeRequest()</code> 方法呢？</p> <p>如果直接实现 <code>Target</code> 是不行的</p> <div class="language- extra-class"><pre class="language-text"><code>public class ConcreteTarget implements Target {
    @Override
    public void request() {
        System.out.println(&quot;concreteTarget目标方法&quot;);
    }
}
</code></pre></div><p>如果通过一个适配器类，实现 <code>Target</code> 接口，同时继承了 <code>Adaptee</code> 类，然后在实现的 <code>request()</code> 方法中调用父类的 <code>adapteeRequest()</code> 即可实现</p> <div class="language- extra-class"><pre class="language-text"><code>public class Adapter extends Adaptee implements Target{
    @Override
    public void request() {
        //...一些操作...
        super.adapteeRequest();
        //...一些操作...
    }
}
</code></pre></div><p>我们来测试一下</p> <div class="language- extra-class"><pre class="language-text"><code>public class Test {
    public static void main(String[] args) {
        Target target = new ConcreteTarget();
        target.request();

        Target adapterTarget = new Adapter();
        adapterTarget.request();
    }
}
</code></pre></div><p>输出</p> <div class="language- extra-class"><pre class="language-text"><code>concreteTarget目标方法
被适配者的方法
</code></pre></div><p><img src="http://img.jssjqd.cn/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy9QYWNrYWdlJTIwY2xhc3NhZGFwdGVyLnBuZw" alt=""></p> <p>这样我们即可在新接口 <code>Target</code> 中适配旧的接口或类</p> <h4 id="对象适配器"><a href="#对象适配器" class="header-anchor">#</a> 对象适配器</h4> <p>对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成，这里稍微修改一下 <code>Adapter</code> 类即可将转变为对象适配器</p> <div class="language- extra-class"><pre class="language-text"><code>public class Adapter implements Target{
    // 适配者是对象适配器的一个属性
    private Adaptee adaptee = new Adaptee();

    @Override
    public void request() {
        //...
        adaptee.adapteeRequest();
        //...
    }
}
</code></pre></div><p><img src="http://img.jssjqd.cn/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOVBhY2thZ2Vfb2JqZWN0YWRhcHRlci5wbmc" alt=""></p> <p>注意这里的 <code>Adapter</code> 是将 <code>Adaptee</code> 作为一个成员属性，而不是继承它</p> <h4 id="电压适配器"><a href="#电压适配器" class="header-anchor">#</a> 电压适配器</h4> <p>再来一个好理解的例子，我们国家的民用电都是 220V，日本是 110V，而我们的手机充电一般需要 5V，这时候要充电，就需要一个电压适配器，将 220V 或者 100V 的输入电压变换为 5V 输出</p> <p>定义输出交流电接口，输出 220V 交流电类和输出 110V 交流电类</p> <div class="language- extra-class"><pre class="language-text"><code>int outputAC();
}

public class AC110 implements AC {
    public final int output = 110;

    @Override
    public int outputAC() {
        return output;
    }
}

public class AC220 implements AC {
    public final int output = 220;

    @Override
    public int outputAC() {
        return output;
    }
}
</code></pre></div><p>适配器接口，其中 <code>support()</code> 方法用于检查输入的电压是否与适配器匹配，<code>outputDC5V()</code> 方法则用于将输入的电压变换为 5V 后输出</p> <div class="language- extra-class"><pre class="language-text"><code>public interface DC5Adapter {
    boolean support(AC ac);

    int outputDC5V(AC ac);
}
</code></pre></div><p>实现中国变压适配器和日本变压适配器</p> <div class="language- extra-class"><pre class="language-text"><code>public class ChinaPowerAdapter implements DC5Adapter {
    public static final int voltage = 220;
    
    @Override
    public boolean support(AC ac) {
        return (voltage == ac.outputAC());
    }
    
    @Override
    public int outputDC5V(AC ac) {
        int adapterInput = ac.outputAC();
        //变压器...
        int adapterOutput = adapterInput / 44;
        System.out.println(&quot;使用ChinaPowerAdapter变压适配器，输入AC:&quot; + adapterInput + &quot;V&quot; + &quot;，输出DC:&quot; + adapterOutput + &quot;V&quot;);
        return adapterOutput;
    }
}

public class JapanPowerAdapter implements DC5Adapter {
    public static final int voltage = 110;

    @Override
    public boolean support(AC ac) {
        return (voltage == ac.outputAC());
    }

    @Override
    public int outputDC5V(AC ac) {
        int adapterInput = ac.outputAC();
        //变压器...
        int adapterOutput = adapterInput / 22;
        System.out.println(&quot;使用JapanPowerAdapter变压适配器，输入AC:&quot; + adapterInput + &quot;V&quot; + &quot;，输出DC:&quot; + adapterOutput + &quot;V&quot;);
        return adapterOutput;
    }
}
</code></pre></div><p>测试，准备中国变压适配器和日本变压适配器各一个，定义一个方法可以根据电压找到合适的变压器，然后进行测试</p> <div class="language- extra-class"><pre class="language-text"><code>public class Test {
    private List&lt;DC5Adapter&gt; adapters = new LinkedList&lt;DC5Adapter&gt;();

    public Test() {
        this.adapters.add(new ChinaPowerAdapter());
        this.adapters.add(new JapanPowerAdapter());
    }

    // 根据电压找合适的变压器
    public DC5Adapter getPowerAdapter(AC ac) {
        DC5Adapter adapter = null;
        for (DC5Adapter ad : this.adapters) {
            if (ad.support(ac)) {
                adapter = ad;
                break;
            }
        }
        if (adapter == null){
            throw new  IllegalArgumentException(&quot;没有找到合适的变压适配器&quot;);
        }
        return adapter;
    }

    public static void main(String[] args) {
        Test test = new Test();
        AC chinaAC = new AC220();
        DC5Adapter adapter = test.getPowerAdapter(chinaAC);
        adapter.outputDC5V(chinaAC);

        // 去日本旅游，电压是 110V
        AC japanAC = new AC110();
        adapter = test.getPowerAdapter(japanAC);
        adapter.outputDC5V(japanAC);
    }
}
</code></pre></div><p>输出</p> <div class="language- extra-class"><pre class="language-text"><code>使用ChinaPowerAdapter变压适配器，输入AC:220V，输出DC:5V
使用JapanPowerAdapter变压适配器，输入AC:110V，输出DC:5V
</code></pre></div><h3 id="适配器模式总结"><a href="#适配器模式总结" class="header-anchor">#</a> 适配器模式总结</h3> <p><strong>主要优点</strong>：</p> <ol><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li> <li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li> <li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合 “开闭原则”。</li></ol> <p>具体来说，类适配器模式还有如下优点：</p> <ul><li>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</li></ul> <p>对象适配器模式还有如下优点：</p> <ul><li>一个对象适配器可以把多个不同的适配者适配到同一个目标；</li> <li>可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据 “里氏代换原则”，适配者的子类也可通过该适配器进行适配。</li></ul> <p>类适配器模式的缺点如下：</p> <ol><li>对于 Java、C# 等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；</li> <li>适配者类不能为最终类，如在 Java 中不能为 final 类，C# 中不能为 sealed 类；</li> <li>在 Java、C# 等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li></ol> <p>对象适配器模式的缺点如下：</p> <ul><li>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li></ul> <p><strong>适用场景</strong>：</p> <ul><li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</li> <li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ul> <h3 id="源码分析适配器模式的典型应用"><a href="#源码分析适配器模式的典型应用" class="header-anchor">#</a> 源码分析适配器模式的典型应用</h3> <h4 id="spring-aop-中的适配器模式"><a href="#spring-aop-中的适配器模式" class="header-anchor">#</a> spring AOP 中的适配器模式</h4> <p>在 Spring 的 Aop 中，使用的 <code>Advice（通知）</code> 来增强被代理类的功能。</p> <p><code>Advice</code>的类型有：<code>MethodBeforeAdvice</code>、<code>AfterReturningAdvice</code>、<code>ThrowsAdvice</code></p> <p>在每个类型 <code>Advice</code> 都有对应的拦截器，<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceInterceptor</code>、<code>ThrowsAdviceInterceptor</code></p> <p>Spring 需要将每个 <code>Advice</code> <strong>都封装成对应的拦截器类型</strong>，返回给容器，所以需要使用适配器模式对 <code>Advice</code> 进行转换</p> <p>三个适配者类 Adaptee 如下：</p> <div class="language- extra-class"><pre class="language-text"><code>public interface MethodBeforeAdvice extends BeforeAdvice {
    void before(Method var1, Object[] var2, @Nullable Object var3) throws Throwable;
}

public interface AfterReturningAdvice extends AfterAdvice {
    void afterReturning(@Nullable Object var1, Method var2, Object[] var3, @Nullable Object var4) throws Throwable;
}

public interface ThrowsAdvice extends AfterAdvice {
}
</code></pre></div><p>目标接口 Target，有两个方法，一个判断 <code>Advice</code> 类型是否匹配，一个是工厂方法，创建对应类型的 <code>Advice</code> 对应的拦截器</p> <div class="language- extra-class"><pre class="language-text"><code>public interface AdvisorAdapter {
    boolean supportsAdvice(Advice var1);

    MethodInterceptor getInterceptor(Advisor var1);
}
</code></pre></div><p>三个适配器类 Adapter 分别如下，注意其中的 Advice、Adapter、Interceptor 之间的对应关系</p> <div class="language- extra-class"><pre class="language-text"><code>class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {
	@Override
	public boolean supportsAdvice(Advice advice) {
		return (advice instanceof MethodBeforeAdvice);
	}

	@Override
	public MethodInterceptor getInterceptor(Advisor advisor) {
		MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();
		return new MethodBeforeAdviceInterceptor(advice);
	}
}

@SuppressWarnings(&quot;serial&quot;)
class AfterReturningAdviceAdapter implements AdvisorAdapter, Serializable {
	@Override
	public boolean supportsAdvice(Advice advice) {
		return (advice instanceof AfterReturningAdvice);
	}
	@Override
	public MethodInterceptor getInterceptor(Advisor advisor) {
		AfterReturningAdvice advice = (AfterReturningAdvice) advisor.getAdvice();
		return new AfterReturningAdviceInterceptor(advice);
	}
}

class ThrowsAdviceAdapter implements AdvisorAdapter, Serializable {
	@Override
	public boolean supportsAdvice(Advice advice) {
		return (advice instanceof ThrowsAdvice);
	}
	@Override
	public MethodInterceptor getInterceptor(Advisor advisor) {
		return new ThrowsAdviceInterceptor(advisor.getAdvice());
	}
}
</code></pre></div><p>客户端 DefaultAdvisorAdapterRegistry</p> <div class="language- extra-class"><pre class="language-text"><code>public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable {
    private final List&lt;AdvisorAdapter&gt; adapters = new ArrayList(3);

    public DefaultAdvisorAdapterRegistry() {
        // 这里注册了适配器
        this.registerAdvisorAdapter(new MethodBeforeAdviceAdapter());
        this.registerAdvisorAdapter(new AfterReturningAdviceAdapter());
        this.registerAdvisorAdapter(new ThrowsAdviceAdapter());
    }
    
    public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {
        List&lt;MethodInterceptor&gt; interceptors = new ArrayList(3);
        Advice advice = advisor.getAdvice();
        if (advice instanceof MethodInterceptor) {
            interceptors.add((MethodInterceptor)advice);
        }

        Iterator var4 = this.adapters.iterator();

        while(var4.hasNext()) {
            AdvisorAdapter adapter = (AdvisorAdapter)var4.next();
            if (adapter.supportsAdvice(advice)) {   // 这里调用适配器方法
                interceptors.add(adapter.getInterceptor(advisor));  // 这里调用适配器方法
            }
        }

        if (interceptors.isEmpty()) {
            throw new UnknownAdviceTypeException(advisor.getAdvice());
        } else {
            return (MethodInterceptor[])interceptors.toArray(new MethodInterceptor[0]);
        }
    }
    // ...省略...
}
</code></pre></div><p>这里看 while 循环里，逐个取出注册的适配器，调用 <code>supportsAdvice()</code> 方法来判断 <code>Advice</code> 对应的类型，然后调用 <code>getInterceptor()</code> 创建对应类型的拦截器</p> <p><img src="http://img.jssjqd.cn/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOV8yMjE3LmpwZw" alt=""></p> <p>这里应该属于对象适配器模式，关键字 <code>instanceof</code> 可看成是 <code>Advice</code> 的方法，不过这里的 <code>Advice</code> 对象是从外部传进来，而不是成员属性</p> <h4 id="spring-jpa-中的适配器模式"><a href="#spring-jpa-中的适配器模式" class="header-anchor">#</a> spring JPA 中的适配器模式</h4> <p>在 Spring 的 ORM 包中，对于 JPA 的支持也是采用了适配器模式，首先定义了一个接口的 <code>JpaVendorAdapter</code>，然后不同的持久层框架都实现此接口。</p> <p>jpaVendorAdapter：用于设置实现厂商 JPA 实现的特定属性，如设置 Hibernate 的是否自动生成 DDL 的属性 generateDdl；这些属性是厂商特定的，因此最好在这里设置；目前 Spring 提供 <code>HibernateJpaVendorAdapter</code>、<code>OpenJpaVendorAdapter</code>、<code>EclipseLinkJpaVendorAdapter</code>、<code>TopLinkJpaVendorAdapter</code> 四个实现。其中最重要的属性是 database，用来指定使用的数据库类型，从而能<strong>根据数据库类型来决定比如如何将数据库特定异常转换为 Spring 的一致性异常</strong>，目前支持如下数据库（DB2、DERBY、H2、HSQL、INFORMIX、MYSQL、ORACLE、POSTGRESQL、SQL_SERVER、SYBASE）</p> <div class="language- extra-class"><pre class="language-text"><code>public interface JpaVendorAdapter
{
  // 返回一个具体的持久层提供者
  public abstract PersistenceProvider getPersistenceProvider();

  // 返回持久层提供者的包名
  public abstract String getPersistenceProviderRootPackage();

  // 返回持久层提供者的属性
  public abstract Map&lt;String, ?&gt; getJpaPropertyMap();

  // 返回JpaDialect
  public abstract JpaDialect getJpaDialect();

  // 返回持久层管理器工厂
  public abstract Class&lt;? extends EntityManagerFactory&gt; getEntityManagerFactoryInterface();

  // 返回持久层管理器
  public abstract Class&lt;? extends EntityManager&gt; getEntityManagerInterface();

  // 自定义回调方法
  public abstract void postProcessEntityManagerFactory(EntityManagerFactory paramEntityManagerFactory);
}
</code></pre></div><p>我们来看其中一个适配器实现类 HibernateJpaVendorAdapter</p> <div class="language- extra-class"><pre class="language-text"><code>public class HibernateJpaVendorAdapter extends AbstractJpaVendorAdapter {
    //设定持久层提供者
    private final PersistenceProvider persistenceProvider;
    //设定持久层方言
    private final JpaDialect jpaDialect;

    public HibernateJpaVendorAdapter() {
        this.persistenceProvider = new HibernatePersistence();
        this.jpaDialect = new HibernateJpaDialect();
    }

    //返回持久层方言
    public PersistenceProvider getPersistenceProvider() {
        return this.persistenceProvider;
    }

    //返回持久层提供者
    public String getPersistenceProviderRootPackage() {
        return &quot;org.hibernate&quot;;
    }

    //返回JPA的属性
    public Map&lt;String, Object&gt; getJpaPropertyMap() {
        Map jpaProperties = new HashMap();

        if (getDatabasePlatform() != null) {
            jpaProperties.put(&quot;hibernate.dialect&quot;, getDatabasePlatform());
        } else if (getDatabase() != null) {
            Class databaseDialectClass = determineDatabaseDialectClass(getDatabase());
            if (databaseDialectClass != null) {
                jpaProperties.put(&quot;hibernate.dialect&quot;,
                        databaseDialectClass.getName());
            }
        }

        if (isGenerateDdl()) {
            jpaProperties.put(&quot;hibernate.hbm2ddl.auto&quot;, &quot;update&quot;);
        }
        if (isShowSql()) {
            jpaProperties.put(&quot;hibernate.show_sql&quot;, &quot;true&quot;);
        }

        return jpaProperties;
    }

    //设定数据库
    protected Class determineDatabaseDialectClass(Database database)     
    {                                                                                       
        switch (1.$SwitchMap$org$springframework$orm$jpa$vendor$Database[database.ordinal()]) 
        {                                                                                     
        case 1:                                                                             
          return DB2Dialect.class;                                                            
        case 2:                                                                               
          return DerbyDialect.class;                                                          
        case 3:                                                                               
          return H2Dialect.class;                                                             
        case 4:                                                                               
          return HSQLDialect.class;                                                           
        case 5:                                                                               
          return InformixDialect.class;                                                       
        case 6:                                                                               
          return MySQLDialect.class;                                                          
        case 7:                                                                               
          return Oracle9iDialect.class;                                                       
        case 8:                                                                               
          return PostgreSQLDialect.class;                                                     
        case 9:                                                                               
          return SQLServerDialect.class;                                                      
        case 10:                                                                              
          return SybaseDialect.class; }                                                       
        return null;              
    }

    //返回JPA方言
    public JpaDialect getJpaDialect() {
        return this.jpaDialect;
    }

    //返回JPA实体管理器工厂
    public Class&lt;? extends EntityManagerFactory&gt; getEntityManagerFactoryInterface() {
        return HibernateEntityManagerFactory.class;
    }

    //返回JPA实体管理器
    public Class&lt;? extends EntityManager&gt; getEntityManagerInterface() {
        return HibernateEntityManager.class;
    }
}
</code></pre></div><p>配置文件中可以这样指定</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;bean id=&quot;jpaVendorAdapter&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt; 
   &lt;property  /&gt;  
   &lt;property /&gt;  
&lt;/bean&gt;  
&lt;bean id=&quot;jpaDialect&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot;/&gt;
</code></pre></div><h4 id="spring-mvc-中的适配器模式"><a href="#spring-mvc-中的适配器模式" class="header-anchor">#</a> spring MVC 中的适配器模式</h4> <p>Spring MVC 中的适配器模式主要用于执行目标 <code>Controller</code> 中的请求处理方法。</p> <p>在 Spring MVC 中，<code>DispatcherServlet</code> 作为用户，<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</p> <p>为什么要在 Spring MVC 中使用适配器模式？Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code> 直接获取对应类型的 <code>Controller</code>，需要的自行来判断，像下面这段代码一样：</p> <div class="language- extra-class"><pre class="language-text"><code>if(mappedHandler.getHandler() instanceof MultiActionController){  
   ((MultiActionController)mappedHandler.getHandler()).xxx  
}else if(mappedHandler.getHandler() instanceof XXX){  
    ...  
}else if(...){  
   ...  
}
</code></pre></div><p>这样假设如果我们增加一个 <code>HardController</code>, 就要在代码中加入一行 <code>if(mappedHandler.getHandler() instanceof HardController)</code>，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p> <p>我们来看看源码，首先是适配器接口 <code>HandlerAdapter</code></p> <div class="language- extra-class"><pre class="language-text"><code>public interface HandlerAdapter {
    boolean supports(Object var1);

    ModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;

    long getLastModified(HttpServletRequest var1, Object var2);
}
</code></pre></div><p>现该接口的适配器每一个 <code>Controller</code> 都有一个适配器与之对应，这样的话，每自定义一个 <code>Controller</code> 需要定义一个实现 <code>HandlerAdapter</code> 的适配器。</p> <p>springmvc 中提供的 <code>Controller</code> 实现类有如下</p> <p><img src="http://img.jssjqd.cn/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOV8yMzMzMjcucG5n" alt=""></p> <p>springmvc 中提供的 <code>HandlerAdapter</code> 实现类如下</p> <p><img src="http://img.jssjqd.cn/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOV8yMzQzMjUucG5n" alt=""></p> <p><code>HttpRequestHandlerAdapter</code> 这个适配器代码如下</p> <div class="language- extra-class"><pre class="language-text"><code>public class HttpRequestHandlerAdapter implements HandlerAdapter {
    public HttpRequestHandlerAdapter() {
    }

    public boolean supports(Object handler) {
        return handler instanceof HttpRequestHandler;
    }

    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        ((HttpRequestHandler)handler).handleRequest(request, response);
        return null;
    }

    public long getLastModified(HttpServletRequest request, Object handler) {
        return handler instanceof LastModified ? ((LastModified)handler).getLastModified(request) : -1L;
    }
}
</code></pre></div><p>当 Spring 容器启动后，会将所有定义好的适配器对象存放在一个 List 集合中，当一个请求来临时，<code>DispatcherServlet</code> 会通过 <code>handler</code> 的类型找到对应适配器，并将该适配器对象返回给用户，然后就可以统一通过适配器的 <code>hanle()</code> 方法来调用 <code>Controller</code> 中的用于处理请求的方法。</p> <div class="language- extra-class"><pre class="language-text"><code>public class DispatcherServlet extends FrameworkServlet {
    private List&lt;HandlerAdapter&gt; handlerAdapters;
    
    //初始化handlerAdapters
    private void initHandlerAdapters(ApplicationContext context) {
        //..省略...
    }
    
    // 遍历所有的 HandlerAdapters，通过 supports 判断找到匹配的适配器
    protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
		for (HandlerAdapter ha : this.handlerAdapters) {
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Testing handler adapter [&quot; + ha + &quot;]&quot;);
			}
			if (ha.supports(handler)) {
				return ha;
			}
		}
	}
	
	// 分发请求，请求需要找到匹配的适配器来处理
	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
		HttpServletRequest processedRequest = request;
		HandlerExecutionChain mappedHandler = null;

		// Determine handler for the current request.
		mappedHandler = getHandler(processedRequest);
			
		// 确定当前请求的匹配的适配器.
		HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

		ha.getLastModified(request, mappedHandler.getHandler());
					
		mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
    }
	// ...省略...
}
</code></pre></div><p>通过适配器模式我们将所有的 <code>controller</code> 统一交给 <code>HandlerAdapter</code> 处理，免去了写大量的 <code>if-else</code> 语句对 <code>Controller</code> 进行判断，也更利于扩展新的 <code>Controller</code> 类型。</p> <blockquote><p>参考：<br>
刘伟：设计模式 Java 版<br>
慕课网 java 设计模式精讲 Debug 方式 + 内存分析<br>
孤落:<a href="https://blog.csdn.net/lu__peng/article/details/79117894" target="_blank" rel="noopener noreferrer">Spring MVC 中的适配器模式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br>
ToughMind_：<a href="https://blog.csdn.net/liuquan0071/article/details/50506121" target="_blank" rel="noopener noreferrer">深入浅出设计模式（五）：7. 适配器模式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote></div></div>  <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/03/18, 15:17:13</span></div></div> <div class="page-nav-wapper"><!----> <!----></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/bc8703/"><div>
            JVM调优实战及常量池详解
            <!----></div></a> <span class="date">03-14</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/5f19b8/"><div>
            Spring底层核心原理解析
            <!----></div></a> <span class="date">01-01</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/5a94a3/"><div>
            ElasticSearch 高级查询语法Query DSL实战
            <!----></div></a> <span class="date">12-11</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:894072666@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/xugaoyi" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2023
    <span>江</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.73613012.js" defer></script><script src="/assets/js/2.1211d3e1.js" defer></script><script src="/assets/js/16.7b69e07f.js" defer></script>
  </body>
</html>
